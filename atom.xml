<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>面试详解</title>
  
  
  <link href="https://data-cz.github.io/atom.xml" rel="self"/>
  
  <link href="https://data-cz.github.io/"/>
  <updated>2022-04-11T02:28:34.292Z</updated>
  <id>https://data-cz.github.io/</id>
  
  <author>
    <name>Chen Daxian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS 对象创建与拷贝</title>
    <link href="https://data-cz.github.io/2022/04/11/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://data-cz.github.io/2022/04/11/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2022-04-11T07:56:13.000Z</published>
    <updated>2022-04-11T02:28:34.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-对象创建与拷贝"><a href="#JS-对象创建与拷贝" class="headerlink" title="JS 对象创建与拷贝"></a>JS 对象创建与拷贝</h1><h3 id="五种创建对象的方法"><a href="#五种创建对象的方法" class="headerlink" title="五种创建对象的方法"></a>五种创建对象的方法</h3><p>1、对象字面量的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = &#123; <span class="attr">firstname</span>: <span class="string">&#x27;Mark&#x27;</span>, <span class="attr">lastname</span>: <span class="string">&#x27;Yun&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">eyecolor</span>: <span class="string">&#x27;black&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>2、用 function 来模拟无参的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Mark&#x27;</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;25&#x27;</span></span><br><span class="line">person.<span class="property">work</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(person.<span class="property">name</span> + <span class="string">&#x27; hello...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">work</span>()</span><br></pre></td></tr></table></figure><p>3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Pet</span>(<span class="params">name, age, hobby</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name <span class="comment">//this作用域：当前对象</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = hobby</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我叫&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;,我喜欢&#x27;</span> + <span class="variable language_">this</span>.<span class="property">hobby</span> + <span class="string">&#x27;,是个程序员&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maidou = <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&#x27;麦兜&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;coding&#x27;</span>) <span class="comment">//实例化、创建对象</span></span><br><span class="line">maidou.<span class="title function_">eat</span>() <span class="comment">//调用eat方法</span></span><br></pre></td></tr></table></figure><p>4、用工厂方式来创建（内置对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wcDog = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">wcDog.<span class="property">name</span> = <span class="string">&#x27;旺财&#x27;</span></span><br><span class="line">wcDog.<span class="property">age</span> = <span class="number">3</span></span><br><span class="line">wcDog.<span class="property">work</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;我是&#x27;</span> + wcDog.<span class="property">name</span> + <span class="string">&#x27;,汪汪汪......&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">wcDog.<span class="title function_">work</span>()</span><br></pre></td></tr></table></figure><p>5、用原型方式来创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;旺财&#x27;</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;是个吃货&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wangcai = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br></pre></td></tr></table></figure><p>合并两个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123; <span class="attr">b</span>: <span class="number">30</span>, <span class="attr">c</span>: <span class="number">40</span>, <span class="attr">d</span>: <span class="number">50</span> &#125;</span><br><span class="line"><span class="keyword">let</span> merged = &#123; ...object1, ...object2 &#125; <span class="comment">//spread and re-add into merged</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged) <span class="comment">// &#123;a:1, b:30, c:40, d:50&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。</p><ul><li>基本数据类型：直接存储在栈(stack)中的数据</li><li>引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</li></ul><p>深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。</p><ul><li>栈（stack）为自动分配的内存空间，它由系统自动释放。</li><li>堆（heap）则是动态分配的内存，大小不定也不会自动释放。</li></ul><h4 id="数据的比较"><a href="#数据的比较" class="headerlink" title="数据的比较"></a>数据的比较</h4><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h4><p>基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line"></span><br><span class="line">a++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125; <span class="comment">// a保存了一个空对象的实例</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">// a和b都指向了这个空对象</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;jozo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>) <span class="comment">// &#x27;jozo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>) <span class="comment">// &#x27;jozo&#x27;</span></span><br><span class="line"></span><br><span class="line">b.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>) <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;photography&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = obj</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; ...obj &#125;</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">obj.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">//&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3) <span class="comment">//&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj4) <span class="comment">//&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p>从以上例子可以看出，当数据为引用数据类型时</p><ol><li>直接赋值属于浅拷贝</li><li>Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。</li><li>扩展运算符和Object.assign原理一样。</li><li>JSON.parse(JSON.stringify(obj))可实现深拷贝</li></ol><h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h3><ol><li>JSON.parse(JSON.stringify(obj)) 但存在一些缺陷</li></ol><ul><li>对象的属性值是函数时，无法拷贝。</li><li>原型链上的属性无法拷贝</li><li>不能正确的处理 Date，RegExp 类型的数据</li><li>会忽略 undefined</li></ul><ol start="2"><li>实现一个 deepClone 函数</li></ol><ul><li>如果是基本数据类型，直接返回</li><li>如果是 RegExp 或者 Date 类型，返回对应类型</li><li>如果是复杂数据类型，递归。</li><li>考虑循环引用的问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">//递归拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, t)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">//是否是自身的属性</span></span><br><span class="line">      t[key] = <span class="title function_">deepClone</span>(obj[key], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-对象创建与拷贝&quot;&gt;&lt;a href=&quot;#JS-对象创建与拷贝&quot; class=&quot;headerlink&quot; title=&quot;JS 对象创建与拷贝&quot;&gt;&lt;/a&gt;JS 对象创建与拷贝&lt;/h1&gt;&lt;h3 id=&quot;五种创建对象的方法&quot;&gt;&lt;a href=&quot;#五种创建对象的方法&quot; c</summary>
      
    
    
    
    
    <category term="JS" scheme="https://data-cz.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://data-cz.github.io/2022/04/11/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://data-cz.github.io/2022/04/11/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2022-04-11T07:56:13.000Z</published>
    <updated>2022-04-11T02:28:10.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><p>应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。</p><h3 id="函数防抖（debounce）："><a href="#函数防抖（debounce）：" class="headerlink" title="函数防抖（debounce）："></a>函数防抖（debounce）：</h3><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><p>非立即执行版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);      </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>立即执行版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func,wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果</p><h4 id="防抖应用场景"><a href="#防抖应用场景" class="headerlink" title="防抖应用场景"></a>防抖应用场景</h4><ol><li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li><li>表单验证</li><li>按钮提交事件。</li><li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li></ol><h3 id="函数节流（throttle）："><a href="#函数节流（throttle）：" class="headerlink" title="函数节流（throttle）："></a>函数节流（throttle）：</h3><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器</p><p>时间戳版:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器版:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节流应用场景"><a href="#节流应用场景" class="headerlink" title="节流应用场景"></a>节流应用场景</h4><ol><li>按钮点击事件</li><li>拖拽事件</li><li>onScoll</li><li>计算鼠标移动的距离(mousemove)</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防抖与节流&quot;&gt;&lt;a href=&quot;#防抖与节流&quot; class=&quot;headerlink&quot; title=&quot;防抖与节流&quot;&gt;&lt;/a&gt;防抖与节流&lt;/h1&gt;&lt;p&gt;应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemov</summary>
      
    
    
    
    
    <category term="vue2.0" scheme="https://data-cz.github.io/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>vue3的生命周期</title>
    <link href="https://data-cz.github.io/2022/04/11/vue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://data-cz.github.io/2022/04/11/vue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-04-11T07:56:13.000Z</published>
    <updated>2022-04-11T02:26:14.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue3的生命周期"><a href="#vue3的生命周期" class="headerlink" title="vue3的生命周期"></a>vue3的生命周期</h1><p>vue3的生命周期对比vue2没有大的改变，只有<font color="red">beforeDestroy</font>和<font color="red">destroyed</font>换了名字，换成<font color="red">beforeUnmount</font>和<font color="red">unmounted</font>。注：如果在组合式API里面使用生命周期的变动就多了。</p><span id="more"></span><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-1252491761.cos.ap-beijing.myqcloud.com/vue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/v3.cn.vuejs.org_images_lifecycle.svg.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="vue2生命周期"><a href="#vue2生命周期" class="headerlink" title="vue2生命周期"></a>vue2生命周期</h2><p><a href="https://blog.langpz.com/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html">https://blog.langpz.com/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;vue3的生命周期&quot;&gt;&lt;a href=&quot;#vue3的生命周期&quot; class=&quot;headerlink&quot; title=&quot;vue3的生命周期&quot;&gt;&lt;/a&gt;vue3的生命周期&lt;/h1&gt;&lt;p&gt;vue3的生命周期对比vue2没有大的改变，只有&lt;font color=&quot;red&quot;&gt;beforeDestroy&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;destroyed&lt;/font&gt;换了名字，换成&lt;font color=&quot;red&quot;&gt;beforeUnmount&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;unmounted&lt;/font&gt;。注：如果在组合式API里面使用生命周期的变动就多了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="vue3.0" scheme="https://data-cz.github.io/tags/vue3-0/"/>
    
    <category term="生命周期" scheme="https://data-cz.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://data-cz.github.io/2022/04/07/hello-world/"/>
    <id>https://data-cz.github.io/2022/04/07/hello-world/</id>
    <published>2022-04-07T07:23:27.048Z</published>
    <updated>2022-04-11T01:46:40.656Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
