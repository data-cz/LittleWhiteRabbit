<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>面试详解</title>
  
  
  <link href="https://data-cz.github.io/atom.xml" rel="self"/>
  
  <link href="https://data-cz.github.io/"/>
  <updated>2022-04-13T02:17:39.253Z</updated>
  <id>https://data-cz.github.io/</id>
  
  <author>
    <name>Chen Daxian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue 组件下拉加载更多</title>
    <link href="https://data-cz.github.io/2022/04/13/Vue%20%E7%BB%84%E4%BB%B6%E4%B8%8B%E6%8B%89%20%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/"/>
    <id>https://data-cz.github.io/2022/04/13/Vue%20%E7%BB%84%E4%BB%B6%E4%B8%8B%E6%8B%89%20%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/</id>
    <published>2022-04-13T01:46:34.427Z</published>
    <updated>2022-04-13T02:17:39.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、新建一个loadingMessage组件"><a href="#一、新建一个loadingMessage组件" class="headerlink" title="一、新建一个loadingMessage组件"></a>一、新建一个loadingMessage组件</h2><h3 id="1-1-监听滑动"><a href="#1-1-监听滑动" class="headerlink" title="1.1 监听滑动"></a>1.1 监听滑动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&quot;content&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="1-1-挂载监听"><a href="#1-1-挂载监听" class="headerlink" title="1.1 挂载监听"></a>1.1 挂载监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    this.$refs.content.scrollTag = 0; // 标记监听数</span><br><span class="line">    // 挂载监听</span><br><span class="line">    this.listenerScroll();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="1-2-加载数据时候设置高度"><a href="#1-2-加载数据时候设置高度" class="headerlink" title="1.2 加载数据时候设置高度"></a>1.2 加载数据时候设置高度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updated() &#123;</span><br><span class="line">  this.scrollHeight = this.$refs.content.scrollHeight; // 加载数据时设置滚动内容高</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="1-3-离开页面销毁监听组件"><a href="#1-3-离开页面销毁监听组件" class="headerlink" title="1.3 离开页面销毁监听组件"></a>1.3 离开页面销毁监听组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() &#123;</span><br><span class="line">  this.destroyScroll()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="1-3-watch-监听，滑动到顶部事件"><a href="#1-3-watch-监听，滑动到顶部事件" class="headerlink" title="1.3 watch 监听，滑动到顶部事件"></a>1.3 watch 监听，滑动到顶部事件</h3>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  scrollHeight: function(newHeight,oldHeight)&#123; // 加载数据时设置滚动条</span><br><span class="line">    if(this.scrollTop === 0)&#123; // scrollTop 为0时说明时下拉加载操作</span><br><span class="line">      this.$refs.content.scrollTop = newHeight - oldHeight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  interlocutor: function()&#123;</span><br><span class="line">    this.scrollToBottom();  // 滚动条至底</span><br><span class="line">    this.listenerScroll();  // 重现挂载监听</span><br><span class="line">  &#125;,</span><br><span class="line">  loadingStatus: function(newStatus,oldStatus) &#123; // 加载完全部数据时移除滚动条监听</span><br><span class="line">    if(newStatus === 2)&#123;</span><br><span class="line">      this.destroyScroll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="1-4-监听-滑动-滚动事件"><a href="#1-4-监听-滑动-滚动事件" class="headerlink" title="1.4  监听 滑动 滚动事件"></a>1.4  监听 滑动 滚动事件</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  // 滚动监听处理</span><br><span class="line">  handleScroll(e)&#123;</span><br><span class="line">    this.scrollTop = e.srcElement.scrollTop; // 距离顶部</span><br><span class="line">    this.scrollHeight = e.srcElement.scrollHeight; // 滚动内容高</span><br><span class="line">    this.clientHeight = e.srcElement.clientHeight; // 滚动区域高</span><br><span class="line">    if(this.scrollTop ===  0) &#123; // 滚动触顶调用</span><br><span class="line">      this.$emit(&#x27;onTouchTop&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(this.scrollHeight === this.scrollTop + this.clientHeight)&#123; // 滚动触底调用</span><br><span class="line">      this.$emit(&#x27;onTouchBottom&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 添加滚动监听事件</span><br><span class="line">  listenerScroll() &#123;</span><br><span class="line">    if(this.$refs.content.scrollTag !== 0) return;</span><br><span class="line">    this.$refs.content.scrollTag++;</span><br><span class="line">    this.$refs.content.addEventListener(&#x27;scroll&#x27;, this.handleScroll, true);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 移除滚动监听事件</span><br><span class="line">  destroyScroll() &#123;</span><br><span class="line">    if(this.$refs.content.scrollTag !== 1) return;</span><br><span class="line">    this.$refs.content.scrollTag--;</span><br><span class="line">    this.$refs.content.removeEventListener(&quot;scroll&quot;, this.handleScroll, true);</span><br><span class="line">  &#125;,</span><br><span class="line">  scrollToBottom() &#123; //滚动条置底</span><br><span class="line">    this.$nextTick(function()&#123;</span><br><span class="line">      this.$refs.content.scrollTop</span><br><span class="line">        = this.$refs.content.scrollHeight - this.$refs.content.clientHeight;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、新建一个loadingMessage组件&quot;&gt;&lt;a href=&quot;#一、新建一个loadingMessage组件&quot; class=&quot;headerlink&quot; title=&quot;一、新建一个loadingMessage组件&quot;&gt;&lt;/a&gt;一、新建一个loadingMessage组件&lt;/h2&gt;&lt;h3 id=&quot;1-1-监听滑动&quot;&gt;&lt;a href=&quot;#1-1-监听滑动&quot; class=&quot;headerlink&quot; title=&quot;1.1 监听滑动&quot;&gt;&lt;/a&gt;1.1 监听滑动&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div ref=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;1-1-挂载监听&quot;&gt;&lt;a href=&quot;#1-1-挂载监听&quot; class=&quot;headerlink&quot; title=&quot;1.1 挂载监听&quot;&gt;&lt;/a&gt;1.1 挂载监听&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mounted() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.$refs.content.scrollTag = 0; // 标记监听数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 挂载监听&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.listenerScroll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Vue" scheme="https://data-cz.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://data-cz.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SVG 转地图json 数据</title>
    <link href="https://data-cz.github.io/2022/04/13/svg-to-geojson/"/>
    <id>https://data-cz.github.io/2022/04/13/svg-to-geojson/</id>
    <published>2022-04-13T01:46:34.408Z</published>
    <updated>2022-04-13T02:00:52.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="svg-yo-geojson"><a href="#svg-yo-geojson" class="headerlink" title="svg-yo-geojson"></a>svg-yo-geojson</h1><p> svg 转 json</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://github.com/data-cz/svg-to-geojson.git">DEMO_HERE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;svg-yo-geojson&quot;&gt;&lt;a href=&quot;#svg-yo-geojson&quot; class=&quot;headerlink&quot; title=&quot;svg-yo-geojson&quot;&gt;&lt;/a&gt;svg-yo-geojson&lt;/h1&gt;&lt;p&gt; svg 转 json&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="Map" scheme="https://data-cz.github.io/categories/Map/"/>
    
    
    <category term="json" scheme="https://data-cz.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>前端需要注意哪些SEO</title>
    <link href="https://data-cz.github.io/2022/04/13/SEO/"/>
    <id>https://data-cz.github.io/2022/04/13/SEO/</id>
    <published>2022-04-13T01:46:34.401Z</published>
    <updated>2022-04-13T02:19:17.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a>前端需要注意哪些SEO</h3><ul><li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li><li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用js输出：爬虫不会执行js获取内容</li><li>少用iframe：搜索引擎不会抓取iframe中的内容</li><li>非装饰性图片必须加alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标<span id="more"></span></li></ul><p><strong>如何做SEO优化?</strong></p><ul><li>标题与关键词</li></ul><ul><li>设置有吸引力切合实际的标题，标题中要包含所做的关键词</li></ul><ul><li>网站结构目录</li></ul><ul><li>最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布</li></ul><ul><li>页面元素</li></ul><ul><li>给图片标注”Alt”可以让搜索引擎更友好的收录</li></ul><ul><li>网站内容</li></ul><ul><li>每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢</li></ul><ul><li>友情链接</li></ul><ul><li>对方一定要是正规网站，每天有专业的团队或者个人维护更新</li></ul><ul><li>内链的布置</li></ul><ul><li>使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接</li></ul><ul><li>流量分析</li></ul><ul><li>通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前端需要注意哪些SEO&quot;&gt;&lt;a href=&quot;#前端需要注意哪些SEO&quot; class=&quot;headerlink&quot; title=&quot;前端需要注意哪些SEO&quot;&gt;&lt;/a&gt;前端需要注意哪些SEO&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可&lt;/li&gt;
&lt;li&gt;语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页&lt;/li&gt;
&lt;li&gt;重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取&lt;/li&gt;
&lt;li&gt;重要内容不要用js输出：爬虫不会执行js获取内容&lt;/li&gt;
&lt;li&gt;少用iframe：搜索引擎不会抓取iframe中的内容&lt;/li&gt;
&lt;li&gt;非装饰性图片必须加alt&lt;/li&gt;
&lt;li&gt;提高网站速度：网站速度是搜索引擎排序的一个重要指标</summary>
    
    
    
    <category term="前端" scheme="https://data-cz.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Web" scheme="https://data-cz.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>2020年你不能不知道的webpack基本配置</title>
    <link href="https://data-cz.github.io/2022/04/13/2020%E5%B9%B4%E4%BD%A0%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>https://data-cz.github.io/2022/04/13/2020%E5%B9%B4%E4%BD%A0%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-13T01:46:32.651Z</published>
    <updated>2022-04-13T02:16:58.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况：</p><ul><li>需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。</li><li>传统的<code>html+css+js</code>开发方式不能不能很好地运用<code>less/scss</code>等css预处理器以及<code>ES6+</code>的高级语法。</li><li>代码复用性差，可维护性差。  <span id="more"></span>此时就需要一个处理这些问题的工具，webpack应运而生。</li></ul><p>webpack可以看做是模块打包工具：它将各种静态资源（比如：<code>javaScript</code> 文件，图片文件，<code>css</code>文件等）视为模块，它能够对这些模块进行解析优化和转换等操作，最后将它们打包在一起，打包后的文件可用于在浏览器中使用。</p><h3 id="webpack的优点："><a href="#webpack的优点：" class="headerlink" title="webpack的优点："></a>webpack的优点：</h3><ul><li>代码转换: <code>typeScript</code> 编译成 <code>javaScript</code>、<code>scss，less</code> 编译成 <code>css</code>.</li><li>文件优化：压缩 <code>javaScript</code>、<code>css</code>、<code>html</code> 代码，压缩合并图片。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>扩展性强，插件机制完善。</li></ul><h3 id="webpack打包过程："><a href="#webpack打包过程：" class="headerlink" title="webpack打包过程："></a>webpack打包过程：</h3><ol><li>利用babel完成代码转换,并生成单个文件的依赖</li><li>从入口开始递归分析，并生成依赖图谱</li><li>将各个引用模块打包为一个立即执行函数</li><li>将最终的bundle文件写入bundle.js中</li></ol><h3 id="Webpack-的四大核心："><a href="#Webpack-的四大核心：" class="headerlink" title="Webpack 的四大核心："></a>Webpack 的四大核心：</h3><ul><li>entry：js 入口源文件</li><li>output：生成文件</li><li>loader：进行文件处理</li><li>plugins：插件，比 loader 更强大，能使用更多 webpack 的 api</li></ul><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>webpack 应该使用哪个模块做为入口文件，来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。  </p><p>单⼊⼝：entry 是⼀个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多⼊⼝：entry 是⼀个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">manager</span>: <span class="string">&#x27;./src/manager.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，这些都可以在webpack的配置文件中指定。</p><p>单⼊⼝配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js’,</span></span><br><span class="line"><span class="string">        path: __dirname + &#x27;</span>/dist<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>多⼊⼝配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过[name]占位符确保⽂件名称的唯⼀</p><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p><code>loader</code> 让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<code>webpack</code> 自身只理解 <code>javaScript</code>）。<code>loader</code> 可以将所有类型的文件转换为 <code>webpack</code> 能够处理的有效模块，然后你就可以利用 <code>webpack</code> 的打包能力，对它们进行处理。</p><h3 id="loader的特点"><a href="#loader的特点" class="headerlink" title="loader的特点"></a>loader的特点</h3><ul><li>一个Loader 的职责是单一的，只需要完成一种转换</li><li>一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数</li><li>loader 总是从右到左地被调用。</li></ul><h3 id="常用的loader"><a href="#常用的loader" class="headerlink" title="常用的loader"></a>常用的loader</h3><h4 id="处理样式"><a href="#处理样式" class="headerlink" title="处理样式"></a>处理样式</h4><ul><li><code>css-loader</code>: 加载.css 文件，</li><li><code>style-loader</code>:使用 style 标签将 <code>css-loader</code> 内部样式注入到我们的 html 页面</li><li><code>less-loader, sass-loader</code>: 解析css预处理器</li></ul><h4 id="处理-js"><a href="#处理-js" class="headerlink" title="处理 js"></a>处理 js</h4><ul><li>让你能使用最新的js代码（ES6，ES7…）</li><li>让你能使用基于js进行了拓展的语言，比如React的JSX；</li></ul><h4 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h4><p>处理图片资源时，我们常用的两种loader是<code>file-loader</code>或者<code>url-loader</code>，两者的主要差异在于。<code>url-loader</code>可以设置图片大小限制，当图片超过限制时，其表现行为等同于<code>file-loader</code>，而当图片不超过限制时，则会将图片以<code>base64</code>的形式打包进css文件，以减少请求次数</p><h4 id="处理-vue文件"><a href="#处理-vue文件" class="headerlink" title="处理.vue文件"></a>处理.vue文件</h4><p><code>vue-loader</code> 是 <code>webpack</code> 的加载器模块，它使我们可以用 <code>.vue</code> 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 <code>vue-loader</code> 模块允许 <code>webpack</code> 使用单独的加载器模块（例如 <code>sass 或 scss 加载器</code>）提取和处理每个部分。该设置使我们可以使用 <code>.vue</code> 文件无缝编写程序。</p><h3 id="开发一个loader"><a href="#开发一个loader" class="headerlink" title="开发一个loader"></a>开发一个loader</h3><!-- 1. 基本形式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source </span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> source; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用第三方模块<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sass= <span class="built_in">require</span>(<span class="string">&#x27;node-sass&#x27;</span>); </span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sass</span>(source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">需求：手写一个 `</span><span class="string">`loader`</span><span class="string">`，将 `</span><span class="string">`&#x27;kobe&#x27;`</span><span class="string">` 转换成 `</span><span class="string">`&#x27;Black Mamba&#x27;`</span><span class="string">`。当然大家可以根据自己的需求进行设计。这里只是讲解方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 1、编写 loader</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在根目录下，新建目录 `</span><span class="string">`kobe-loader`</span><span class="string">` 作为我们编写 `</span><span class="string">`loader`</span><span class="string">` 的名称，执行 `</span><span class="string">`npm init -y`</span><span class="string">` 命令，新建一个模块化项目，然后新建 `</span><span class="string">`index.js`</span><span class="string">` 文件，相关源码如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> content &amp;&amp; content.<span class="title function_">replace</span>(<span class="regexp">/kobe/gi</span>, <span class="string">&#x27;Black Mamba&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、注册模块"><a href="#2、注册模块" class="headerlink" title="2、注册模块"></a>2、注册模块</h4><p>正常我们安装的 <code>loader</code> 是从 <code>npm</code> 下载安装，但是我们可以在 <code>kobe-loader</code> 目录底下使用 <code>npm link</code> 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 <code>node_modules</code> 目录下，让项目可以直接使用本地的 <code>npm</code> 模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>然后在项目根目录执行以下命令，将注册到全局的本地 <code>npm</code> 模块链接到项目的 <code>node_modules</code> 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm link kobe-loader</span><br></pre></td></tr></table></figure><p>注册成功后，我们可以在 <code>node_modules</code> 目录下能查找到对应的 <code>loader</code>。</p><h4 id="3、在-webpack-中配置-loader"><a href="#3、在-webpack-中配置-loader" class="headerlink" title="3、在 webpack 中配置 loader"></a>3、在 webpack 中配置 loader</h4><p>在 <code>webpack.base.conf.js</code> 加上如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>:<span class="regexp">/\.js/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;kobe-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们在所有 js 文件下书写的 <code>&#39;kobe&#39;</code> 就全部替换成 <code>&#39;Black Mamba&#39;</code>了。</p><h4 id="4、配置参数"><a href="#4、配置参数" class="headerlink" title="4、配置参数"></a>4、配置参数</h4><p>上面我们是写死的替换文案，假如我想通过配置项来改变，可以在 loader 中做以下调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom-loader/index.js</span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;loader-utils&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = utils.<span class="title function_">getOptions</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">return</span> content &amp;&amp; content.<span class="title function_">replace</span>(<span class="regexp">/kobe/gi</span>, options.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.base.conf.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>:<span class="regexp">/\.js/</span>,</span><br><span class="line">  <span class="attr">use</span>: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;kobe-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。</p><h3 id="Plugin-的特点"><a href="#Plugin-的特点" class="headerlink" title="Plugin 的特点"></a>Plugin 的特点</h3><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply </code>方法 <code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 <code>webpack</code> 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 <code>callback</code></li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 <code>callback</code> 回调。</li></ul><h3 id="常用Plugin"><a href="#常用Plugin" class="headerlink" title="常用Plugin"></a>常用Plugin</h3><ul><li><p><code>HotModuleReplacementPlugin</code> 代码热替换。因为 <code>Hot-Module-Replacement</code> 的热更新是依赖于 <code>webpack-dev-server</code>，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，<code>HRM</code> 是只更新修改的部分。</p></li><li><p><code>HtmlWebpackPlugin</code>, 生成 html 文件。将 webpack 中<code>entry</code>配置的相关入口 chunk 和 <code>extract-text-webpack-plugin</code>抽取的 css 样式 插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</p></li><li><p><code>ExtractTextPlugin</code>, 将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。</p></li><li><p><code>NoErrorsPlugin</code>报错但不退出 webpack 进程</p></li><li><p><code>UglifyJsPlugin</code>，代码丑化，开发过程中不建议打开。 <code>uglifyJsPlugin</code> 用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。<code>uglifyJsPlugin</code> 会拖慢 webpack 的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。多个 html 共用一个 js 文件(chunk)，可用 <code>CommonsChunkPlugin</code></p></li><li><p><code>purifycss-webpack</code>  。打包编译时，可剔除页面和 js 中未被使用的 css，这样使用第三方的类库时，只加载被使用的类，大大减小 css 体积</p></li><li><p><code>optimize-css-assets-webpack-plugin</code>   压缩 css，优化 css 结构，利于网页加载和渲染</p></li><li><p><code>webpack-parallel-uglify-plugin</code>   可以并行运行 UglifyJS 插件，这可以有效减少构建时间</p></li></ul><h3 id="开发一个-plugin"><a href="#开发一个-plugin" class="headerlink" title="开发一个 plugin"></a>开发一个 plugin</h3><ul><li>Webpack 在编译过程中，会广播很多事件，例如 run、compile、done、fail 等等，可以查看官网；</li><li>Webpack 的事件流机制应用了观察者模式，我们编写的插件可以监听 Webpack 事件来触发对应的处理逻辑；</li><li>插件中可以使用很多 Webpack 提供的 API，例如读取输出资源、代码块、模块及依赖等；</li></ul><h4 id="1、编写插件"><a href="#1、编写插件" class="headerlink" title="1、编写插件"></a>1、编写插件</h4><p>在根目录下，新建目录 my-plugin 作为我们编写插件的名称，执行 npm init -y 命令，新建一个模块化项目，然后新建 index.js 文件，相关源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">doneCallback, failCallback</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存在创建插件实例时传入的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">doneCallback</span> = doneCallback</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">failCallback</span> = failCallback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功完成一次完整的编译和输出流程时，会触发 done 事件</span></span><br><span class="line">    compiler.<span class="title function_">plugin</span>(<span class="string">&#x27;done&#x27;</span>, <span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">doneCallback</span>(stats)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 在编译和输出的流程中遇到异常时，会触发 failed 事件</span></span><br><span class="line">    compiler.<span class="title function_">plugin</span>(<span class="string">&#x27;failed&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">failCallback</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPlugin</span></span><br></pre></td></tr></table></figure><h4 id="2、注册模块-1"><a href="#2、注册模块-1" class="headerlink" title="2、注册模块"></a>2、注册模块</h4><p>按照以上的方法，我们在 my-plugin 目录底下使用 npm link 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 npm 模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>然后在项目根目录执行以下命令，将注册到全局的本地 npm 模块链接到项目的 node_modules 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm link my-plugin</span><br></pre></td></tr></table></figure><p>注册成功后，我们可以在 node_modules 目录下能查找到对应的插件了。</p><h4 id="3、配置插件"><a href="#3、配置插件" class="headerlink" title="3、配置插件"></a>3、配置插件</h4><p>在 webpack.base.conf.js 加上如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">MyPlugin</span>(</span><br><span class="line">    <span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;编译成功!&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;编译失败!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>执行运行 or 编译命令，就能看到我们的 plugin 起作用了。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。&lt;/li&gt;
&lt;li&gt;传统的&lt;code&gt;html+css+js&lt;/code&gt;开发方式不能不能很好地运用&lt;code&gt;less/scss&lt;/code&gt;等css预处理器以及&lt;code&gt;ES6+&lt;/code&gt;的高级语法。&lt;/li&gt;
&lt;li&gt;代码复用性差，可维护性差。</summary>
    
    
    
    <category term="webpack" scheme="https://data-cz.github.io/categories/webpack/"/>
    
    
    <category term="webpack" scheme="https://data-cz.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://data-cz.github.io/2022/04/13/hello-world-hexo/"/>
    <id>https://data-cz.github.io/2022/04/13/hello-world-hexo/</id>
    <published>2022-04-13T01:41:20.276Z</published>
    <updated>2022-04-14T02:07:35.721Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p>正文<br>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要&lt;/p&gt;</summary>
    
    
    
    <category term="分类" scheme="https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="PS3" scheme="https://data-cz.github.io/tags/PS3/"/>
    
    <category term="Games" scheme="https://data-cz.github.io/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="https://data-cz.github.io/2022/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/"/>
    <id>https://data-cz.github.io/2022/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/</id>
    <published>2022-04-12T10:07:00.353Z</published>
    <updated>2022-04-13T02:17:02.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目：谈一谈你对CSS盒模型的认识"><a href="#题目：谈一谈你对CSS盒模型的认识" class="headerlink" title="题目：谈一谈你对CSS盒模型的认识"></a>题目：谈一谈你对CSS盒模型的认识</h2><blockquote><p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p></blockquote><ol><li><p>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></p></li><li><p>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</p></li><li><p><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</p></li><li><p><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</p></li><li><p>实例题：根据盒模型解释<strong>边距重叠</strong>。</p><span id="more"></span><blockquote><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p></blockquote></li><li><p><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</p></li></ol><blockquote><p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p></blockquote><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p><p>接下来，我们把上面的六条，依次讲解。</p><p><strong>标准盒模型和IE盒子模型</strong></p><p>标准盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg"></p><p><code>IE</code>盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg"></p><p>上图显示：</p><blockquote><p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p></blockquote><ul><li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li><code>padding</code>：内边距。</li><li><code>border</code>：边框。</li><li><code>margin</code>：外边距。</li></ul><blockquote><p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p></blockquote><ul><li><p>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p></li></ul><p><strong>CSS如何设置这两种模型</strong></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-<span class="attr">sizing</span>: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-<span class="attr">sizing</span>: border-box;</span><br></pre></td></tr></table></figure><blockquote><p>备注：盒子默认为标准盒模型。</p></blockquote><p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p><blockquote><p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">style</span>.<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p></blockquote><p>这种方式有局限性，但应该了解。</p><blockquote><p>方式二（通用型）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(element).<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p></blockquote><blockquote><p>方式三（IE独有的）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">currentStyle</span>.<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p></blockquote><blockquote><p>方式四</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p></blockquote><p><strong>margin塌陷&#x2F;margin重叠</strong></p><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p><blockquote><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p></blockquote><blockquote><p>我们来看几个例子。</p></blockquote><p><strong>兄弟元素之间</strong></p><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png"></p><p><strong>子元素和父元素之间</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p></blockquote><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png"></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png"></p><blockquote><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p></blockquote><p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1537.png"></p><blockquote><p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1544.png"></p><blockquote><p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p></blockquote><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><blockquote><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。</p></blockquote><p><strong>BFC（边距重叠解决方案）</strong></p><blockquote><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p></blockquote><p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p><p><strong>BFC 的原理&#x2F;BFC的布局规则【非常重要】</strong></p><blockquote><p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p></blockquote><ol><li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li><li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li><li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li><li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li></ol><p><strong>如何生成BFC</strong></p><blockquote><p>有以下几种方法：</p></blockquote><ul><li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li><li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li><li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li><li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li></ul><p><strong>BFC 的应用</strong></p><p><strong>举例1：</strong>解决 margin 重叠</p><blockquote><p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p></blockquote><p>比如说，针对下面这样一个 <code>div</code> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p></blockquote><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">150px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father-layout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png"></p><blockquote><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p></blockquote><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.smyhvae.com/20180306_0827.png"></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png"></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><blockquote><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_0845.png"></p><blockquote><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目：谈一谈你对CSS盒模型的认识&quot;&gt;&lt;a href=&quot;#题目：谈一谈你对CSS盒模型的认识&quot; class=&quot;headerlink&quot; title=&quot;题目：谈一谈你对CSS盒模型的认识&quot;&gt;&lt;/a&gt;题目：谈一谈你对CSS盒模型的认识&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;专业的面试，一定会问 &lt;code&gt;CSS&lt;/code&gt; 盒模型。对于这个题目，我们要回答一下几个方面：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本概念：&lt;code&gt;content&lt;/code&gt;、&lt;code&gt;padding&lt;/code&gt;、&lt;code&gt;margin&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标准盒模型、&lt;code&gt;IE&lt;/code&gt;盒模型的区别。不要漏说了&lt;code&gt;IE&lt;/code&gt;盒模型，通过这个问题，可以筛选一部分人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;CSS&lt;/code&gt;如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JS&lt;/code&gt;如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实例题：根据盒模型解释&lt;strong&gt;边距重叠&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="css" scheme="https://data-cz.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://data-cz.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS盒模型的认识</title>
    <link href="https://data-cz.github.io/2022/04/07/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>https://data-cz.github.io/2022/04/07/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86/</id>
    <published>2022-04-07T07:34:10.000Z</published>
    <updated>2022-04-13T02:18:02.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目：谈一谈你对CSS盒模型的认识"><a href="#题目：谈一谈你对CSS盒模型的认识" class="headerlink" title="题目：谈一谈你对CSS盒模型的认识"></a>题目：谈一谈你对CSS盒模型的认识</h2><blockquote><p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p></blockquote><ol><li><p>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></p></li><li><p>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</p></li><li><p><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</p></li><li><p><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</p></li><li><p>实例题：根据盒模型解释<strong>边距重叠</strong>。</p><span id="more"></span><blockquote><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p></blockquote></li><li><p><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</p></li></ol><blockquote><p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p></blockquote><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p><p>接下来，我们把上面的六条，依次讲解。</p><p><strong>标准盒模型和IE盒子模型</strong></p><p>标准盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg"></p><p><code>IE</code>盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg"></p><p>上图显示：</p><blockquote><p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p></blockquote><ul><li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li><code>padding</code>：内边距。</li><li><code>border</code>：边框。</li><li><code>margin</code>：外边距。</li></ul><blockquote><p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p></blockquote><ul><li><p>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p></li></ul><p><strong>CSS如何设置这两种模型</strong></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-<span class="attr">sizing</span>: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-<span class="attr">sizing</span>: border-box;</span><br></pre></td></tr></table></figure><blockquote><p>备注：盒子默认为标准盒模型。</p></blockquote><p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p><blockquote><p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">style</span>.<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p></blockquote><p>这种方式有局限性，但应该了解。</p><blockquote><p>方式二（通用型）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(element).<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p></blockquote><blockquote><p>方式三（IE独有的）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">currentStyle</span>.<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p></blockquote><blockquote><p>方式四</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span>/height;</span><br></pre></td></tr></table></figure><blockquote><p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p></blockquote><p><strong>margin塌陷&#x2F;margin重叠</strong></p><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p><blockquote><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p></blockquote><blockquote><p>我们来看几个例子。</p></blockquote><p><strong>兄弟元素之间</strong></p><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png"></p><p><strong>子元素和父元素之间</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p></blockquote><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png"></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png"></p><blockquote><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p></blockquote><p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1537.png"></p><blockquote><p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1544.png"></p><blockquote><p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p></blockquote><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><blockquote><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。</p></blockquote><p><strong>BFC（边距重叠解决方案）</strong></p><blockquote><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p></blockquote><p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p><p><strong>BFC 的原理&#x2F;BFC的布局规则【非常重要】</strong></p><blockquote><p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p></blockquote><ol><li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li><li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li><li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li><li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li></ol><p><strong>如何生成BFC</strong></p><blockquote><p>有以下几种方法：</p></blockquote><ul><li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li><li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li><li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li><li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li></ul><p><strong>BFC 的应用</strong></p><p><strong>举例1：</strong>解决 margin 重叠</p><blockquote><p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p></blockquote><p>比如说，针对下面这样一个 <code>div</code> 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p></blockquote><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">150px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father-layout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png"></p><blockquote><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p></blockquote><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.smyhvae.com/20180306_0827.png"></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png"></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><blockquote><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_0845.png"></p><blockquote><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目：谈一谈你对CSS盒模型的认识&quot;&gt;&lt;a href=&quot;#题目：谈一谈你对CSS盒模型的认识&quot; class=&quot;headerlink&quot; title=&quot;题目：谈一谈你对CSS盒模型的认识&quot;&gt;&lt;/a&gt;题目：谈一谈你对CSS盒模型的认识&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;专业的面试，一定会问 &lt;code&gt;CSS&lt;/code&gt; 盒模型。对于这个题目，我们要回答一下几个方面：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本概念：&lt;code&gt;content&lt;/code&gt;、&lt;code&gt;padding&lt;/code&gt;、&lt;code&gt;margin&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标准盒模型、&lt;code&gt;IE&lt;/code&gt;盒模型的区别。不要漏说了&lt;code&gt;IE&lt;/code&gt;盒模型，通过这个问题，可以筛选一部分人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;CSS&lt;/code&gt;如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JS&lt;/code&gt;如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实例题：根据盒模型解释&lt;strong&gt;边距重叠&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JS防抖与节流</title>
    <link href="https://data-cz.github.io/2020/04/14/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://data-cz.github.io/2020/04/14/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2020-04-14T02:06:22.000Z</published>
    <updated>2022-04-14T02:10:11.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><p>应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。</p><span id="more"></span><h3 id="函数防抖（debounce）："><a href="#函数防抖（debounce）：" class="headerlink" title="函数防抖（debounce）："></a>函数防抖（debounce）：</h3><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><p>非立即执行版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);      </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>立即执行版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func,wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果</p><h4 id="防抖应用场景"><a href="#防抖应用场景" class="headerlink" title="防抖应用场景"></a>防抖应用场景</h4><ol><li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li><li>表单验证</li><li>按钮提交事件。</li><li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li></ol><h3 id="函数节流（throttle）："><a href="#函数节流（throttle）：" class="headerlink" title="函数节流（throttle）："></a>函数节流（throttle）：</h3><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器</p><p>时间戳版:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器版:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节流应用场景"><a href="#节流应用场景" class="headerlink" title="节流应用场景"></a>节流应用场景</h4><ol><li>按钮点击事件</li><li>拖拽事件</li><li>onScoll</li><li>计算鼠标移动的距离(mousemove)</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;防抖与节流&quot;&gt;&lt;a href=&quot;#防抖与节流&quot; class=&quot;headerlink&quot; title=&quot;防抖与节流&quot;&gt;&lt;/a&gt;防抖与节流&lt;/h1&gt;&lt;p&gt;应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JS对象创建与拷贝</title>
    <link href="https://data-cz.github.io/2020/04/14/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://data-cz.github.io/2020/04/14/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-04-14T02:05:22.000Z</published>
    <updated>2022-04-14T02:09:52.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-对象创建与拷贝"><a href="#JS-对象创建与拷贝" class="headerlink" title="JS 对象创建与拷贝"></a>JS 对象创建与拷贝</h1><h3 id="五种创建对象的方法"><a href="#五种创建对象的方法" class="headerlink" title="五种创建对象的方法"></a>五种创建对象的方法</h3><p>1、对象字面量的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = &#123; <span class="attr">firstname</span>: <span class="string">&#x27;Mark&#x27;</span>, <span class="attr">lastname</span>: <span class="string">&#x27;Yun&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">eyecolor</span>: <span class="string">&#x27;black&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>2、用 function 来模拟无参的构造函数</p><!--more--><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Mark&#x27;</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;25&#x27;</span></span><br><span class="line">person.<span class="property">work</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(person.<span class="property">name</span> + <span class="string">&#x27; hello...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">work</span>()</span><br></pre></td></tr></table></figure><p>3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Pet</span>(<span class="params">name, age, hobby</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name <span class="comment">//this作用域：当前对象</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = hobby</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我叫&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;,我喜欢&#x27;</span> + <span class="variable language_">this</span>.<span class="property">hobby</span> + <span class="string">&#x27;,是个程序员&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maidou = <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&#x27;麦兜&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;coding&#x27;</span>) <span class="comment">//实例化、创建对象</span></span><br><span class="line">maidou.<span class="title function_">eat</span>() <span class="comment">//调用eat方法</span></span><br></pre></td></tr></table></figure><p>4、用工厂方式来创建（内置对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wcDog = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">wcDog.<span class="property">name</span> = <span class="string">&#x27;旺财&#x27;</span></span><br><span class="line">wcDog.<span class="property">age</span> = <span class="number">3</span></span><br><span class="line">wcDog.<span class="property">work</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;我是&#x27;</span> + wcDog.<span class="property">name</span> + <span class="string">&#x27;,汪汪汪......&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">wcDog.<span class="title function_">work</span>()</span><br></pre></td></tr></table></figure><p>5、用原型方式来创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;旺财&#x27;</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;是个吃货&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wangcai = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br></pre></td></tr></table></figure><p>合并两个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123; <span class="attr">b</span>: <span class="number">30</span>, <span class="attr">c</span>: <span class="number">40</span>, <span class="attr">d</span>: <span class="number">50</span> &#125;</span><br><span class="line"><span class="keyword">let</span> merged = &#123; ...object1, ...object2 &#125; <span class="comment">//spread and re-add into merged</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged) <span class="comment">// &#123;a:1, b:30, c:40, d:50&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。</p><ul><li>基本数据类型：直接存储在栈(stack)中的数据</li><li>引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</li></ul><p>深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。</p><ul><li>栈（stack）为自动分配的内存空间，它由系统自动释放。</li><li>堆（heap）则是动态分配的内存，大小不定也不会自动释放。</li></ul><h4 id="数据的比较"><a href="#数据的比较" class="headerlink" title="数据的比较"></a>数据的比较</h4><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h4><p>基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line"></span><br><span class="line">a++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125; <span class="comment">// a保存了一个空对象的实例</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">// a和b都指向了这个空对象</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;jozo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>) <span class="comment">// &#x27;jozo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>) <span class="comment">// &#x27;jozo&#x27;</span></span><br><span class="line"></span><br><span class="line">b.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>) <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;photography&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = obj</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; ...obj &#125;</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">obj.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">//&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3) <span class="comment">//&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj4) <span class="comment">//&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p>从以上例子可以看出，当数据为引用数据类型时</p><ol><li>直接赋值属于浅拷贝</li><li>Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。</li><li>扩展运算符和Object.assign原理一样。</li><li>JSON.parse(JSON.stringify(obj))可实现深拷贝</li></ol><h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h3><ol><li>JSON.parse(JSON.stringify(obj)) 但存在一些缺陷</li></ol><ul><li>对象的属性值是函数时，无法拷贝。</li><li>原型链上的属性无法拷贝</li><li>不能正确的处理 Date，RegExp 类型的数据</li><li>会忽略 undefined</li></ul><ol start="2"><li>实现一个 deepClone 函数</li></ol><ul><li>如果是基本数据类型，直接返回</li><li>如果是 RegExp 或者 Date 类型，返回对应类型</li><li>如果是复杂数据类型，递归。</li><li>考虑循环引用的问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">//递归拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, t)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">//是否是自身的属性</span></span><br><span class="line">      t[key] = <span class="title function_">deepClone</span>(obj[key], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JS-对象创建与拷贝&quot;&gt;&lt;a href=&quot;#JS-对象创建与拷贝&quot; class=&quot;headerlink&quot; title=&quot;JS 对象创建与拷贝&quot;&gt;&lt;/a&gt;JS 对象创建与拷贝&lt;/h1&gt;&lt;h3 id=&quot;五种创建对象的方法&quot;&gt;&lt;a href=&quot;#五种创建对象的方法&quot; class=&quot;headerlink&quot; title=&quot;五种创建对象的方法&quot;&gt;&lt;/a&gt;五种创建对象的方法&lt;/h3&gt;&lt;p&gt;1、对象字面量的方式&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;person = &amp;#123; &lt;span class=&quot;attr&quot;&gt;firstname&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;Mark&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;lastname&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;Yun&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;eyecolor&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;black&amp;#x27;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
