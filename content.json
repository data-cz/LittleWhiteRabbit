{"meta":{"title":"面试详解","subtitle":"","description":"","author":"Chen Daxian","url":"https://data-cz.github.io","root":"/LittleWhiteRabbit/"},"pages":[{"title":"","date":"2022-04-11T03:46:10.402Z","updated":"2022-04-11T03:46:10.402Z","comments":true,"path":"404.html","permalink":"https://data-cz.github.io/404.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-12T02:07:57.000Z","updated":"2022-04-12T02:07:57.393Z","comments":true,"path":"tags/index.html","permalink":"https://data-cz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue 组件下拉加载更多","slug":"Vue 组件下拉 加载更多","date":"2022-04-13T01:46:34.427Z","updated":"2022-04-13T02:17:39.253Z","comments":true,"path":"2022/04/13/Vue 组件下拉 加载更多/","link":"","permalink":"https://data-cz.github.io/2022/04/13/Vue%20%E7%BB%84%E4%BB%B6%E4%B8%8B%E6%8B%89%20%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/","excerpt":"一、新建一个loadingMessage组件1.1 监听滑动1&lt;div ref=&quot;content&quot;&gt;&lt;/div&gt; 1.1 挂载监听12345mounted() &#123; this.$refs.content.scrollTag = 0; // 标记监听数 // 挂载监听 this.listenerScroll(); &#125;,","text":"一、新建一个loadingMessage组件1.1 监听滑动1&lt;div ref=&quot;content&quot;&gt;&lt;/div&gt; 1.1 挂载监听12345mounted() &#123; this.$refs.content.scrollTag = 0; // 标记监听数 // 挂载监听 this.listenerScroll(); &#125;, 1.2 加载数据时候设置高度123updated() &#123; this.scrollHeight = this.$refs.content.scrollHeight; // 加载数据时设置滚动内容高&#125;, 1.3 离开页面销毁监听组件123beforeDestroy() &#123; this.destroyScroll()&#125;, 1.3 watch 监听，滑动到顶部事件 12345678910111213141516watch: &#123; scrollHeight: function(newHeight,oldHeight)&#123; // 加载数据时设置滚动条 if(this.scrollTop === 0)&#123; // scrollTop 为0时说明时下拉加载操作 this.$refs.content.scrollTop = newHeight - oldHeight; &#125; &#125;, interlocutor: function()&#123; this.scrollToBottom(); // 滚动条至底 this.listenerScroll(); // 重现挂载监听 &#125;, loadingStatus: function(newStatus,oldStatus) &#123; // 加载完全部数据时移除滚动条监听 if(newStatus === 2)&#123; this.destroyScroll(); &#125; &#125;&#125;, 1.4 监听 滑动 滚动事件 12345678910111213141516171819202122232425262728293031methods: &#123; // 滚动监听处理 handleScroll(e)&#123; this.scrollTop = e.srcElement.scrollTop; // 距离顶部 this.scrollHeight = e.srcElement.scrollHeight; // 滚动内容高 this.clientHeight = e.srcElement.clientHeight; // 滚动区域高 if(this.scrollTop === 0) &#123; // 滚动触顶调用 this.$emit(&#x27;onTouchTop&#x27;); &#125; if(this.scrollHeight === this.scrollTop + this.clientHeight)&#123; // 滚动触底调用 this.$emit(&#x27;onTouchBottom&#x27;); &#125; &#125;, // 添加滚动监听事件 listenerScroll() &#123; if(this.$refs.content.scrollTag !== 0) return; this.$refs.content.scrollTag++; this.$refs.content.addEventListener(&#x27;scroll&#x27;, this.handleScroll, true); &#125;, // 移除滚动监听事件 destroyScroll() &#123; if(this.$refs.content.scrollTag !== 1) return; this.$refs.content.scrollTag--; this.$refs.content.removeEventListener(&quot;scroll&quot;, this.handleScroll, true); &#125;, scrollToBottom() &#123; //滚动条置底 this.$nextTick(function()&#123; this.$refs.content.scrollTop = this.$refs.content.scrollHeight - this.$refs.content.clientHeight; &#125;) &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/tags/Vue/"}]},{"title":"SVG 转地图json 数据","slug":"svg-to-geojson","date":"2022-04-13T01:46:34.408Z","updated":"2022-04-13T02:00:52.257Z","comments":true,"path":"2022/04/13/svg-to-geojson/","link":"","permalink":"https://data-cz.github.io/2022/04/13/svg-to-geojson/","excerpt":"","text":"svg-yo-geojson svg 转 json 源码地址DEMO_HERE","categories":[{"name":"Map","slug":"Map","permalink":"https://data-cz.github.io/categories/Map/"}],"tags":[{"name":"json","slug":"json","permalink":"https://data-cz.github.io/tags/json/"}]},{"title":"前端需要注意哪些SEO","slug":"SEO","date":"2022-04-13T01:46:34.401Z","updated":"2022-04-13T02:19:17.866Z","comments":true,"path":"2022/04/13/SEO/","link":"","permalink":"https://data-cz.github.io/2022/04/13/SEO/","excerpt":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标","text":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 如何做SEO优化? 标题与关键词 设置有吸引力切合实际的标题，标题中要包含所做的关键词 网站结构目录 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布 页面元素 给图片标注”Alt”可以让搜索引擎更友好的收录 网站内容 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢 友情链接 对方一定要是正规网站，每天有专业的团队或者个人维护更新 内链的布置 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接 流量分析 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO","categories":[{"name":"前端","slug":"前端","permalink":"https://data-cz.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://data-cz.github.io/tags/Web/"}]},{"title":"2020年你不能不知道的webpack基本配置","slug":"2020年你不能不知道的webpack基本配置","date":"2022-04-13T01:46:32.651Z","updated":"2022-04-13T02:16:58.272Z","comments":true,"path":"2022/04/13/2020年你不能不知道的webpack基本配置/","link":"","permalink":"https://data-cz.github.io/2022/04/13/2020%E5%B9%B4%E4%BD%A0%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","excerpt":"前言在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况： 需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。 传统的html+css+js开发方式不能不能很好地运用less/scss等css预处理器以及ES6+的高级语法。 代码复用性差，可维护性差。","text":"前言在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况： 需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。 传统的html+css+js开发方式不能不能很好地运用less/scss等css预处理器以及ES6+的高级语法。 代码复用性差，可维护性差。 此时就需要一个处理这些问题的工具，webpack应运而生。 webpack可以看做是模块打包工具：它将各种静态资源（比如：javaScript 文件，图片文件，css文件等）视为模块，它能够对这些模块进行解析优化和转换等操作，最后将它们打包在一起，打包后的文件可用于在浏览器中使用。 webpack的优点： 代码转换: typeScript 编译成 javaScript、scss，less 编译成 css. 文件优化：压缩 javaScript、css、html 代码，压缩合并图片。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 扩展性强，插件机制完善。 webpack打包过程： 利用babel完成代码转换,并生成单个文件的依赖 从入口开始递归分析，并生成依赖图谱 将各个引用模块打包为一个立即执行函数 将最终的bundle文件写入bundle.js中 Webpack 的四大核心： entry：js 入口源文件 output：生成文件 loader：进行文件处理 plugins：插件，比 loader 更强大，能使用更多 webpack 的 api Entrywebpack 应该使用哪个模块做为入口文件，来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 单⼊⼝：entry 是⼀个字符串 123module.exports = &#123; entry: &#x27;./src/index.js&#x27;&#125; 多⼊⼝：entry 是⼀个对象 123456module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, manager: &#x27;./src/manager.js&#x27; &#125;&#125; Output告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，这些都可以在webpack的配置文件中指定。 单⼊⼝配置 1234567module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js’, path: __dirname + &#x27;/dist&#x27; &#125;&#125;; 多⼊⼝配置 12345678910module.exports = &#123; entry: &#123; app: &#x27;./src/app.js&#x27;, search: &#x27;./src/search.js&#x27; &#125;, output: &#123; filename: &#x27;[name].js&#x27;, path: __dirname + &#x27;/dist&#x27; &#125;&#125; 通过[name]占位符确保⽂件名称的唯⼀ Loaderloader 让 webpack 能够去处理那些非 javaScript 文件（webpack 自身只理解 javaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 loader的特点 一个Loader 的职责是单一的，只需要完成一种转换 一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数 loader 总是从右到左地被调用。 常用的loader处理样式 css-loader: 加载.css 文件， style-loader:使用 style 标签将 css-loader 内部样式注入到我们的 html 页面 less-loader, sass-loader: 解析css预处理器 处理 js 让你能使用最新的js代码（ES6，ES7…） 让你能使用基于js进行了拓展的语言，比如React的JSX； 处理文件处理图片资源时，我们常用的两种loader是file-loader或者url-loader，两者的主要差异在于。url-loader可以设置图片大小限制，当图片超过限制时，其表现行为等同于file-loader，而当图片不超过限制时，则会将图片以base64的形式打包进css文件，以减少请求次数 处理.vue文件vue-loader 是 webpack 的加载器模块，它使我们可以用 .vue 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 vue-loader 模块允许 webpack 使用单独的加载器模块（例如 sass 或 scss 加载器）提取和处理每个部分。该设置使我们可以使用 .vue 文件无缝编写程序。 开发一个loader","categories":[{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/tags/webpack/"}]},{"title":"Hello World","slug":"hello-world-hexo","date":"2022-04-13T01:41:20.276Z","updated":"2022-04-14T02:07:35.721Z","comments":true,"path":"2022/04/13/hello-world-hexo/","link":"","permalink":"https://data-cz.github.io/2022/04/13/hello-world-hexo/","excerpt":"摘要","text":"摘要 正文Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"分类","slug":"分类","permalink":"https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"https://data-cz.github.io/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"https://data-cz.github.io/tags/Games/"}]},{"title":"css","slug":"CSS盒模型及BFC","date":"2022-04-12T10:07:00.353Z","updated":"2022-04-13T02:17:02.668Z","comments":true,"path":"2022/04/12/CSS盒模型及BFC/","link":"","permalink":"https://data-cz.github.io/2022/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/","excerpt":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。","text":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型 代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷&#x2F;margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理&#x2F;BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算","categories":[{"name":"css","slug":"css","permalink":"https://data-cz.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://data-cz.github.io/tags/css/"}]},{"title":"CSS盒模型的认识","slug":"CSS盒模型的认识","date":"2022-04-07T07:34:10.000Z","updated":"2022-04-13T02:18:02.275Z","comments":true,"path":"2022/04/07/CSS盒模型的认识/","link":"","permalink":"https://data-cz.github.io/2022/04/07/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86/","excerpt":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。","text":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型 代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷&#x2F;margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理&#x2F;BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算","categories":[],"tags":[]},{"title":"JS防抖与节流","slug":"js防抖与节流","date":"2020-04-14T02:06:22.000Z","updated":"2022-04-14T02:10:11.421Z","comments":true,"path":"2020/04/14/js防抖与节流/","link":"","permalink":"https://data-cz.github.io/2020/04/14/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"防抖与节流应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。","text":"防抖与节流应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。 非立即执行版 1234567891011function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 立即执行版 12345678910111213function debounce(func,wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果 防抖应用场景 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。 表单验证 按钮提交事件。 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。 函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器 时间戳版: 123456789101112function throttle(func, wait) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 定时器版: 12345678910111213function throttle(func, wait) &#123; let timeout; return function() &#123; let context = this; let args = arguments; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 节流应用场景 按钮点击事件 拖拽事件 onScoll 计算鼠标移动的距离(mousemove) 总结函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[]},{"title":"JS对象创建与拷贝","slug":"js对象及深拷贝","date":"2020-04-14T02:05:22.000Z","updated":"2022-04-14T02:09:52.136Z","comments":true,"path":"2020/04/14/js对象及深拷贝/","link":"","permalink":"https://data-cz.github.io/2020/04/14/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"JS 对象创建与拷贝五种创建对象的方法1、对象字面量的方式 1person = &#123; firstname: &#x27;Mark&#x27;, lastname: &#x27;Yun&#x27;, age: 25, eyecolor: &#x27;black&#x27; &#125;","text":"JS 对象创建与拷贝五种创建对象的方法1、对象字面量的方式 1person = &#123; firstname: &#x27;Mark&#x27;, lastname: &#x27;Yun&#x27;, age: 25, eyecolor: &#x27;black&#x27; &#125; 2、用 function 来模拟无参的构造函数 12345678function Person() &#123;&#125;var person = new Person() //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Classperson.name = &#x27;Mark&#x27;person.age = &#x27;25&#x27;person.work = function() &#123; alert(person.name + &#x27; hello...&#x27;)&#125;person.work() 3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性） 12345678910function Pet(name, age, hobby) &#123; this.name = name //this作用域：当前对象 this.age = age this.hobby = hobby this.eat = function() &#123; alert(&#x27;我叫&#x27; + this.name + &#x27;,我喜欢&#x27; + this.hobby + &#x27;,是个程序员&#x27;) &#125;&#125;var maidou = new Pet(&#x27;麦兜&#x27;, 25, &#x27;coding&#x27;) //实例化、创建对象maidou.eat() //调用eat方法 4、用工厂方式来创建（内置对象） 1234567var wcDog = new Object()wcDog.name = &#x27;旺财&#x27;wcDog.age = 3wcDog.work = function() &#123; alert(&#x27;我是&#x27; + wcDog.name + &#x27;,汪汪汪......&#x27;)&#125;wcDog.work() 5、用原型方式来创建 123456function Dog() &#123;&#125;Dog.prototype.name = &#x27;旺财&#x27;Dog.prototype.eat = function() &#123; alert(this.name + &#x27;是个吃货&#x27;)&#125;var wangcai = new Dog() 合并两个对象 1234let object1 = &#123; a: 1, b: 2, c: 3 &#125;let object2 = &#123; b: 30, c: 40, d: 50 &#125;let merged = &#123; ...object1, ...object2 &#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 深拷贝和浅拷贝js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。 基本数据类型：直接存储在栈(stack)中的数据 引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放。 堆（heap）则是动态分配的内存，大小不定也不会自动释放。 数据的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 10var b = 10console.log(a === b) //true 而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1, 2, 3]var b = [1, 2, 3]console.log(a === b) // false 传值与传址基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子； 123456var a = 10var b = aa++console.log(a) // 11console.log(b) // 10 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125; // a保存了一个空对象的实例var b = a // a和b都指向了这个空对象a.name = &#x27;jozo&#x27;console.log(a.name) // &#x27;jozo&#x27;console.log(b.name) // &#x27;jozo&#x27;b.age = 22console.log(b.age) // 22console.log(a.age) // 22console.log(a == b) // true 深拷贝深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 浅拷贝浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 区别浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制； 1234567891011121314151617let obj = &#123; name: &#x27;Tom&#x27;, age: 18, hobbies: [&#x27;reading&#x27;, &#x27;photography&#x27;]&#125;let obj1 = objlet obj2 = Object.assign(&#123;&#125;, obj)let obj3 = &#123; ...obj &#125;let obj4 = JSON.parse(JSON.stringify(obj))obj.name = &#x27;Jack&#x27;obj.hobbies.push(&#x27;coding&#x27;)console.log(obj) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj1) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj2) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj3) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj4) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125; 从以上例子可以看出，当数据为引用数据类型时 直接赋值属于浅拷贝 Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。 扩展运算符和Object.assign原理一样。 JSON.parse(JSON.stringify(obj))可实现深拷贝 深拷贝的实现 JSON.parse(JSON.stringify(obj)) 但存在一些缺陷 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date，RegExp 类型的数据 会忽略 undefined 实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 1234567891011121314151617181920212223242526function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) if (obj === null || typeof obj !== &#x27;object&#x27;) &#123; //如果不是复杂数据类型，直接返回 return obj &#125; if (hash.has(obj)) &#123; return hash.get(obj) &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor() hash.set(obj, t) for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123; //是否是自身的属性 t[key] = deepClone(obj[key], hash) &#125; &#125; return t&#125;","categories":[],"tags":[]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/categories/Vue/"},{"name":"Map","slug":"Map","permalink":"https://data-cz.github.io/categories/Map/"},{"name":"前端","slug":"前端","permalink":"https://data-cz.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/categories/webpack/"},{"name":"分类","slug":"分类","permalink":"https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"},{"name":"css","slug":"css","permalink":"https://data-cz.github.io/categories/css/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/tags/Vue/"},{"name":"json","slug":"json","permalink":"https://data-cz.github.io/tags/json/"},{"name":"Web","slug":"Web","permalink":"https://data-cz.github.io/tags/Web/"},{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/tags/webpack/"},{"name":"PS3","slug":"PS3","permalink":"https://data-cz.github.io/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"https://data-cz.github.io/tags/Games/"},{"name":"css","slug":"css","permalink":"https://data-cz.github.io/tags/css/"}]}