{"meta":{"title":"面试详解","subtitle":"","description":"","author":"Chen Daxian","url":"https://data-cz.github.io","root":"/LittleWhiteRabbit/"},"pages":[{"title":"标签","date":"2022-04-08T10:23:38.000Z","updated":"2022-04-08T07:54:56.133Z","comments":true,"path":"tags/index.html","permalink":"https://data-cz.github.io/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-12-30T07:08:02.000Z","comments":true,"path":"404.html","permalink":"https://data-cz.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-06T09:25:30.000Z","updated":"2022-04-11T02:43:11.547Z","comments":true,"path":"categories/index.html","permalink":"https://data-cz.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JS 对象创建与拷贝","slug":"js对象及深拷贝","date":"2022-04-11T07:56:13.000Z","updated":"2022-04-11T02:28:34.292Z","comments":true,"path":"2022/04/11/js对象及深拷贝/","link":"","permalink":"https://data-cz.github.io/2022/04/11/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"JS 对象创建与拷贝五种创建对象的方法1、对象字面量的方式 1person = &#123; firstname: &#x27;Mark&#x27;, lastname: &#x27;Yun&#x27;, age: 25, eyecolor: &#x27;black&#x27; &#125; 2、用 function 来模拟无参的构造函数 12345678function Person() &#123;&#125;var person = new Person() //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Classperson.name = &#x27;Mark&#x27;person.age = &#x27;25&#x27;person.work = function() &#123; alert(person.name + &#x27; hello...&#x27;)&#125;person.work() 3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性） 12345678910function Pet(name, age, hobby) &#123; this.name = name //this作用域：当前对象 this.age = age this.hobby = hobby this.eat = function() &#123; alert(&#x27;我叫&#x27; + this.name + &#x27;,我喜欢&#x27; + this.hobby + &#x27;,是个程序员&#x27;) &#125;&#125;var maidou = new Pet(&#x27;麦兜&#x27;, 25, &#x27;coding&#x27;) //实例化、创建对象maidou.eat() //调用eat方法 4、用工厂方式来创建（内置对象） 1234567var wcDog = new Object()wcDog.name = &#x27;旺财&#x27;wcDog.age = 3wcDog.work = function() &#123; alert(&#x27;我是&#x27; + wcDog.name + &#x27;,汪汪汪......&#x27;)&#125;wcDog.work() 5、用原型方式来创建 123456function Dog() &#123;&#125;Dog.prototype.name = &#x27;旺财&#x27;Dog.prototype.eat = function() &#123; alert(this.name + &#x27;是个吃货&#x27;)&#125;var wangcai = new Dog() 合并两个对象 1234let object1 = &#123; a: 1, b: 2, c: 3 &#125;let object2 = &#123; b: 30, c: 40, d: 50 &#125;let merged = &#123; ...object1, ...object2 &#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 深拷贝和浅拷贝js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。 基本数据类型：直接存储在栈(stack)中的数据 引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放。 堆（heap）则是动态分配的内存，大小不定也不会自动释放。 数据的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 10var b = 10console.log(a === b) //true 而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1, 2, 3]var b = [1, 2, 3]console.log(a === b) // false 传值与传址基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子； 123456var a = 10var b = aa++console.log(a) // 11console.log(b) // 10 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125; // a保存了一个空对象的实例var b = a // a和b都指向了这个空对象a.name = &#x27;jozo&#x27;console.log(a.name) // &#x27;jozo&#x27;console.log(b.name) // &#x27;jozo&#x27;b.age = 22console.log(b.age) // 22console.log(a.age) // 22console.log(a == b) // true 深拷贝深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 浅拷贝浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 区别浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制； 1234567891011121314151617let obj = &#123; name: &#x27;Tom&#x27;, age: 18, hobbies: [&#x27;reading&#x27;, &#x27;photography&#x27;]&#125;let obj1 = objlet obj2 = Object.assign(&#123;&#125;, obj)let obj3 = &#123; ...obj &#125;let obj4 = JSON.parse(JSON.stringify(obj))obj.name = &#x27;Jack&#x27;obj.hobbies.push(&#x27;coding&#x27;)console.log(obj) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj1) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj2) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj3) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj4) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125; 从以上例子可以看出，当数据为引用数据类型时 直接赋值属于浅拷贝 Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。 扩展运算符和Object.assign原理一样。 JSON.parse(JSON.stringify(obj))可实现深拷贝 深拷贝的实现 JSON.parse(JSON.stringify(obj)) 但存在一些缺陷 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date，RegExp 类型的数据 会忽略 undefined 实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 1234567891011121314151617181920212223242526function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) if (obj === null || typeof obj !== &#x27;object&#x27;) &#123; //如果不是复杂数据类型，直接返回 return obj &#125; if (hash.has(obj)) &#123; return hash.get(obj) &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor() hash.set(obj, t) for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123; //是否是自身的属性 t[key] = deepClone(obj[key], hash) &#125; &#125; return t&#125;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://data-cz.github.io/tags/JS/"}]},{"title":"防抖与节流","slug":"js防抖与节流","date":"2022-04-11T07:56:13.000Z","updated":"2022-04-11T02:28:10.230Z","comments":true,"path":"2022/04/11/js防抖与节流/","link":"","permalink":"https://data-cz.github.io/2022/04/11/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖与节流应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。 非立即执行版 1234567891011function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 立即执行版 12345678910111213function debounce(func,wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果 防抖应用场景 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。 表单验证 按钮提交事件。 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。 函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器 时间戳版: 123456789101112function throttle(func, wait) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 定时器版: 12345678910111213function throttle(func, wait) &#123; let timeout; return function() &#123; let context = this; let args = arguments; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 节流应用场景 按钮点击事件 拖拽事件 onScoll 计算鼠标移动的距离(mousemove) 总结函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"https://data-cz.github.io/tags/vue2-0/"}]},{"title":"vue3的生命周期","slug":"vue3的生命周期","date":"2022-04-11T07:56:13.000Z","updated":"2022-04-11T02:26:14.822Z","comments":true,"path":"2022/04/11/vue3的生命周期/","link":"","permalink":"https://data-cz.github.io/2022/04/11/vue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"vue3的生命周期vue3的生命周期对比vue2没有大的改变，只有beforeDestroy和destroyed换了名字，换成beforeUnmount和unmounted。注：如果在组合式API里面使用生命周期的变动就多了。","text":"vue3的生命周期vue3的生命周期对比vue2没有大的改变，只有beforeDestroy和destroyed换了名字，换成beforeUnmount和unmounted。注：如果在组合式API里面使用生命周期的变动就多了。 生命周期图示 vue2生命周期https://blog.langpz.com/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html 参考https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA","categories":[],"tags":[{"name":"vue3.0","slug":"vue3-0","permalink":"https://data-cz.github.io/tags/vue3-0/"},{"name":"生命周期","slug":"生命周期","permalink":"https://data-cz.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-07T07:23:27.048Z","updated":"2022-04-11T01:46:40.656Z","comments":true,"path":"2022/04/07/hello-world/","link":"","permalink":"https://data-cz.github.io/2022/04/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://data-cz.github.io/tags/JS/"},{"name":"vue2.0","slug":"vue2-0","permalink":"https://data-cz.github.io/tags/vue2-0/"},{"name":"vue3.0","slug":"vue3-0","permalink":"https://data-cz.github.io/tags/vue3-0/"},{"name":"生命周期","slug":"生命周期","permalink":"https://data-cz.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]}