{"meta":{"title":"面试详解","subtitle":"","description":"","author":"Chen Daxian","url":"https://data-cz.github.io","root":"/LittleWhiteRabbit/"},"pages":[{"title":"","date":"2022-04-11T03:46:10.402Z","updated":"2022-04-11T03:46:10.402Z","comments":true,"path":"404.html","permalink":"https://data-cz.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-04-11T04:01:08.747Z","updated":"2022-04-11T04:01:08.747Z","comments":false,"path":"tags/index.html","permalink":"https://data-cz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS 对象创建与拷贝","slug":"js对象及深拷贝","date":"2022-04-11T07:56:13.000Z","updated":"2022-04-11T05:52:57.168Z","comments":true,"path":"2022/04/11/js对象及深拷贝/","link":"","permalink":"https://data-cz.github.io/2022/04/11/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"JS 对象及深拷贝 JS 对象创建与拷贝五种创建对象的方法1、对象字面量的方式 1person = &#123; firstname: &#x27;Mark&#x27;, lastname: &#x27;Yun&#x27;, age: 25, eyecolor: &#x27;black&#x27; &#125; 2、用 function 来模拟无参的构造函数 12345678function Person() &#123;&#125;var person = new Person() //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Classperson.name = &#x27;Mark&#x27;person.age = &#x27;25&#x27;person.work = function() &#123; alert(person.name + &#x27; hello...&#x27;)&#125;person.work() 3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性） 12345678910function Pet(name, age, hobby) &#123; this.name = name //this作用域：当前对象 this.age = age this.hobby = hobby this.eat = function() &#123; alert(&#x27;我叫&#x27; + this.name + &#x27;,我喜欢&#x27; + this.hobby + &#x27;,是个程序员&#x27;) &#125;&#125;var maidou = new Pet(&#x27;麦兜&#x27;, 25, &#x27;coding&#x27;) //实例化、创建对象maidou.eat() //调用eat方法 4、用工厂方式来创建（内置对象） 1234567var wcDog = new Object()wcDog.name = &#x27;旺财&#x27;wcDog.age = 3wcDog.work = function() &#123; alert(&#x27;我是&#x27; + wcDog.name + &#x27;,汪汪汪......&#x27;)&#125;wcDog.work() 5、用原型方式来创建 123456function Dog() &#123;&#125;Dog.prototype.name = &#x27;旺财&#x27;Dog.prototype.eat = function() &#123; alert(this.name + &#x27;是个吃货&#x27;)&#125;var wangcai = new Dog() 合并两个对象 1234let object1 = &#123; a: 1, b: 2, c: 3 &#125;let object2 = &#123; b: 30, c: 40, d: 50 &#125;let merged = &#123; ...object1, ...object2 &#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 深拷贝和浅拷贝js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。 基本数据类型：直接存储在栈(stack)中的数据 引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放。 堆（heap）则是动态分配的内存，大小不定也不会自动释放。 数据的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 10var b = 10console.log(a === b) //true 而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1, 2, 3]var b = [1, 2, 3]console.log(a === b) // false 传值与传址基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子； 123456var a = 10var b = aa++console.log(a) // 11console.log(b) // 10 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125; // a保存了一个空对象的实例var b = a // a和b都指向了这个空对象a.name = &#x27;jozo&#x27;console.log(a.name) // &#x27;jozo&#x27;console.log(b.name) // &#x27;jozo&#x27;b.age = 22console.log(b.age) // 22console.log(a.age) // 22console.log(a == b) // true 深拷贝深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 浅拷贝浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 区别浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制； 1234567891011121314151617let obj = &#123; name: &#x27;Tom&#x27;, age: 18, hobbies: [&#x27;reading&#x27;, &#x27;photography&#x27;]&#125;let obj1 = objlet obj2 = Object.assign(&#123;&#125;, obj)let obj3 = &#123; ...obj &#125;let obj4 = JSON.parse(JSON.stringify(obj))obj.name = &#x27;Jack&#x27;obj.hobbies.push(&#x27;coding&#x27;)console.log(obj) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj1) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj2) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj3) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj4) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125; 从以上例子可以看出，当数据为引用数据类型时 直接赋值属于浅拷贝 Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。 扩展运算符和Object.assign原理一样。 JSON.parse(JSON.stringify(obj))可实现深拷贝 深拷贝的实现 JSON.parse(JSON.stringify(obj)) 但存在一些缺陷 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date，RegExp 类型的数据 会忽略 undefined 实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 1234567891011121314151617181920212223242526function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) if (obj === null || typeof obj !== &#x27;object&#x27;) &#123; //如果不是复杂数据类型，直接返回 return obj &#125; if (hash.has(obj)) &#123; return hash.get(obj) &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor() hash.set(obj, t) for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123; //是否是自身的属性 t[key] = deepClone(obj[key], hash) &#125; &#125; return t&#125;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://data-cz.github.io/tags/JS/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-07T07:23:27.048Z","updated":"2022-04-11T01:46:40.656Z","comments":true,"path":"2022/04/07/hello-world/","link":"","permalink":"https://data-cz.github.io/2022/04/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://data-cz.github.io/tags/JS/"}]}