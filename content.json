{"meta":{"title":"面试详解","subtitle":"","description":"","author":"Chen Daxian","url":"https://data-cz.github.io","root":"/LittleWhiteRabbit/"},"pages":[{"title":"","date":"2022-04-11T03:46:10.402Z","updated":"2022-04-11T03:46:10.402Z","comments":true,"path":"404.html","permalink":"https://data-cz.github.io/404.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-12T02:07:57.000Z","updated":"2022-04-24T01:59:32.090Z","comments":true,"path":"tags/index.html","permalink":"https://data-cz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象","slug":"面向对象：类的定义和继承的几种方式","date":"2022-04-24T01:47:52.774Z","updated":"2022-04-24T01:59:32.179Z","comments":true,"path":"2022/04/24/面向对象：类的定义和继承的几种方式/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1 前言 类与实例： 类的声明 生成实例 类与继承： 如何实现继承：继承的本质就是原型链 继承的几种方式 2 类的定义、实例化2.1 类的定义&#x2F;类的声明方式一：用构造函数模拟类（传统写法） 123function Animal1() &#123; this.name = &#x27;smyhvae&#x27;; //通过this，表明这是一个构造函数&#125; 方式二：用 class 声明（ES6的写法） 12345class Animal2 &#123; constructor() &#123; //可以在构造函数里写属性 this.name = name; &#125;&#125; 控制台的效果： 2.2 实例化类的实例化很简单，直接 new 出来即可。 1console.log(new Animal1(),new Animal2()); //实例化。如果括号里没有参数，则括号可以省略 3 继承的几种方式 继承的本质就是原型链。 继承的方式有几种？每种形式的优缺点是？这些问题必问的。其实就是考察你对原型链的掌握程度。 3.1 方式一：借助构造函数12345678910function Parent1() &#123; this.name = &#x27;parent1 的属性&#x27;;&#125;function Child1() &#123; Parent1.call(this); //【重要】此处用 call 或 apply 都行：改变 this 的指向 this.type = &#x27;child1 的属性&#x27;;&#125;console.log(new Child1); 【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了Parent1.call(this);，意思是：让Parent的构造函数在child的构造函数中执行。发生的变化是：改变this的指向，parent的实例 –&gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。 打印结果： 上方结果表明：child先有了 parent 实例的属性（继承得以实现），再有了child 实例的属性。 分析： 这种方式，虽然改变了 this 的指向，但是，Child1 无法继承 Parent1 的原型。也就是说，如果我给 Parent1 的原型增加一个方法： 12Parent1.prototype.say = function () &#123;&#125;; 上面这个方法是无法被 Child1 继承的。如下： 3.2 方法二：通过原型链实现继承1234567891011121314/*通过原型链实现继承 */function Parent() &#123; this.name = &#x27;Parent 的属性&#x27;;&#125;function Child() &#123; this.type = &#x27;Child 的属性&#x27;;&#125;Child.prototype = new Parent(); //【重要】console.log(new Child()); 打印结果： 【重要】上方代码中，最重要的那行：每个函数都有prototype属性，于是，构造函数也有这个属性，这个属性是一个对象。现在，我们把Parent的实例赋值给了Child的prototye，从而实现继承。此时，Child构造函数、Parent的实例、Child的实例构成一个三角关系。于是： new Child.__proto__ === new Parent()的结果为true 分析： 这种继承方式，Child 可以继承 Parent 的原型，但有个缺点： 缺点是：如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变。 如下： 上面的代码中， child1修改了arr属性，却发现，child2的arr属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。 造成这种缺点的原因是：child1和child2共用原型。即：chi1d1.__proto__ === child2__proto__是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。 3.3 方式三：组合的方式：构造函数 + 原型链就是把上面的两种方式组合起来： 123456789101112131415/*组合方式实现继承：构造函数、原型链 */function Parent3() &#123; this.name = &#x27;Parent 的属性&#x27;; this.arr = [1, 2, 3];&#125;function Child3() &#123; Parent3.call(this); //【重要1】执行 parent方法 this.type = &#x27;Child 的属性&#x27;;&#125;Child3.prototype = new Parent3(); //【重要2】第二次执行parent方法var child = new Child3(); 这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。 这种方式的缺点是：让父亲Parent的构造方法执行了两次。 ES6中的继承方式，一带而过即可，重点是要掌握ES5中的继承。","categories":[],"tags":[]},{"title":"跨域通信","slug":"跨域通信类","date":"2022-04-24T01:47:52.771Z","updated":"2022-04-24T01:59:31.870Z","comments":true,"path":"2022/04/24/跨域通信类/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/","excerpt":"","text":"1 前言从本章起，对代码的要求没之前那么高了，但是，要求你对知识面的掌握要足够宽。 前端通信类的问题，主要包括以下内容： 什么是同源策略及限制 同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。 前后端如何通信 如果你不准备，估计也就只能说出ajax。这个可以考察出知识面。 如何创建Ajax Ajax在前后端通信中经常用到。做业务时，可以借助第三方的库，比如vue框架里的库、jQuery也有封装好的方法。但如果让你用原生的js去实现，该怎么做？ 这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。 跨域通信的几种方式 这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、跨域有几种方式。 下面分别讲解。 2 同源策略的概念和具体限制 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释） 具体解释： 源包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则源不同，那就是跨域了。 限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住） Cookie、LocalStorage和IndexDB无法获取。 无法获取和操作DOM。 不能发送Ajax请求。我们要注意，Ajax只适合同源的通信。 3 前后端如何通信主要有以下几种方式： Ajax：不支持跨域。 WebSocket：不受同源策略的限制，支持跨域 CORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的Ajax。 4 如何创建Ajax 在回答 Ajax 的问题时，要回答以下几个方面： XMLHttpRequest 的工作原理 兼容性处理 XMLHttpRequest只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。 事件的触发条件 事件的触发顺序 XMLHttpRequest有很多触发事件，每个事件是怎么触发的。 4.1 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理） 创建XMLHttpRequest 对象。 使用open方法设置请求的参数。&#96;open(method, url, 是否异步)&#96;&#96;。 发送请求。 注册事件。 注册onreadystatechange事件，状态改变时就会调用。 如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 获取返回的数据，更新UI。 4.2 发送 get 请求和 post 请求 get请求举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送get_ajax请求&quot; id=&#x27;btnAjax&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 绑定点击事件 document.querySelector(&#x27;#btnAjax&#x27;).onclick = function () &#123; // 发送ajax 请求 需要 五步 // （1）创建异步对象 var ajaxObj = new XMLHttpRequest(); // （2）设置请求的参数。包括：请求的方法、请求的url。 ajaxObj.open(&#x27;get&#x27;, &#x27;02-ajax.php&#x27;); // （3）发送请求 ajaxObj.send(); //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。 //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 ajaxObj.onreadystatechange = function () &#123; // 为了保证 数据 完整返回，我们一般会判断 两个值 if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status == 200) &#123; // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示 console.log(&#x27;数据返回成功&#x27;); // 数据是保存在 异步对象的 属性中 console.log(ajaxObj.responseText); // 修改页面的显示 document.querySelector(&#x27;h1&#x27;).innerHTML = ajaxObj.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post 请求举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送put_ajax请求&quot; id=&#x27;btnAjax&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 异步对象 var xhr = new XMLHttpRequest(); // 设置属性 xhr.open(&#x27;post&#x27;, &#x27;02.post.php&#x27;); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); // 将数据通过send方法传递 xhr.send(&#x27;name=fox&amp;age=18&#x27;); // 发送并接受返回值 xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.3 onreadystatechange 事件 注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。 readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化） 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 4.4 事件的触发条件 4.5 事件的触发顺序 4.6 实际开发中用的 原生Ajax请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var util = &#123;&#125;;//获取 ajax 请求之后的jsonutil.json = function (options) &#123; var opt = &#123; url: &#x27;&#x27;, type: &#x27;get&#x27;, data: &#123;&#125;, success: function () &#123; &#125;, error: function () &#123; &#125;, &#125;; util.extend(opt, options); if (opt.url) &#123; //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); var data = opt.data, url = opt.url, type = opt.type.toUpperCase(); dataArr = []; &#125; for (var key in data) &#123; dataArr.push(key + &#x27;=&#x27; + data[key]); &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;); xhr.open(type, url.replace(/\\?$/g, &#x27;&#x27;), true); xhr.send(); &#125; if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url, true); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(dataArr.join(&#x27;&amp;&#x27;)); &#125; xhr.onload = function () &#123; if (xhr.status === 200 || xhr.status === 304) &#123; //304表示：用缓存即可。206表示获取媒体资源的前面一部分 var res; if (opt.success &amp;&amp; opt.success instanceof Function) &#123; res = xhr.responseText; if (typeof res === &#x27;string&#x27;) &#123; res = JSON.parse(res); //将字符串转成json opt.success.call(xhr, res); &#125; &#125; &#125; else &#123; if (opt.error &amp;&amp; opt.error instanceof Function) &#123; opt.error.call(xhr, res); &#125; &#125; &#125;;&#125; 5 跨域通信的几种方式 方式如下： JSONP WebSocket CORS Hash postMessage 上面这五种方式，在面试时，都要说出来。 5.1 JSONP 面试会问：JSONP的原理是什么？怎么实现的？ 在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。 JSONP的原理：通过&lt;script&gt;标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过&lt;script&gt;标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。 JSONP的实现： 比如说，客户端这样写： 1&lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt; 上面的src中，data=name是get请求的参数，myjsonp是和后台约定好的函数名。服务器端这样写： 1234myjsonp(&#123; data: &#123;&#125;&#125;) 于是，本地要求创建一个myjsonp 的全局函数，才能将返回的数据执行出来。 实际开发中，前端的JSONP是这样实现的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script&gt; var util = &#123;&#125;; //定义方法：动态创建 script 标签 /** * [function 在页面中注入js脚本] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.createScript = function (url, charset) &#123; var script = document.createElement(&#x27;script&#x27;); script.setAttribute(&#x27;type&#x27;, &#x27;text/javascript&#x27;); charset &amp;&amp; script.setAttribute(&#x27;charset&#x27;, charset); script.setAttribute(&#x27;src&#x27;, url); script.async = true; return script; &#125;; /** * [function 处理jsonp] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; onsucess [description] * @param &#123;[type]&#125; onerror [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.jsonp = function (url, onsuccess, onerror, charset) &#123; var callbackName = util.getName(&#x27;tt_player&#x27;); //事先约定好的 函数名 window[callbackName] = function () &#123; //根据回调名称注册一个全局的函数 if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123; onsuccess(arguments[0]); &#125; &#125;; var script = util.createScript(url + &#x27;&amp;callback=&#x27; + callbackName, charset); //动态创建一个script标签 script.onload = script.onreadystatechange = function () &#123; //监听加载成功的事件，获取数据 if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123; script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) &#123; script.parentNode.removeChild(script); &#125; // 删除函数或变量 window[callbackName] = null; //最后不要忘了删除 &#125; &#125;; script.onerror = function () &#123; if (onerror &amp;&amp; util.isFunction(onerror)) &#123; onerror(); &#125; &#125;; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去 &#125;;&lt;/script&gt; 5.2 WebSocket WebSocket的用法如下： 123456789101112131415161718192021//var ws = new WebSocket(&#x27;wss://echo.websocket.org&#x27;); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。//把请求发出去ws.onopen = function (evt) &#123; console.log(&#x27;Connection open ...&#x27;); ws.send(&#x27;Hello WebSockets!&#x27;);&#125;;//对方发消息过来时，我接收ws.onmessage = function (evt) &#123; console.log(&#x27;Received Message: &#x27;, evt.data); ws.close();&#125;;//关闭连接ws.onclose = function (evt) &#123; console.log(&#x27;Connection closed.&#x27;);&#125;; 面试一般不会让你写这个代码，一般是考察你是否了解 WebSocket概念，知道有这么回事即可。 5.3 CORS CORS 可以理解成是既可以同步、也可以异步的Ajax。 fetch 是一个比较新的API，用来实现CORS&#96;通信。用法如下： 12345678// url（必选），options（可选）fetch(&#x27;/some/url/&#x27;, &#123; method: &#x27;get&#x27;,&#125;).then(function (response) &#123; //类似于 ES6中的promise&#125;).catch(function (err) &#123; // 出错了，等价于 then 的第二个参数，但这样更好用更直观&#125;); 另外，如果面试官问：“CORS为什么支持跨域的通信？” 答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。 5.4 Hash url的#后面的内容就叫Hash。Hash的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。 补充：url的?后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。 使用举例： 场景：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。 现在，我这个A页面想给B页面发消息，怎么操作呢？ 首先，在我的A页面中： 123//伪代码var B = document.getElementsByTagName(&#x27;iframe&#x27;);B.src = B.src + &#x27;#&#x27; + &#x27;jsonString&#x27;; //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B 然后，在B页面中： 1234// B中的伪代码window.onhashchange = function () &#123; //通过onhashchange方法监听，url中的 hash 是否发生变化 var data = window.location.hash;&#125;; 5.5 postMessage()方法 H5中新增的&#96;postMessage()&#96;&#96;方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。 场景：窗口 A (http:A.com)向跨域的窗口 B (http:B.com)发送信息。步骤如下 在A窗口中操作如下：向B窗口发送数据： 12// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage(&#x27;data&#x27;, &#x27;http://B.com&#x27;); //这里强调的是B窗口里的window对象 在B窗口中操作如下： 123456// 在窗口B中监听 message 事件Awindow.addEventListener(&#x27;message&#x27;, function (event) &#123; //这里强调的是A窗口里的window对象 console.log(event.origin); //获取 ：url。这里指：http://A.com console.log(event.source); //获取：A window对象 console.log(event.data); //获取传过来的数据&#125;, false);","categories":[],"tags":[]},{"title":"谈谈数据状态管理和实现一个简易版vuex","slug":"谈谈数据状态管理和实现一个简易版vuex","date":"2022-04-24T01:47:52.766Z","updated":"2022-04-24T01:59:32.118Z","comments":true,"path":"2022/04/24/谈谈数据状态管理和实现一个简易版vuex/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E8%B0%88%E8%B0%88%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88vuex/","excerpt":"","text":"数据状态管理首先说说什么叫“前端状态”。所有程序都有“状态”，状态表现在代码中的各种类型的变量，在程序运行的过程中发生改变的过程，而我们编写的程序就是在控制这些“状态”如何发生改变。 为什么要进行数据状态管理数据状态管理是近年随着在 React&#x2F;Vue 等现代化的前端框架流行起来的，主要应用在单页应用 SPA(Single Page Application)中。在以前前端“刀耕火种”的年代还没有这种概念的。 前端技术在如火如荼地发展，前端工作也越来越复杂，现阶段的前端不在只是传统意义上的“切图仔”，更多地负责页面数据逻辑处理，原有的很多技术体系、解决方案已经不能很好的支撑这些越来越复杂的需求。而且，现在 Vue&#x2F;React 等前端框架都是使用 MVVM 的设计模式，都是依靠数据驱动视图的更新。 比如 Vue 使用了 Virtual DOM 的 思想。将 DOM 放到内存中，当 data 发生变化的时候，生成新的 Virtual DOM，再将它和之前的 Virtual DOM 通过一个 diff 算法进行对比，将被改变的内容在浏览器中渲染，大大减少了对 DOM 的操作，提升了前端性能。 其次数据管理逻辑和页面渲染逻辑分离，使得代码更容易维护。操作数据的地方不会关心页面如何展示，展示页面的地方不会关心数据从哪里来的。 数据状态管理的方法 localStorage 和 sessionStorage : 适合小量简单数据的存储 prop 和 $emit: 适合父子组件传值 provide 和 inject: 允许一个祖先组件向其所有子孙后代注入一个依赖 vuex: 全局数据状态管理，适合数据复杂的大型应用 VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex 解决了什么问题 多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 五个核心属性 state：存储状态（变量）,相当于 vue 的 data getters：对数据获取之前的再次编译，可以理解为 state 的计算属性。我们在组件中使用 $sotre.getters.fun() mutations：修改状态，并且是同步的。在组件中使用$store.commit(&#39;&#39;,params)。相当于 vue 的 methods。 actions：异步操作。在组件中使用是$store.dispath(&#39;&#39;) modules：store 的子模块，为了开发大型项目，方便状态管理而使用的。 statestate 是存储状态，它是一个对象。 123456const store = new Vuex.Store(&#123; state: &#123; count: 10, price: 10, &#125;,&#125;) 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性。 1234567891011// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from &#x27;vuex&#x27;export default &#123; computed: mapState(&#123; count: (state) =&gt; state.count, price: (state) =&gt; state.price, &#125;),&#125;// 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。computed: mapState([&#x27;count&#x27;, &#x27;price&#x27;]) getter有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数，这时候我们就用到 getter 属性。 1234567891011121314export default new Vuex.Store(&#123; state: &#123; list: [1, 2, 3, 4] &#125;, getters: &#123; // 这个主要是对状态的处理，相当于把状态处理的方法抽成公共部分来管理了 filterArr(state) &#123; // 一般化getter return state.list.filter((item, index, arr) =&gt; &#123; return item % 2 === 0; &#125;) &#125;, getLength(state, getter) &#123; // 方法里面传getter，调用modifyArr来计算长度 return getter.filterArr.length; &#125;&#125;) 然后在组件中可以用计算属性 computed 来访问这些派生转态。 12345computed: &#123; list() &#123; return this.$store.getters.filterArr &#125;,&#125; mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，当我们想在组件里面引入多个 getter 时，可以使用 mapGetters： 123456import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapGetters([&#x27;filterArr&#x27;, &#x27;getLength&#x27;]), &#125;,&#125; mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type) 和 一个 回调函数 (handler)。它会接受 state 作为第一个参数，提交载荷（Payload）作为第二个参数。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; count: 1, &#125;, mutations: &#123; increment(state, n) &#123; // 变更状态 state.count += n &#125;, &#125;,&#125;)store.commit(&#x27;increment&#x27;, 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： 123456789mutations: &#123; increment (state, payload) &#123; state.count += payload.count &#125;&#125;store.commit(&#x27;increment&#x27;, &#123; count: 10&#125;) 提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 1234store.commit(&#123; type: &#x27;increment&#x27;, count: 10,&#125;) 在组件中提交 Mutation你可以在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 123456789import &#123; mapMutations &#125; from &#x27;vuex&#x27;export default &#123; // ... methods: &#123; ...mapMutations([ &#x27;increment&#x27;, // 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)` ]), &#125;,&#125; ActionAction 类似于 mutation，不同在于： action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态。 action 可以包含任意异步操作。mutation 只能是同步操作。 提交方式不同，action 是用this.$store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。mutation 是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交。 接收参数不同，mutation 第一个参数是 state，而 action 第一个参数是 context。 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125;, &#125;, actions: &#123; increment(context) &#123; context.commit(&#x27;increment&#x27;) &#125;, &#125;,&#125;) 注意：vuex 的 mutation 中不能做异步操作 vuex 中所有的状态更新的唯一方式都是提交 mutation，异步操作需要通过 action 来提交 mutation（dispatch）。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地使用 vuex ModuleVuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 1234567891011121314151617181920212223const moduleA = &#123; state: &#123; ... &#125;, getters: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;,&#125;const moduleB = &#123; state: &#123; ... &#125;, getters: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 实现一个简易版的 vuex我们先来看一下 vuex 的使用方法 12345678910import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;,&#125;) 通过上面可以看到，vuex 是通过 Vue.use() 注入到 Vue 的。使用Vue.use() 的插件，如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。 实现 Store 类首先来实现一个 Store 类，代码如下 12345678910111213141516171819202122232425262728293031323334353637class Store &#123; constructor(options) &#123; this.state = new Vue(&#123; data: options.state, &#125;) this.mutations = options.mutations this.actions = options.actions options.getters &amp;&amp; this.handleGetters(options.getters) &#125; commit = (type, arg) =&gt; &#123; this.mutations[type](this.state, arg) &#125; dispatch(type, arg) &#123; this.actions[type]( &#123; commit: this.commit, state: this.state, &#125;, arg ) &#125; // getters为参数 而this.getters是实例化的 handleGetters(getters) &#123; this.getters = &#123;&#125; Object.keys(getters).forEach((key) =&gt; &#123; Object.defineProperty(this.getters, key, &#123; get: () =&gt; &#123; return getters[key](this.state) &#125;, &#125;) &#125;) &#125;&#125; 实现 install 方法使用Vue.use() 的插件，必须提供 install 方法。并将 Vue 作为参数传入。 123456789101112let Vuefunction install(_Vue) &#123; Vue = _Vue Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$store = this.$options.store &#125; &#125;, &#125;)&#125; vuex 最终 export 了一个对象这个对象包括了一个 install 方法和一个类 Store, 注意对应我们的使用方法。 1export default &#123; Store, install &#125; 使用简易版 vuex1、新建 store.js 1234567891011121314151617181920212223242526272829303132import Vue from &#x27;vue&#x27;import Vuex from &#x27;./store&#x27;Vue.use(Vuex)const state = &#123; count: 0,&#125;const getters = &#123; getCount(state) &#123; return state.count &#125;,&#125;const mutations = &#123; addCount(state, payload) &#123; state.count += payload &#125;,&#125;const actions = &#123; asyncAdd(context, payload) &#123; context.commit(&#x27;addCount&#x27;, payload) &#125;,&#125;const store = new Vuex.Store(&#123; state, mutations, getters, actions,&#125;)export default store 2、main.js 引入 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store/index&#x27;Vue.config.productionTip = falsenew Vue(&#123; router, store, render: (h) =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 3、页面使用数据状态管理 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;div class=&quot;item&quot;&gt;当前数量是&#123;&#123;count&#125;&#125; &lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt;&lt;/div&gt; &lt;button @click=&quot;asyncAdd&quot;&gt;异步操作+10&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; count() &#123; return this.$store.getters.getCount &#125;, &#125;, methods: &#123; add() &#123; this.$store.commit(&#x27;add&#x27;, 1) &#125;, asyncAdd() &#123; setTimeout(() =&gt; &#123; this.$store.dispatch(&#x27;asyncAdd&#x27;, 10) &#125;, 1000) &#125;, &#125;, &#125;&lt;/script&gt; 这样就能完成一个简易版的 vuex 了。 详细代码可见 https://github.com/Michael-lzg/vuex-demo","categories":[],"tags":[]},{"title":"谈谈关于文件上传下载那些事","slug":"谈谈关于文件上传下载那些事","date":"2022-04-24T01:47:52.762Z","updated":"2022-04-24T01:59:31.482Z","comments":true,"path":"2022/04/24/谈谈关于文件上传下载那些事/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"前端开发中总免不了关于文件的上传、下载需求。下面来总结一下常用的方法，欢迎讨论和吐槽。 form 表单提交最传统的文件上传方法是使用form表单上传文件的，只需要把enctype设置为 multipart/form-data。这种方式上传文件不需要 js ，而且没有兼容问题，所有浏览器都支持，就是体验很差，导致页面刷新，页面其他数据丢失。 1234567&lt;form method=&quot;post&quot; action=&quot;xxxxx&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件:&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;br /&gt; 标题：&lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 注意：input 必须设置 name 属性，否则数据无法发送 文件接口上传这种方法由服务端提供接口，设置相应的请求头，前端提交 formData 形式的文件数据。 1&lt;input id=&quot;uploadFile&quot; type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image/png,image/gif&quot; /&gt; accept：表示可以选择的文件 MIME 类型，多个 MIME 类型用英文逗号分开 multiple：是否可以选择多个文件 123456789101112131415161718$(&#x27;#uploadFile&#x27;).on(&#x27;change&#x27;, function (e) &#123; var file = this.files[0] var formData = new FormData() formData.append(&#x27;file&#x27;, file) $.ajax(&#123; url: &#x27;xxxx&#x27;, type: &#x27;post&#x27;, data: formData, cache: false, contentType: false, processData: false, success: function (res) &#123; // &#125;, &#125;)&#125;) processData 设置为 false。因为 data 值是 FormData 对象，不需要对数据做处理。 cache 设置为 false，上传文件不需要缓存。 contentType 设置为 false。 分片上传有时候我们上传的文件可能很大，比如视频等可能达到 2 个 G，这样会造成上传速度太慢，甚至有时候会出现链接超时的情况。而且有时候服务端会设置文件允许上传的大小，太大的文件就不允许上传了。为解决这个问题，我们可以将文件进行分片上传，每次只上传很小的一部分 比如 1M。 思路 将文件按一定大小(比如 1M)截取成一小份，并将切片带上 hash 值，用于作为标识。 将每个切片文件并发提交到服务端，服务端保存每个切片文件的信息。 切片上传完成后，服务端根据文件标识进行合并，合并完后删除切片文件。 这样因为每个切片是并发上传的，所以可以有效地降低上传时间。下面说一下具体的实现步骤。（PS：这是我司的实现方式，并不是唯一方法，且涉及到具体接口的代码就不贴在这里了） 生成 hash 值无论上传文件信息还是上传切片文件，都必须要生成文件和切片的 hash。最简单粗暴的 hash 值可以用文件名字+下标来标识，但是这样文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash。我司用的是 spark-md5 库，在这里就不一一细说了。 文件信息上传在文件分片上传之前需要把整个文件的信息如该文件的总的文件大小、文件名、哈希值等等，主要目的是初始化一个文件分片上传事件，返回文件 id，用于每个分片的提交。 12345678910111213141516171819202122232425getFileId (file) &#123; let vm = this let formData = new FormData() formData.append(&#x27;file&#x27;, file) axios(&#123; timeout: 5 * 60 * 1000, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json-&#x27;, &#x27;x-data&#x27;: JSON.stringify(&#123; fileName: file.fileName, size: file.size, hash: &#x27;hashxxx&#x27;, &#125;), &#125;, url: &#x27;xxxxxx&#x27;, method: &#x27;POST&#x27;, &#125;) .then((res) =&gt; &#123; if (res.code === &#x27;200&#x27;) &#123; return res.data.fileId &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)&#125; 文件切片分割当前端获取到本地图片后，利用 Blob.prototype.slice 方法（和数组的 slice 方法相似），将大文件按照没小片 1M 进行切割，返回原文件的某个切片，再并发将各个分片上传到服务端。 123456789101112131415161718getCkunk (file, fileId) &#123; let vm = this let chunkSize = 1024 * 1024 let totalSize = file.size let count = Math.ceil(totalSize / chunkSize) let chunkArr = [] for (let i = 0; i &lt; count; i++) &#123; if (i === count.length - 1) &#123; chunkArr.push(file.slice(i * chunkSize, totalSize)) &#125; else &#123; chunkArr.push(file.slice(i * chunkSize, (i + 1) * chunkSize)) &#125; for (let index = 0; index &lt; count; index++) &#123; let item = chunkArr[index] this.uploadChunk(item, index, fileId) &#125;&#125; 各个分片上传到服务端的方法。此处省略 hash 值得获取方式。 1234567891011121314151617181920212223ploadChunk(item, index, fileId) &#123; let formData = new FormData() formData.append(&#x27;file&#x27;, item) request(&#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/octet-stream;&#x27;, &#x27;x-data&#x27;: JSON.stringify(&#123; fileId: fileId, partId: index + 1, hash: res, &#125;) &#125;, url: &#x27;xxxxx&#x27;, method: &#x27;POST&#x27;, data: formData, &#125;) .then((res) =&gt; &#123; return res.data.path &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)&#125; 显示上传进度条由于文件比较大，即使是采用分片上传的方式也是需要一定的时间的，为了更好的用户体验，前端最好是提示上传的进度。这时候就需要后端在每个分片的放回结果加上上传的 100%字段。前端获取到返回值就改变当前进度。 当最后一个分片上传完成后，服务端返回文件的 url，前端获取 url，同时将进度条状态改变为 100%。 断点续传上面说到的分片上传，解决了大文件上传超时和服务器的限制。但是对于更大的文件，上传并不是短时间内就上传完成，甚至有时候会面临断网或者手动暂停，难道就要重新将整个文件上传了，我们当然不希望。这时候断点续传就派上用场了。 下面说一下实现思路。首先断点续传必须是基于分片上传的基础上的 每个分片上传的时候，服务端记录上传好的文件 hash 值，上传成功后返回 hash 值给前端，前端记录 hash 值 重新上传时，将每个文件的 hash 值与记录的 hash 值做比对，如果相同的话则跳过，继续下一个分段的上传。 全部分片上传完成后，服务端根据文件标识进行合并，合并完后删除小文件。 文件下载文件下载有以下几种方法 form 表单提交这是最原始的方法，为一个下载按钮添加 click 事件，点击时动态生成一个表单，利用表单提交的功能来实现文件的下载（实际上表单的提交就是发送一个请求）。 12345678910function downloadFile(downloadUrl, fileName) &#123; // 创建表单 let form = document.createElement(&#x27;form&#x27;) form.method = &#x27;get&#x27; form.action = downloadUrl //form.target = &#x27;_blank&#x27;; // form新开页面 document.body.appendChild(form) form.submit() document.body.removeChild(form)&#125; 优点:兼容性好，不会出现 URL 长度限制问题。 缺点:无法知道下载的进度，无法直接下载浏览器可直接预览的文件类型（如 txt&#x2F;png 等） window.open 或 window.location.href最简单最直接的方式，实际上跟 a 标签访问下载链接一样 12window.open(&#x27;downloadFile.zip&#x27;)location.href = &#x27;downloadFile.zip&#x27; 缺点 会出现 URL 长度限制问题 需要注意 url 编码问题 浏览器可直接浏览的文件类型是不提供下载的，如 txt、png、jpg、gif 等 不能添加 header，也就不能进行鉴权 无法知道下载的进度 a 标签 download 属性download 属性是 HTML5 新增的属性，兼容性可以了解下 can i use download。 123&lt;a href=&quot;xxxx&quot; download&gt;点击下载&lt;/a&gt;&lt;!-- 重命名下载文件 --&gt;&lt;a href=&quot;xxxx&quot; download=&quot;test&quot;&gt;点击下载&lt;/a&gt; 优点:能解决不能直接下载浏览器可浏览的文件。 缺点 得已知下载文件地址 不能下载跨域下的浏览器可浏览的文件 有兼容性问题，特别是 IE 不能进行鉴权 利用 Blob 对象此方法除了能利用已知文件地址路径进行下载外，还能通过发送 ajax 请求 api 获取文件流进行下载。利用 Blob 对象可以将文件流转化成 Blob 二进制对象。 进行下载的思路很简单：发请求获取二进制数据，转化为 Blob 对象，利用 URL.createObjectUrl 生成 url 地址，赋值在 a 标签的 href 属性上，结合 download 进行下载。 123456789101112131415161718192021downdFile (path, name) &#123; const xhr = new XMLHttpRequest(); xhr.open(&#x27;get&#x27;, path); xhr.responseType = &#x27;blob&#x27;; xhr.send(); xhr.onload = function () &#123; if (this.status === 200 || this.status === 304) &#123; // const blob = new Blob([this.response], &#123; type: xhr.getResponseHeader(&#x27;Content-Type&#x27;) &#125;); // const url = URL.createObjectURL(blob); const url = URL.createObjectURL(this.response); const a = document.createElement(&#x27;a&#x27;); a.style.display = &#x27;none&#x27;; a.href = url; a.download = name; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"浏览器","slug":"浏览器","date":"2022-04-24T01:47:52.757Z","updated":"2022-04-24T01:59:32.035Z","comments":true,"path":"2022/04/24/浏览器/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"一、事件机制1.1 事件触发三阶段 document 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 document 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行 1234567// 以下会先打印冒泡然后是捕获node.addEventListener(&#x27;click&#x27;,(event) =&gt;&#123; console.log(&#x27;冒泡&#x27;)&#125;,false);node.addEventListener(&#x27;click&#x27;,(event) =&gt;&#123; console.log(&#x27;捕获 &#x27;)&#125;,true) 1.2 注册事件 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件 12345678node.addEventListener(&#x27;click&#x27;,(event) =&gt;&#123; event.stopImmediatePropagation() console.log(&#x27;冒泡&#x27;)&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener(&#x27;click&#x27;,(event) =&gt; &#123; console.log(&#x27;捕获 &#x27;)&#125;,true) 1.3 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 12345678910111213&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector(&#x27;##ul&#x27;) ul.addEventListener(&#x27;click&#x27;, (event) =&gt; &#123; console.log(event.target); &#125;)&lt;/script&gt; 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 二、跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败 2.1 JSONP JSONP 的原理很简单，就是利用 标签没有跨域限制的漏洞。通过 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时 123456&lt;script src=&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; JSONP 使用简单且兼容性不错，但是只限于 get 请求 2.2 CORS CORS需要浏览器和后端同时支持 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源 2.3 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域 2.4 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 1234567891011// 发送消息端window.parent.postMessage(&#x27;message&#x27;, &#x27;http://test.com&#x27;);// 接收消息端var mc = new MessageChannel();mc.addEventListener(&#x27;message&#x27;, (event) =&gt; &#123; var origin = event.origin || event.originalEvent.origin; if (origin === &#x27;http://test.com&#x27;) &#123; console.log(&#x27;验证通过&#x27;) &#125;&#125;); 三、Event loop3.1 JS中的event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点） JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 1234567console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);console.log(&#x27;script end&#x27;); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task 1234567891011121314151617console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&#x27;Promise&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;);// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务 微任务 process.nextTick promise Object.observe MutationObserver 宏任务 script setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中 3.2 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 123456789101112131415161718┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──connections─── ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepareidle, prepare 阶段内部实现 poll poll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 12345678910setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;);&#125;)// 这里可能会输出 setTimeout，setImmediate// 可能也会相反的输出，这取决于性能// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate// 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行 1234567891011121314151617181920setTimeout(()=&gt;&#123; console.log(&#x27;timer1&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;) &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log(&#x27;timer2&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise2&#x27;) &#125;)&#125;, 0)// 以上代码在浏览器和 node 中打印情况是不同的// 浏览器中一定打印 timer1, promise1, timer2, promise2// node 中可能打印 timer1, timer2, promise1, promise2// 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行 123456789101112setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); Promise.resolve().then(function() &#123; console.log(&quot;promise1&quot;); &#125;);&#125;, 0);process.nextTick(() =&gt; &#123; console.log(&quot;nextTick&quot;);&#125;);// nextTick, timer1, promise1 四、Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API 目前该技术通常用来做缓存文件，提高首屏速度 123456789101112131415161718192021222324252627282930313233// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker .register(&quot;sw.js&quot;) .then(function(registration) &#123; console.log(&quot;service worker 注册成功&quot;); &#125;) .catch(function(err) &#123; console.log(&quot;servcie worker 注册失败&quot;); &#125;);&#125;// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener(&quot;install&quot;, e =&gt; &#123; e.waitUntil( caches.open(&quot;my-cache&quot;).then(function(cache) &#123; return cache.addAll([&quot;./index.html&quot;, &quot;./index.js&quot;]); &#125;) );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&quot;fetch&quot;, e =&gt; &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response) &#123; return response; &#125; console.log(&quot;fetch source&quot;); &#125;) );&#125;); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 五、渲染机制浏览器的渲染机制一般分为以下几个步骤 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 5.1 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用 通过以下几个常用属性可以生成新图层 3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 5.2 重绘（Repaint）和回流（Reflow） 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 减少重绘和回流 使用 translate 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层","categories":[],"tags":[]},{"title":"总结移动端H5开发常用技巧","slug":"总结移动端H5开发常用技巧","date":"2022-04-24T01:47:52.753Z","updated":"2022-04-24T01:59:32.228Z","comments":true,"path":"2022/04/24/总结移动端H5开发常用技巧/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%BB%E7%BB%93%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"html 篇常用的meta属性设置meta对于移动端的一些特殊属性，可根据需要自行设置 1234567&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; //Android 禁止屏幕旋转&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; //全屏显示&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; //UC应用模式，使用了application这种应用模式后，页面讲默认全屏，禁止长按菜单，禁止收拾，标准排版，以及强制图片显示。&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; //QQ强制竖屏&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; //QQ强制全屏&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; //QQ应用模式 电话号码识别在 iOS Safari （其他浏览器和 Android 均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如： 7 位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11 位数字，形如：13800138000 关闭识别 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 开启识别 1&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt; 邮箱识别（Android）安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的 meta 来管别邮箱的自动识别： 1&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; 同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能： 1&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt; css 篇0.5px细线移动端 H5 项目越来越多，设计师对于 UI 的要求也越来越高，比如 1px 的边框。在高清屏下，移动端的 1px 会很粗。 那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为 100%的情况下，设备像素和 CSS 像素的比值。目前主流的屏幕 DPR&#x3D;2（iPhone 8）,或者 3（iPhone 8 Plus）。拿 2 倍屏来说，设备的物理像素要实现 1 像素，而 DPR&#x3D;2，所以 css 像素只能是 0.5。 下面介绍最常用的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* 底边框 */.b-border &#123; position: relative;&#125;.b-border:before &#123; content: &#x27;&#x27;; position: absolute; left: 0; bottom: 0; width: 100%; height: 1px; background: #d9d9d9; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125;/* 上边框 */.t-border &#123; position: relative;&#125;.t-border:before &#123; content: &#x27;&#x27;; position: absolute; left: 0; top: 0; width: 100%; height: 1px; background: #d9d9d9; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125;/* 右边框 */.r-border &#123; position: relative;&#125;.r-border:before &#123; content: &#x27;&#x27;; position: absolute; right: 0; bottom: 0; width: 1px; height: 100%; background: #d9d9d9; -webkit-transform: scaleX(0.5); transform: scaleX(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125;/* 左边框 */.l-border &#123; position: relative;&#125;.l-border:before &#123; content: &#x27;&#x27;; position: absolute; left: 0; bottom: 0; width: 1px; height: 100%; background: #d9d9d9; -webkit-transform: scaleX(0.5); transform: scaleX(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125;/* 四条边 */.setBorderAll &#123; position: relative; &amp;:after &#123; content: &#x27; &#x27;; position: absolute; top: 0; left: 0; width: 200%; height: 200%; transform: scale(0.5); transform-origin: left top; box-sizing: border-box; border: 1px solid #e5e5e5; border-radius: 4px; &#125;&#125; 屏蔽用户选择禁止用户选择页面中的文字或者图片 12345678div &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 清除输入框内阴影在 iOS 上，输入框默认有内部阴影,以这样关闭： 123div &#123; -webkit-appearance: none;&#125; 如何禁止保存或拷贝图像代码如下 123img &#123; -webkit-touch-callout: none;&#125; 输入框默认字体颜色设置 input 里面 placeholder 字体的颜色 123456789101112input::-webkit-input-placeholder,textarea::-webkit-input-placeholder &#123; color: #c7c7c7;&#125;input:-moz-placeholder,textarea:-moz-placeholder &#123; color: #c7c7c7;&#125;input:-ms-input-placeholder,textarea:-ms-input-placeholder &#123; color: #c7c7c7;&#125; 用户设置字号放大或者缩小导致页面布局错误设置字体禁止缩放 12345body &#123; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; -moz-text-size-adjust: 100% !important;&#125; android系统中元素被点击时产生边框部分android系统点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样。去除代码如下 1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0) -webkit-user-modify:read-write-plaintext-only; &#125; iOS 滑动不流畅ios 手机上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。 解决方案 在滚动容器上增加滚动 touch 方法 123.wrapper &#123; -webkit-overflow-scrolling: touch;&#125; 设置 overflow设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。 123456body &#123; overflow-y: hidden;&#125;.wrapper &#123; overflow-y: auto;&#125; js 篇移动端click屏幕产生200-300 ms的延迟响应移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 ontouchstart ontouchmove ontouchend onclick audio 和 video 在 ios 和 andriod 中自动播放这个不是bug，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。加入自动触发播放的代码 123$(&#x27;html&#x27;).one(&#x27;touchstart&#x27;, function() &#123; audio.play()&#125;) iOS 上拉边界下拉出现空白手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。 在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。 解决方案 1234567891011document.body.addEventListener( &#x27;touchmove&#x27;, function(e) &#123; if (e._isScroller) return // 阻止默认事件 e.preventDefault() &#125;, &#123; passive: false &#125;) ios 日期转换 NAN 的问题将日期字符串的格式符号替换成’&#x2F;‘ 1&#x27;yyyy-MM-dd&#x27;.replace(/-/g, &#x27;/&#x27;) 软键盘问题IOS 键盘弹起挡住原来的视图 可以通过监听移动端软键盘弹起Element.scrollIntoViewIfNeeded（Boolean）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。 true，则元素将在其所在滚动区的可视区域中居中对齐。 false，则元素将与其所在滚动区的可视区域最近的边缘对齐。 根据可见区域最靠近元素的哪个边缘，元素的顶部将与可见区域的顶部边缘对准，或者元素的底部边缘将与可见区域的底部边缘对准。 1234567891011121314window.addEventListener(&#x27;resize&#x27;, function() &#123; if ( document.activeElement.tagName === &#x27;INPUT&#x27; || document.activeElement.tagName === &#x27;TEXTAREA&#x27; ) &#123; window.setTimeout(function() &#123; if (&#x27;scrollIntoView&#x27; in document.activeElement) &#123; document.activeElement.scrollIntoView(false) &#125; else &#123; document.activeElement.scrollIntoViewIfNeeded(false) &#125; &#125;, 0) &#125;&#125;) onkeyUp 和 onKeydown 兼容性问题IOS 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件 IOS12 输入框难以点击获取焦点，弹不出软键盘定位找到问题是 fastclick.js 对 IOS12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改 12345678910111213141516FastClick.prototype.focus = function(targetElement) &#123; var length if ( deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#x27;date&#x27;) !== 0 &amp;&amp; targetElement.type !== &#x27;time&#x27; &amp;&amp; targetElement.type !== &#x27;month&#x27; ) &#123; length = targetElement.value.length targetElement.setSelectionRange(length, length) targetElement.focus() &#125; else &#123; targetElement.focus() &#125;&#125; IOS 键盘收起时页面没用回落，底部会留白通过监听键盘回落时间滚动到原来的位置 123456789101112131415window.addEventListener(&#x27;focusout&#x27;, function() &#123; window.scrollTo(0, 0)&#125;)//input输入框弹起软键盘的解决方案。var bfscrolltop = document.body.scrollTop$(&#x27;input&#x27;) .focus(function() &#123; document.body.scrollTop = document.body.scrollHeight //console.log(document.body.scrollTop); &#125;) .blur(function() &#123; document.body.scrollTop = bfscrolltop //console.log(document.body.scrollTop); &#125;) IOS 下 fixed 失效的原因软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type&#x3D;text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。 解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll 123456&lt;body&gt; &lt;div class=&#x27;warper&#x27;&gt; &lt;div class=&#x27;main&#x27;&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=&quot;fix-bottom&quot;&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415.warper &#123; position: absolute; width: 100%; left: 0; right: 0; top: 0; bottom: 0; overflow-y: scroll; -webkit-overflow-scrolling: touch; /* 解决ios滑动不流畅问题 */&#125;.fix-bottom &#123; position: fixed; bottom: 0; width: 100%;&#125;","categories":[],"tags":[]},{"title":"总结几个移动端H5软键盘的大坑","slug":"总结几个移动端H5软键盘的大坑","date":"2022-04-24T01:47:52.749Z","updated":"2022-04-24T01:59:32.213Z","comments":true,"path":"2022/04/24/总结几个移动端H5软键盘的大坑/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%A7%E5%9D%91/","excerpt":"","text":"1、部分机型软键盘弹起挡住原来的视图解决方法：可以通过监听移动端软键盘弹起 Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。参数如下。 true，表示元素的顶部与当前区域的可见部分的顶部对齐 false，表示元素的底部与当前区域的可见部分的尾部对齐 Element.scrollIntoViewIfNeeded()方法也是用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。此方法是标准的Element.scrollIntoView()方法的专有变体。 1234567891011window.addEventListener(&#x27;resize&#x27;, function() &#123; if (document.activeElement.tagName === &#x27;INPUT&#x27; || document.activeElement.tagName === &#x27;TEXTAREA&#x27;) &#123; window.setTimeout(function() &#123; if (&#x27;scrollIntoView&#x27; in document.activeElement) &#123; document.activeElement.scrollIntoView(false) &#125; else &#123; document.activeElement.scrollIntoViewIfNeeded(false) &#125; &#125;, 0) &#125;&#125;) 2、ios 键盘收起时页面没有回落，底部会留白部分苹果手机填写表单的时候的，输入内容后关闭软键盘，底部会留一块空白。这种情况可以通过监听键盘回落时间滚动到原来的位置。 123456789101112131415window.addEventListener(&#x27;focusout&#x27;, function() &#123; window.scrollTo(0, 0)&#125;)//input输入框弹起软键盘的解决方案。var bfscrolltop = document.body.scrollTop$(&#x27;input&#x27;) .focus(function() &#123; document.body.scrollTop = document.body.scrollHeight //console.log(document.body.scrollTop); &#125;) .blur(function() &#123; document.body.scrollTop = bfscrolltop //console.log(document.body.scrollTop); &#125;) 3、onkeyUp 和 onKeydown 兼容性问题部分 ios 机型 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件 onkeypress 用户按下并放开任何字母数字键时发生。系统按钮（箭头键和功能键）无法得到识别。 onkeyup 用户放开任何先前按下的键盘键时发生。 onkeydown 用户按下任何键盘键（包括系统按钮，如箭头键和功能键）时发生。 4、ios12 输入框难以点击获取焦点，弹不出软键盘定位找到问题是 fastclick.js 对 ios12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改 12345678910FastClick.prototype.focus = function(targetElement) &#123; var length if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#x27;date&#x27;) !== 0 &amp;&amp; targetElement.type !== &#x27;time&#x27; &amp;&amp; targetElement.type !== &#x27;month&#x27;) &#123; length = targetElement.value.length targetElement.setSelectionRange(length, length) targetElement.focus() &#125; else &#123; targetElement.focus() &#125;&#125; 5、fastclick 导致下拉框焦点冲突移动端使用 fastclick 之后，在 ios 环境下，有几个连续的下拉框 第一个 select 框突然填充了第二个下拉框的内容。 根本原因是 Fastclick 导致 ios 下多个 select ，点击某一个，焦点不停变换的 bug。修改源码，在 onTouchStart 事件内判断设备是否为 ios，再判断当前 nodeName 是否为 select，如果是 return false 去阻止 fastClick 执行其他事件。 github 源码地址：fastclick.js 1234567891011//line 391行FastClick.prototype.onTouchStart = function(event) &#123; //在其方法中添加判断 符合ios select的时候 不返回事件 if (deviceIsIOS &amp;&amp; this.targetElement == &#x27;select&#x27;) this.targetElement = null event.preventDefault()&#125;//line521 或者讲源码中 有关touchEnd判断非ios或者非select的事件注释，if (!deviceIsIOS || targetTagName !== &#x27;select&#x27;) &#123; this.targetElement = null event.preventDefault()&#125; 6、ios 下 fixed 失效的原因软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type=text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。 解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll 123456&lt;body&gt; &lt;div class=&#x27;warper&#x27;&gt; &lt;div class=&#x27;main&#x27;&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=&quot;fix-bottom&quot;&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415.warper &#123; position: absolute; width: 100%; left: 0; right: 0; top: 0; bottom: 0; overflow-y: scroll; -webkit-overflow-scrolling: touch; /* 解决ios滑动不流畅问题 */&#125;.fix-bottom &#123; position: fixed; bottom: 0; width: 100%;&#125; 7、ios 键盘换行变为搜索 input type=&quot;search&quot; input 外面套 form，必须要有 action，action=&quot;javascript:return true&quot; 表单提交阻止默认提交事件 123&lt;form action=&quot;javascript:return true&quot; @submit.prevent=&quot;formSubmit&quot;&gt; &lt;input type=&quot;search&quot; placeholder=&quot;请输入诉求名称&quot; id=&quot;search&quot; /&gt;&lt;/form&gt;","categories":[],"tags":[]},{"title":"前端需要注意哪些SEO","slug":"SEO","date":"2022-04-24T01:47:52.743Z","updated":"2022-04-24T01:59:32.071Z","comments":true,"path":"2022/04/24/SEO/","link":"","permalink":"https://data-cz.github.io/2022/04/24/SEO/","excerpt":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标","text":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 如何做SEO优化? 标题与关键词 设置有吸引力切合实际的标题，标题中要包含所做的关键词 网站结构目录 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布 页面元素 给图片标注”Alt”可以让搜索引擎更友好的收录 网站内容 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢 友情链接 对方一定要是正规网站，每天有专业的团队或者个人维护更新 内链的布置 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接 流量分析 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO","categories":[{"name":"前端","slug":"前端","permalink":"https://data-cz.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://data-cz.github.io/tags/Web/"}]},{"title":"HTTP协议","slug":"HTTP协议","date":"2022-04-24T01:47:52.740Z","updated":"2022-04-24T01:59:31.974Z","comments":true,"path":"2022/04/24/HTTP协议/","link":"","permalink":"https://data-cz.github.io/2022/04/24/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"一面中，如果有笔试，考HTTP协议的可能性较大。 1. 前言一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化","text":"一面中，如果有笔试，考HTTP协议的可能性较大。 1. 前言一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要讲的内容； 缓存 CSRF攻击 2. HTTP协议的主要特点 简单快速 灵活 无连接 无状态 通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：无连接、无状态。 我们分别来解释一下。 2.1 简单快速 简单：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。 2.2 灵活 http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。 2.3 无连接 连接一次，就会断开，不会继续保持连接。 2.4 无状态 客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。 有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。 3 HTTP报文的组成部分 在回答此问题时，我们要按照顺序回答： 先回答的是，http报文包括：请求报文和响应报文。 再回答的是，每个报文包含什么部分。 最后回答，每个部分的内容是什么 3.1 请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体 请求体：数据部分。 3.2 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 4 HTTP方法包括： GET：获取资源 POST：传输资源 put：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。 get 和 post&#96; 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。 head 可能偶尔用的到。 5 get 和 post的区别 区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。 有一点要强调，get是相对不隐私的，而post是相对隐私的。 我们大概要记住以下几点： 浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】 get请求会被浏览器主动缓存，而post不会。【重要】 get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 get请求在url中传递的参数有大小限制，基本是2kb&#96;，不同的浏览器略有不同。而post没有注意。 get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。 6 http状态码 http状态码分类： 常见的http状态码： 部分解释： 206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。 301：重定向（永久）。 302：重定向（临时）。 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。 400和401用的不多,未授权。403指的是请求被拒绝。404指的是资源不存在。 7 持久链接&#x2F;http长连接 如果你能答出持久链接，这是面试官很想知道的一个点。 轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。 注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 8 长连接中的管线化 如果能答出管线化，则属于加分项。 8.1 管线化的原理 长连接时，默认的请求这样的： 1请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3 管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。 8.2 管线化的注意事项 面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”","categories":[],"tags":[]},{"title":"http相关","slug":"HTTP","date":"2022-04-24T01:47:52.735Z","updated":"2022-04-24T01:59:31.904Z","comments":true,"path":"2022/04/24/HTTP/","link":"","permalink":"https://data-cz.github.io/2022/04/24/HTTP/","excerpt":"http状态码有那些？分别代表是什么意思？ 12345678910111213141516171819简单版 [ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ]","text":"http状态码有那些？分别代表是什么意思？ 12345678910111213141516171819简单版 [ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload&#x2F;domready、JS执行、JS API绑定等等； 详细版： 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 进行HTTP协议会话，客户端发送报头(请求报头); 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 说说TCP传输的三次握手四次挥手策略 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包 断开一个TCP连接则需要“四次握手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号） 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手 TCP和UDP的区别 TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境 HTTP和HTTPS HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS 默认HTTP的端口号为80，HTTPS的端口号为443 为什么HTTPS安全 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl&#x2F;tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 关于Http 2.0 你知道多少？ HTTP&#x2F;2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP&#x2F;2提供更多的加密支持 HTTP&#x2F;2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽 GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 说说网络分层里七层模型是哪七层 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 讲讲304缓存的原理 服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体 HTTP&#x2F;2 与 HTTP&#x2F;1.x 的关键区别 二进制协议代替文本协议，更加简洁高效 针对每个域只使用一个多路复用的连接 压缩头部信息减小开销 允许服务器主动推送应答到客户端的缓存中 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器) 02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手） 03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com） 04.浏览器跟踪重定向地址，请求另一个带 www 的网址 05.服务器处理请求（通过路由读取资源） 06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text&#x2F;html’） 07.浏览器进 DOM 树构建 08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等） 09.浏览器显示完成页面 10.浏览器发送异步请求","categories":[],"tags":[]},{"title":"如何解决跨域问题","slug":"cross-domain","date":"2022-04-24T01:47:52.732Z","updated":"2022-04-24T01:59:31.811Z","comments":true,"path":"2022/04/24/cross-domain/","link":"","permalink":"https://data-cz.github.io/2022/04/24/cross-domain/","excerpt":"如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里","text":"如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 1234567891011121314151617function createJs(sUrl)&#123; var oScript = document.createElement(&#x27;script&#x27;); oScript.type = &#x27;text/javascript&#x27;; oScript.src = sUrl; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(oScript);&#125;createJs(&#x27;jsonp.js&#x27;);box(&#123; &#x27;name&#x27;: &#x27;test&#x27;&#125;);function box(json)&#123; alert(json.name);&#125; CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法 如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 如何解决跨域问题? document.domain + iframe：要求主域名相同 &#x2F;&#x2F;只能跨子域 JSONP(JSON with Padding)``：response: callback(data)&#96;&#96; &#x2F;&#x2F;只支持 GET 请求 跨域资源共享CORS(XHR2)``：Access-Control-Allow&#96; &#x2F;&#x2F;兼容性 IE10+ 跨文档消息传输(HTML5)：postMessage + onmessage &#x2F;&#x2F;兼容性 IE8+ WebSocket(HTML5)：new WebSocket(url) + onmessage &#x2F;&#x2F;兼容性 IE10+ 服务器端设置代理请求：服务器端不受同源策略限制","categories":[],"tags":[]},{"title":"请你谈谈Cookie的弊端","slug":"cookie","date":"2022-04-24T01:47:52.719Z","updated":"2022-04-24T01:59:32.066Z","comments":true,"path":"2022/04/24/cookie/","link":"","permalink":"https://data-cz.github.io/2022/04/24/cookie/","excerpt":"请你谈谈Cookie的弊端 cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的 第一：每个特定的域名下最多生成20个cookie 1.IE6或更低版本最多20个cookie 2.IE7和之后的版本最后可以有50个cookie。 3.Firefox最多50个cookie 4.chrome和Safari没有做硬性限制","text":"请你谈谈Cookie的弊端 cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的 第一：每个特定的域名下最多生成20个cookie 1.IE6或更低版本最多20个cookie 2.IE7和之后的版本最后可以有50个cookie。 3.Firefox最多50个cookie 4.chrome和Safari没有做硬性限制 请你谈谈Cookie的弊端？ 每个特定的域名下最多生成的 cookie 个数有限制 IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节 如果 cookie 被人拦截了，就可以取得所有的 session 信息","categories":[],"tags":[]},{"title":"搭建一个vue-cli4+webpack移动端框架","slug":"搭建一个vue-cli4+webpack移动端框架","date":"2022-04-24T01:46:49.530Z","updated":"2022-04-24T01:59:32.153Z","comments":true,"path":"2022/04/24/搭建一个vue-cli4+webpack移动端框架/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvue-cli4+webpack%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/","excerpt":"","text":"简介这是基于 vue-cli4 实现的移动端框架，其中包含项目常用的配置，组件封装及webpack优化方法，可供快速开发使用。 技术栈：vue-cli4 + webpack4 + vant + axios + less + postcss-px2rem 源码 https://github.com/Michael-lzg/vue-cli4-vant 12345678// 安装依赖npm install// 本地启动npm run dev// 生产打包npm run build 在一两年前，vue-cli3已经声驾到3.0+版本，但是由于旧项目一致习惯于vue-cli2的脚手架的使用，之前也写过一篇 搭建一个vue-cli的移动端H5开发模板 简单总结了一点移动端的开发技巧。 近日升级vue-cli脚手架才发现，这已经升级到4.0+版本了，觉得很多必要在新的项目中使用vue-cli4进行开发，加上近来对webpack有了进一步理解，所以结合了vue-cli4和webpack搭建了一个移动端框架，以便开箱即用。 主要包括如下技术点： vue-cli4脚手架 vant按需引入 移动端rem适配 axios拦截封装 util工具类函数封装 vue-router配置 登录权限校验 多环境变量配置 vue.config.js配置 toast组件封装 dialog组件封装 跨域代理设置 webpack打包可视化分析 CDN资源优化 gzip打包优化 首页添加骨架屏 关于更多的webpack优化方法，可参考 https://github.com/Michael-lzg/webpack-vue-cli 配置 vantvant 是一套轻量、可靠的移动端 Vue 组件库，非常适合基于 vue 技术栈的移动端开发。在过去很长的一段时间内，本人用的移动端 UI 框架都是 vux。后来由于 vux 不支持 vue-cli3，就转用了 vant，不得不说，无论是在交互体验上，还是代码逻辑上，vant 都比 vux 好很多，而且 vant 的坑比较少。 对于第三方 UI 组件，如果是全部引入的话，比如会造成打包体积过大，加载首页白屏时间过长的问题，所以按需加载非常必要。vant 也提供了按需加载的方法。babel-plugin-import 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。 1、安装依赖 1npm i babel-plugin-import -D 2、配置 .babelrc 或者 babel.config.js 文件 123456789101112131415161718192021// 在.babelrc 中添加配置&#123; &quot;plugins&quot;: [ [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;vant&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: true &#125;] ]&#125;// 对于使用 babel7 的用户，可以在 babel.config.js 中配置module.exports = &#123; plugins: [ [&#x27;import&#x27;, &#123; libraryName: &#x27;vant&#x27;, libraryDirectory: &#x27;es&#x27;, style: true &#125;, &#x27;vant&#x27;] ]&#125;; 3、按需引入 你可以在代码中直接引入 Vant 组件，插件会自动将代码转化为方式二中的按需引入形式 1234import Vue from &#x27;vue&#x27;import &#123; Button &#125; from &#x27;vant&#x27;Vue.use(Button) rem 适配移动端适配是开发过程中不得不面对的事情。在此，我们使用 postcss 中的 px2rem-loader，将我们项目中的 px 按一定比例转化 rem，这样我们就可以对着蓝湖上的标注写 px 了。 我们将 html 字跟字体设置为 100px，很多人选择设置为 375px，但是我觉得这样换算出来的 rem 不够精确，而且我们在控制台上调试代码的时候无法很快地口算得出它本来的 px 值。如果设置 1rem&#x3D;100px，这样我们看到的 0.16rem，0.3rem 就很快得算出原来是 16px，30px 了。 具体步骤如下； 1、安装依赖 1npm install px2rem-loader --save-dev 2、在 vue.config.js 进行如下配置 123456789101112css: &#123; // css预设器配置项 loaderOptions: &#123; postcss: &#123; plugins: [ require(&#x27;postcss-px2rem&#x27;)(&#123; remUnit: 100 &#125;) ] &#125; &#125;&#125;, 3、在 main.js 设置 html 跟字体大小 12345678function initRem() &#123; let cale = window.screen.availWidth &gt; 750 ? 2 : window.screen.availWidth / 375 window.document.documentElement.style.fontSize = `$&#123;100 * cale&#125;px`&#125;window.addEventListener(&#x27;resize&#x27;, function() &#123; initRem()&#125;) axios 请求封装1、设置请求拦截和响应拦截 1234567891011121314151617181920212223242526272829303132333435363738const PRODUCT_URL = &#x27;https://xxxx.com&#x27;const MOCK_URL = &#x27;http://xxxx.com&#x27;let http = axios.create(&#123; baseURL: process.env.NODE_ENV === &#x27;production&#x27; ? PRODUCT_URL : MOCK_URL,&#125;)// 请求拦截器http.interceptors.request.use( (config) =&gt; &#123; // 设置token，Content-Type var token = sessionStorage.getItem(&#x27;token&#x27;) config.headers[&#x27;token&#x27;] = token config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=UTF-8&#x27; // 请求显示loading效果 if (config.loading === true) &#123; vm.$loading.show() &#125; return config &#125;, (error) =&gt; &#123; vm.$loading.hide() return Promise.reject(error) &#125;)// 响应拦截器http.interceptors.response.use( (res) =&gt; &#123; vm.$loading.hide() // token失效，重新登录 if (res.data.code === 401) &#123; // 重新登录 &#125; return res &#125;, (error) =&gt; &#123; vm.$loading.hide() return Promise.reject(error) &#125;) 2、封装 get 和 post 请求方法 12345678910111213141516171819202122232425262728293031323334353637function get(url, data, lodaing) &#123; return new Promise((resolve, reject) =&gt; &#123; http .get(url) .then( (response) =&gt; &#123; resolve(response) &#125;, (err) =&gt; &#123; reject(err) &#125; ) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125;function post(url, data, loading) &#123; return new Promise((resolve, reject) =&gt; &#123; http .post(url, data, &#123; loading: loading &#125;) .then( (response) =&gt; &#123; resolve(response) &#125;, (err) =&gt; &#123; reject(err) &#125; ) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125;export &#123; get, post &#125; 3、把 get，post 方法挂载到 vue 实例上。 123// main.jsimport &#123; get, post &#125; from &#x27;./js/ajax&#x27;Vue.prototype.$http = &#123; get, post &#125; 工具类函数封装1、添加方法到 vue 实例的原型链上 1234567891011export default &#123; install (Vue, options) &#123; Vue.prototype.util = &#123; method1(val) &#123; ... &#125;, method2 (val) &#123; ... &#125;, &#125;&#125; 2、在 main.js 通过 vue.use()注册 12import utils from &#x27;./js/utils&#x27;Vue.use(utils) vue-router 配置平时很多人对 vue-router 的配置可配置了 path 和 component，实现了路由跳转即可。其实 vue-router 可做的事情还有很多，比如 路由懒加载配置 改变单页面应用的 title 登录权限校验 页面缓存配置 路由懒加载配置Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式： 1234567891011121314151617181920// 1、Vue异步组件技术：&#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: resolve =&gt; reqire([&#x27;../views/Home.vue&#x27;], resolve)&#125;// 2、es6提案的import()&#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/Home.vue&#x27;)&#125;// 3、webpack提供的require.ensure()&#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: r =&gt; require.ensure([],() =&gt; r(require(&#x27;../views/Home.vue&#x27;)), &#x27;home&#x27;)&#125; 本项目采用的是第二种方式，为了后续 webpack 打包优化。 改变单页面应用的 title由于单页面应用只有一个 html，所有页面的 title 默认是不会改变的，但是我们可以才路由配置中加入相关属性，再在路由守卫中通过 js 改变页面的 title 123router.beforeEach((to, from, next) =&gt; &#123; document.title = to.meta.title&#125;) 登录权限校验在应用中，通常会有以下的场景，比如商城：有些页面是不需要登录即可访问的，如首页，商品详情页等，都是用户在任何情况都能看到的；但是也有是需要登录后才能访问的，如个人中心，购物车等。此时就需要对页面访问进行控制了。 此外，像一些需要记录用户信息和登录状态的项目，也是需要做登录权限校验的，以防别有用心的人通过直接访问页面的 url 打开页面。 此时。路由守卫可以帮助我们做登录校验。具体如下： 1、配置路由的 meta 对象的 auth 属性 1234567891011121314const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/Home.vue&#x27;), meta: &#123; title: &#x27;首页&#x27;, keepAlive: false, auth: false &#125;, &#125;, &#123; path: &#x27;/mine&#x27;, name: &#x27;mine&#x27;, component: () =&gt; import(&#x27;../views/mine.vue&#x27;), meta: &#123; title: &#x27;我的&#x27;, keepAlive: false, auth: true &#125;, &#125;,] 2、在路由首页进行判断。当to.meta.auth为true(需要登录)，且不存在登录信息缓存时，需要重定向去登录页面 123456789router.beforeEach((to, from, next) =&gt; &#123; document.title = to.meta.title const userInfo = sessionStorage.getItem(&#x27;userInfo&#x27;) || null if (!userInfo &amp;&amp; to.meta.auth) &#123; next(&#x27;/login&#x27;) &#125; else &#123; next() &#125;&#125;) 页面缓存配置项目中，总有一些页面我们是希望加载一次就缓存下来的，此时就用到 keep-alive 了。keep-alive 是 Vue 提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在 v 页面渲染完毕后不会被渲染成一个 DOM 元素。 1、通过配置路由的 meta 对象的 keepAlive 属性值来区分页面是否需要缓存 1234567891011121314const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/Home.vue&#x27;), meta: &#123; title: &#x27;首页&#x27;, keepAlive: false, auth: false &#125;, &#125;, &#123; path: &#x27;/list&#x27;, name: &#x27;list&#x27;, component: () =&gt; import(&#x27;../views/list.vue&#x27;), meta: &#123; title: &#x27;列表页&#x27;, keepAlive: true, auth: false &#125;, &#125;,] 2、在 app.vue 做缓存判断 123456&lt;div id=&quot;app&quot;&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/div&gt; 多环境变量配置首先我们先来了解一下环境变量，一般情况下我们的项目会有三个环境，本地环境(development)，测试环境(test)，生产环境(production)，我们可以在项目根目录下建三个配置环境变量的文件.env.development，.env.test，.env.production 环境变量文件中只包含环境变量的“键&#x3D;值”对： 12NODE_ENV = &#x27;production&#x27;VUE_APP_ENV = &#x27;production&#x27; // 只有VUE_APP开头的环境变量可以在项目代码中直接使用 除了自定义的 VUEAPP*变量之外，还有两个可用的变量： NODE_ENV : “development”、”production” 或 “test”中的一个。具体的值取决于应用运行的模式。 BASE_URL : 和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。 下面开始配置我们的环境变量 1、在项目根目录中新建.env.* .env.development 本地开发环境配置 12NODE_ENV=&#x27;development&#x27;VUE_APP_ENV = &#x27;development&#x27; env.staging 测试环境配置 12NODE_ENV=&#x27;production&#x27;VUE_APP_ENV = &#x27;staging&#x27; env.production 正式环境配置 12NODE_ENV=&#x27;production&#x27;VUE_APP_ENV = &#x27;production&#x27; 为了在不同环境配置更多的变量，我们在 src 文件下新建一个 config&#x2F;index 123// 根据环境引入不同配置 process.env.NODE_ENVconst config = require(&#x27;./env.&#x27; + process.env.VUE_APP_ENV)module.exports = config 在同级目录下新建 env.development.js，env.test.js，env.production.js，在里面配置需要的变量。以 env.development.js 为例 1234module.exports = &#123; baseUrl: &#x27;http://localhost:8089&#x27;, // 项目地址 baseApi: &#x27;https://www.mock.com/api&#x27;, // 本地api请求地址&#125; 2、配置打包命令 package.json 里的 scripts 不同环境的打包命令 通过 npm run serve 启动本地 通过 npm run test 打包测试 通过 npm run build 打包正式 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;test&quot;: &quot;vue-cli-service build --mode test&quot;,&#125; vue.config.js 配置vue-cli3 开始，新建的脚手架都需要我们在 vue.config.js 配置我们项目的东西。主要包括 打包后文件输出位置 关闭生产环境 sourcemap 配置 rem 转化 px 配置 alias 别名 去除生产环境 console 跨域代理设置 此外，还有很多属于优化打包的配置，后面会一一道来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677module.exports = &#123; publicPath: &#x27;./&#x27;, // 默认为&#x27;/&#x27; // 将构建好的文件输出到哪里，本司要求 outputDir: &#x27;dist/static&#x27;, // 放置生成的静态资源(js、css、img、fonts)的目录。 assetsDir: &#x27;static&#x27;, // 指定生成的 index.html 的输出路径 indexPath: &#x27;index.html&#x27;, // 是否使用包含运行时编译器的 Vue 构建版本。 runtimeCompiler: false, transpileDependencies: [], // 如果你不需要生产环境的 source map productionSourceMap: false, // 配置css css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, sourceMap: true, // css预设器配置项 loaderOptions: &#123; postcss: &#123; plugins: [ require(&#x27;postcss-px2rem&#x27;)(&#123; remUnit: 100, &#125;), ], &#125;, &#125;, // 启用 CSS modules for all css / pre-processor files. modules: false, &#125;, // 是一个函数，允许对内部的 webpack 配置进行更细粒度的修改。 chainWebpack: (config) =&gt; &#123; // 配置别名 config.resolve.alias .set(&#x27;@&#x27;, resolve(&#x27;src&#x27;)) .set(&#x27;assets&#x27;, resolve(&#x27;src/assets&#x27;)) .set(&#x27;components&#x27;, resolve(&#x27;src/components&#x27;)) .set(&#x27;views&#x27;, resolve(&#x27;src/views&#x27;)) config.optimization.minimizer(&#x27;terser&#x27;).tap((args) =&gt; &#123; // 去除生产环境console args[0].terserOptions.compress.drop_console = true return args &#125;) &#125;, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 parallel: require(&#x27;os&#x27;).cpus().length &gt; 1, devServer: &#123; host: &#x27;0.0.0.0&#x27;, port: 8088, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: false, // 配置自动启动浏览器 open: &#x27;Google Chrome&#x27;-默认启动谷歌 // 配置多个代理 proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;https://www.mock.com&#x27;, ws: true, // 代理的WebSockets changeOrigin: true, // 允许websockets跨域 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27;, &#125;, &#125;, &#125;, &#125;,&#125; 基础组件封装在开发项目过程中，通常会用到很多功能和设计相类似的组件，toast 和 dialog 组件基本是每一个移动端项目都会用到的。为了更好匹配自己公司的 UI 设计风格，我们没有直接用 vant 的 toast 和 dialog 组件，而是自己封装了类似的组件，可供直接调用，如： 12345678910111213141516this.$toast(&#123; msg: &#x27;手机号码不能为空&#x27; &#125;)this.$toast(&#123; msg: &#x27;成功提示&#x27;, type: &#x27;success&#x27;,&#125;)this.$dialog(&#123; title: &#x27;删除提示&#x27;, text: &#x27;是否确定删除此标签？&#x27;, showCancelBtn: true, confirmText: &#x27;确认&#x27;, confirm(content) &#123; alert(&#x27;删除成功&#x27;) &#125;,&#125;) 效果图如下 toast 传入参数Props name type default description msg String ‘’ 弹窗提示语 type String ‘’ 弹窗类型：success(成功提示),fail(失败提示),warning(警告),loading(加载) dialog 传入参数Props name type default description title String ‘’ 标题 text String ‘’ 文本内容 type String ‘’ 默认纯文本，input(输入框) maxlength Number 20 输入的最多字数 confirmText String 确定 右边按钮 cancelText String 取消 左边按钮 Events name params description confirm null 选择后的回调 cancel ull 取消后的回调 webpack 可视化分析从这里开始，我们开始进行 webpack 优化打包。首先我们来分析一下 webpack 打包性能瓶颈，找出问题所在，然后才能对症下药。此时就用到 webpack-bundle-analyzer 了。1、安装依赖 1npm install webpack-bundle-analyzer -D 2、在 vue.config.js 配置 123456const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;)configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push(new BundleAnalyzerPlugin()) &#125;&#125; 打包后，我们可以看到这样一份依赖图 从以上的界面中，我们可以得到以下信息： 打包出的文件中都包含了什么，以及模块之间的依赖关系 每个文件的大小在总体中的占比，找出较大的文件，思考是否有替换方案，是否使用了它包含了不必要的依赖？ 是否有重复的依赖项，对此可以如何优化？ 每个文件的压缩后的大小。 CDN 资源优化CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 随着项目越做越大，依赖的第三方 npm 包越来越多，构建之后的文件也会越来越大。再加上又是单页应用，这就会导致在网速较慢或者服务器带宽有限的情况出现长时间的白屏。此时我们可以使用 CDN 的方法，优化网络加载速度。 1、将 vue、vue-router、vuex、axios 这些 vue 全家桶的资源，全部改为通过 CDN 链接获取，在 index.html 里插入 相应链接。 12345678&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.6.1/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 2、在 vue.config.js 配置 externals 属性 123456789module.exports = &#123; ··· externals: &#123; &#x27;vue&#x27;: &#x27;Vue&#x27;, &#x27;vuex&#x27;: &#x27;Vuex&#x27;, &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;, &#x27;axios&#x27;:&#x27;axios&#x27; &#125; &#125; 3、卸载相关依赖的 npm 包 1npm uninstall vue vue-router vuex axios 此时启动项目运行就可以了。我们在控制台就能发现项目加载了以上四个 CDN 资源。 不过现在有不少声音说，vue 全家桶加载 CDN 资源其实作用并不大，而且公共的 CDN 资源也没有 npm 包那么稳定，这个就见仁见智了。所以我在源码时新建的分支做这个优化。当项目较小的就不考虑 CDN 优化了。 当然，当引入其他较大第三方资源，比如 echarts，AMAP(高德地图)，采用 CDN 资源还是很有必要的。 gZip 加速优化所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。 gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。 12345678910111213const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new CompressionPlugin(&#123; // gzip压缩配置 test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 对超过10kb的数据进行压缩 deleteOriginalAssets: false, // 是否删除原文件 &#125;) ) &#125;&#125; 首页添加骨架屏随着 SPA 在前端界的逐渐流行，单页面应用不可避免地给首页加载带来压力，此时良好的首页用户体验至关重要。很多 APP 采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。 所谓的骨架屏，就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。在这个过程中用户会感知到内容正在逐渐加载并即将呈现，降低了“白屏”的不良体验。 本文采用vue-skeleton-webpack-plugin插件为单页面应用注入骨架屏。 1、在src的common文件夹下面创建了Skeleton1.vue，Skeleton2.vue，具体的结构和样式自行设计，此处省略一万字。。。。 2、在同级目录下新建entry-skeleton.js 12345678910111213141516import Vue from &#x27;vue&#x27;import Skeleton1 from &#x27;./Skeleton1&#x27;import Skeleton2 from &#x27;./Skeleton2&#x27;export default new Vue(&#123; components: &#123; Skeleton1, Skeleton2 &#125;, template: ` &lt;div&gt; &lt;skeleton1 id=&quot;skeleton1&quot; style=&quot;display:none&quot;/&gt; &lt;skeleton2 id=&quot;skeleton2&quot; style=&quot;display:none&quot;/&gt; &lt;/div&gt; `&#125;) 在vue.config.js下配置插件 123456789101112131415161718192021const SkeletonWebpackPlugin = require(&#x27;vue-skeleton-webpack-plugin&#x27;)configureWebpack: (config) =&gt; &#123; config.plugins.push( new SkeletonWebpackPlugin(&#123; webpackConfig: &#123; entry: &#123; app: path.join(__dirname, &#x27;./src/common/entry-skeleton.js&#x27;), &#125;, &#125;, minimize: true, quiet: true, router: &#123; mode: &#x27;hash&#x27;, routes: [ &#123; path: &#x27;/&#x27;, skeletonId: &#x27;skeleton1&#x27; &#125;, &#123; path: &#x27;/about&#x27;, skeletonId: &#x27;skeleton2&#x27; &#125;, ], &#125;, &#125;) )&#125; 此时重新加载页面就可以看到我们的骨架屏了。注意：一定要配置样式分离extract: true","categories":[],"tags":[]},{"title":"webpack 插件","slug":"总结18个webpack插件","date":"2022-04-24T01:46:49.525Z","updated":"2022-04-24T01:59:31.951Z","comments":true,"path":"2022/04/24/总结18个webpack插件/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%BB%E7%BB%9318%E4%B8%AAwebpack%E6%8F%92%E4%BB%B6/","excerpt":"","text":"Plugin何为插件(Plugin)？专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。 Plugin 的特点 是一个独立的模块 模块对外暴露一个 js 函数 函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply方法 apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback 完成自定义子编译流程并处理 complition 对象的内部数据 如果异步编译插件的话，数据处理完成后执行 callback 回调。 下面介绍 18 个常用的 webpack 插件 HotModuleReplacementPlugin模块热更新插件。Hot-Module-Replacement 的热更新是依赖于 webpack-dev-server，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，HRM 是只更新修改的部分。 HotModuleReplacementPlugin是webpack模块自带的，所以引入webpack后，在plugins配置项中直接使用即可。 12345const webpack = require(&#x27;webpack&#x27;)plugins: [ new webpack.HotModuleReplacementPlugin(), // 热更新插件] html-webpack-plugin生成 html 文件。将 webpack 中entry配置的相关入口 chunk 和 extract-text-webpack-plugin抽取的 css 样式 插入到该插件提供的template或者templateContent配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式link插入到head元素中，script插入到head或者body中。 123456789101112131415const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)plugins: [ new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: path.join(__dirname, &#x27;/index.html&#x27;), minify: &#123; // 压缩HTML文件 removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true, // 压缩内联css &#125;, inject: true, &#125;),] inject 有四个选项值 true：默认值，script 标签位于 html 文件的 body 底部 body：script 标签位于 html 文件的 body 底部（同 true） head：script 标签位于 head 标签内 false：不插入生成的 js 文件，只是单纯的生成一个 html 文件 多页应用打包 有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 webpack 进行打包呢。 1234567891011121314151617181920212223const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, login: &#x27;./src/login.js&#x27;, &#125;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;[name].[hash:6].js&#x27;, &#125;, //... plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27;, filename: &#x27;index.html&#x27;, //打包后的文件名 &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./public/login.html&#x27;, filename: &#x27;login.html&#x27;, //打包后的文件名 &#125;), ],&#125; 如果需要配置多个 HtmlWebpackPlugin，那么 filename 字段不可缺省，否则默认生成的都是 index.html。 但是有个问题，index.html 和 login.html 会发现，都同时引入了 index.f7d21a.js 和 login.f7d21a.js，通常这不是我们想要的，我们希望 index.html 中只引入 index.f7d21a.js，login.html 只引入 login.f7d21a.js。 HtmlWebpackPlugin 提供了一个 chunks 的参数，可以接受一个数组，配置此参数仅会将数组中指定的 js 引入到 html 文件中 123456789101112131415module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27;, filename: &#x27;index.html&#x27;, //打包后的文件名 chunks: [&#x27;index&#x27;], &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./public/login.html&#x27;, filename: &#x27;login.html&#x27;, //打包后的文件名 chunks: [&#x27;login&#x27;], &#125;), ],&#125; 这样执行 npm run build，可以看到 index.html 中仅引入了 index 的 js 文件，而 login.html 中也仅引入了 login 的 js 文件。 clean-webpack-pluginclean-webpack-plugin 用于在打包前清理上一次项目生成的 bundle 文件，它会根据 output.path 自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。 12345678const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;/index.html&#x27;), &#125;), new CleanWebpackPlugin(), // 所要清理的文件夹名称] extract-text-webpack-plugin将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象 123456const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;)plugins: [ // 将css分离到/dist文件夹下的css文件夹中的index.css new ExtractTextPlugin(&#x27;css/index.css&#x27;),] mini-css-extract-plugin将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 sourceMap。只能用在 webpack4 中，对比另一个插件 extract-text-webpack-plugin 有以下特点: 异步加载 不重复编译，性能更好 更容易使用 只针对 CSS 这个插件应该只用在生产环境配置，并且在 loaders 链中不使用 style-loader, 而且这个插件暂时不支持 HMR 12345678910111213141516171819202122232425262728const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(le|c)ss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: &#x27;../&#x27;, &#125;, &#125;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;, &#x27;less-loader&#x27;, ], &#125;, ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: &#x27;css/[name].[contenthash:8].css&#x27;, chunkFilename: &#x27;css/[id].[contenthash:8].css&#x27;, &#125;), ],&#125; purifycss-webpack有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。 1234567891011const path = require(&#x27;path&#x27;)const PurifyCssWebpack = require(&#x27;purifycss-webpack&#x27;) // 引入PurifyCssWebpack插件const glob = require(&#x27;glob&#x27;) // 引入glob模块,用于扫描全部html文件中所引用的cssmodule.exports = merge(common, &#123; plugins: [ new PurifyCssWebpack(&#123; paths: glob.sync(path.join(__dirname, &#x27;src/*.html&#x27;)), &#125;), ],&#125;) optimize-css-assets-webpack-plugin我们希望减小 css 打包后的体积，可以用到 optimize-css-assets-webpack-plugin。 1234567const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;) // 压缩css代码optimization: &#123; minimizer: [ // 压缩css new OptimizeCSSAssetsPlugin(&#123;&#125;) ] UglifyJsPluginuglifyJsPlugin 是 vue-cli 默认使用的压缩代码方式，用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。 123456789101112const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)plugins: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: true, //是否启用文件缓存 parallel: true //使用多进程并行运行来提高构建速度 &#125;) ParallelUglifyPlugin开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 1234567891011121314151617const ParallelUglifyPlugin = require(&#x27;webpack-parallel-uglify-plugin&#x27;)plugins: [ new ParallelUglifyPlugin(&#123; //cacheDir 用于配置缓存存放的目录路径。 cacheDir: &#x27;.cache/&#x27;, sourceMap: true, uglifyJS: &#123; output: &#123; comments: false, &#125;, compress: &#123; warnings: false, &#125;, &#125;, &#125;),] terser-webpack-pluginWebpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。 1234567891011const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;) // 压缩js代码optimization: &#123; minimizer: [ new TerserPlugin(&#123; parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1 cache: true, // 是否缓存 sourceMap: false, &#125;), ]&#125; NoErrorsPlugin报错但不退出 webpack 进程。编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段。这样可以确保输出资源不会包含错误。 1plugins: [new webpack.NoEmitOnErrorsPlugin()] compression-webpack-plugin所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。 gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。 12345678910const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)plugins: [ new CompressionPlugin(&#123; // gzip压缩配置 test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 对超过10kb的数据进行压缩 deleteOriginalAssets: false, // 是否删除原文件 &#125;),] 当然，这个方法还需要后端配置支持。 DefinePlugin我们可以通过 DefinePlugin 可以定义一些全局的变量，我们可以在模块当中直接使用这些变量，无需作任何声明，DefinePlugin 是 webpack 自带的插件。 12345678plugins: [ new webpack.DefinePlugin(&#123; DESCRIPTION: &#x27;This Is The Test Text.&#x27;, &#125;),]// 直接引用console.log(DESCRIPTION) ProvidePlugin自动加载模块。 任何时候，当 identifier 被当作未赋值的变量时， module 就会自动被加载，并且 identifier 会被这个 module 输出的内容所赋值。这是 webpack 自带的插件。 1234567891011121314module.exports = &#123; resolve: &#123; alias: &#123; jquery: &#x27;./lib/jquery&#x27;, &#125;, &#125;, plugins: [ //提供全局的变量，在模块中使用无需用require引入 new webpack.ProvidePlugin(&#123; $: &#x27;jquery&#x27;, React: &#x27;react&#x27;, &#125;), ],&#125; DLLPlugin这是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 bundle(dll-only-bundle)。 这个插件会生成一个名为 manifest.json 的文件，这个文件是用来让 DLLReferencePlugin 映射到相关的依赖上去的。 使用步骤如下 1、在 build 下创建 webpack.dll.config.js 123456789101112131415161718192021222324252627282930313233const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; entry: &#123; vendor: [ &#x27;vue-router&#x27;, &#x27;vuex&#x27;, &#x27;vue/dist/vue.common.js&#x27;, &#x27;vue/dist/vue.js&#x27;, &#x27;vue-loader/lib/component-normalizer.js&#x27;, &#x27;vue&#x27;, &#x27;axios&#x27;, &#x27;echarts&#x27;, ], &#125;, output: &#123; path: path.resolve(&#x27;./dist&#x27;), filename: &#x27;[name].dll.js&#x27;, library: &#x27;[name]_library&#x27;, &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.resolve(&#x27;./dist&#x27;, &#x27;[name]-manifest.json&#x27;), name: &#x27;[name]_library&#x27;, &#125;), // 建议加上代码压缩插件，否则dll包会比较大。 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125;, &#125;), ],&#125; 2、在 webpack.prod.conf.js 的 plugin 后面加入配置 123new webpack.DllReferencePlugin(&#123; manifest: require(&#x27;../dist/vendor-manifest.json&#x27;),&#125;) 3、package.json文件中添加快捷命令(build:dll) 1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;build:dll&quot;: &quot;webpack --config build/webpack.dll.conf.js&quot;&#125; 生产环境打包的时候先npm run build:dll命令会在打包目录下生成 vendor-manifest.json 文件与 vendor.dll.js 文件。然后npm run build生产其他文件。 4、根目录下的入口 index.html 加入引用 1&lt;script type=&quot;text/javascript&quot; src=&quot;./vendor.dll.js&quot;&gt;&lt;/script&gt; HappyPackHappyPack 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 HappyPack 对 file-loader、url-loader 支持的不友好，所以不建议对该 loader 使用。 1、HappyPack 插件安装 1npm i -D happypack 2、webpack.base.conf.js 文件对 module.rules 进行配置 1234567891011121314module: &#123; rules: [ &#123; test: /\\.js$/, use: [&#x27;happypack/loader?id=babel&#x27;], include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)], exclude: path.resolve(__dirname, &#x27;node_modules&#x27;), &#125;, &#123; test: /\\.vue$/, use: [&#x27;happypack/loader?id=vue&#x27;], &#125;, ]&#125; 3、在生产环境 webpack.prod.conf.js 文件进行配置 12345678910111213141516171819202122const HappyPack = require(&#x27;happypack&#x27;)// 构造出共享进程池，在进程池中包含5个子进程const HappyPackThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;)plugins: [ new HappyPack(&#123; // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件 id: &#x27;babel&#x27;, // 如何处理.js文件，用法和Loader配置中一样 loaders: [&#x27;babel-loader?cacheDirectory&#x27;], threadPool: HappyPackThreadPool, &#125;), new HappyPack(&#123; id: &#x27;vue&#x27;, // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件 loaders: [ &#123; loader: &#x27;vue-loader&#x27;, options: vueLoaderConfig, &#125;, ], threadPool: HappyPackThreadPool, &#125;),] 注意，当项目较小时，多线程打包反而会使打包速度变慢。 copy-webpack-plugin我们在 public/index.html 中引入了静态资源，但是打包的时候 webpack 并不会帮我们拷贝到 dist 目录，因此 copy-webpack-plugin 就可以很好地帮我做拷贝的工作了。 1234567891011121314const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new CopyWebpackPlugin(&#123; patterns: [ &#123; from: &#x27;public/js/*.js&#x27;, to: path.resolve(__dirname, &#x27;dist&#x27;, &#x27;js&#x27;), flatten: true, &#125;, ], &#125;), ],&#125; IgnorePlugin这是 webpack 内置插件，它的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去。 比如我们要使用 moment 这个第三方依赖库，该库主要是对时间进行格式化，并且支持多个国家语言。虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢。对此，我们可以用 IgnorePlugin 使得指定目录被忽略，从而使得打包变快，文件变小。 12345const Webpack = require(&#x27;webpack&#x27;)plugins: [ //moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去 new Webpack.IgnorePlugin(/\\.\\/locale/, /moment/),] 我们虽然按照上面的方法忽略了包含’./locale/&#39;该字段路径的文件目录，但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录。 123456789import moment from &#x27;moment&#x27;//手动引入所需要的语言包import &#x27;moment/locale/zh-cn&#x27;moment.locale(&#x27;zh-cn&#x27;)let r = moment().endOf(&#x27;day&#x27;).fromNow()console.log(r)","categories":[],"tags":[]},{"title":"零构建一个wbpack项目","slug":"从零构建一个wbpack项目","date":"2022-04-24T01:46:49.519Z","updated":"2022-04-24T01:59:31.566Z","comments":true,"path":"2022/04/24/从零构建一个wbpack项目/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAwbpack%E9%A1%B9%E7%9B%AE/","excerpt":"从零构建一个wbpack项目1、新建项目新建一个空文件夹，用于创建项目，使用 npm init 命令创建一个 package.json 文件。输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，也可以使用 npm init -y 这个命令来一次生成 package.json 文件，这样终端不会询问你问题。","text":"从零构建一个wbpack项目1、新建项目新建一个空文件夹，用于创建项目，使用 npm init 命令创建一个 package.json 文件。输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，也可以使用 npm init -y 这个命令来一次生成 package.json 文件，这样终端不会询问你问题。 2、安装 webpack安装 webapck 时把 webpack-cli 也装上是因为在 webpack4.x 版本后 webpack 模块把一些功能分到了 webpack-cli 模块，所以两者都需要安装，安装方法如下： 12npm install webpack webpack-cli --global //这是安装全局webpack及webpack-cli模块npm install webpack webpack-cli --save-dev //这是安装本地项目模块 3、新建文件在根目录件夹中新建两个文件夹，分别为 src 文件夹和 dist 文件夹，接下来再创建三个文件:此时，项目结构如下 index.html –放在 dist 文件夹中； hello.js –放在 src 文件夹中； index.js –放在 src 文件夹中； 3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件：1234567891011&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Webpack Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&gt; &lt;/body&gt;&lt;/html&gt; 3.2、在 hello.js 中导出一个模块：123456// hello.jsmodule.exports = function() &#123; let hello = document.createElement(&#x27;div&#x27;) hello.innerHTML = &#x27;welcome to China!&#x27; return hello&#125; 3.3、在 index.js 中引入这个模块（hello.js）:123//index.jsconst hello = require(&#x27;./hello.js&#x27;)document.querySelector(&#x27;#root&#x27;).appendChild(hello()) 上述操作就相当于我们把 hello.js 模块合并到了 index.js 模块，之后我们打包时就只需把 index.js 模块打包成 bundle.js 即可。 3.4、进行最简单的 webpack 打包12// 在终端中使用如下命令进行打包：webpack src/index.js --output dist/bundle.js 上述就相当于把 src 文件夹下的 index.js 文件打包到 dist 文件下的 bundle.js，这时就生成了 bundle.js 供 index.html 文件引用。现在打开 index.html 就可以看到我们的页面了。 4、配置 webpack.config.js上述打包方式太 low 了，我们可以在当前项目的根目录下新建一个配置文件 webpack.config.js 用来配置打包方式。webpack.config.js 配置如下 12345678const path = require(&#x27;path&#x27;) // 处理绝对路径module.exports = &#123; entry: path.join(__dirname, &#x27;/src/index.js&#x27;), // 入口文件 output: &#123; path: path.join(__dirname, &#x27;/dist&#x27;), //打包后的文件存放的地方 filename: &#x27;bundle.js&#x27; //打包后输出文件的文件名 &#125;&#125; 有了这个配置文件，我们只需在终端中运行 webpack 命令就可进行打包，这条命令会自动引用 webpack.config.js 文件中的配置选项。 5、构建本地服务器现在我们是通过打开本地文件来查看页面的，感觉还是有点 low。例如 vue, react 等脚手架都是在本地服务器运行的。所以我们再做进一步优化。 5.1 webpack-dev-server 配置本地服务器Webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的组件，在 webpack 中进行配置之前需要单独安装它作为项目依赖：npm i webpack-dev-server -D 以下是devServer 的一些配置选项: contentBase ：设置服务器所读取文件的目录，当前我们设置为”.&#x2F;dist” port ：设置端口号，如果省略，默认为 8080 inline ：设置为 true，当源文件改变时会自动刷新页面 historyApiFallback ：设置为 true，所有的跳转将指向 index.html 现在我们把这些配置加到 webpack.config.js 文件上，如下： 123456789101112131415// webpack.config.jsconst path = require(&#x27;path&#x27;)module.exports = &#123; entry: path.join(__dirname, &#x27;/src/index.js&#x27;), // 入口文件 output: &#123; path: path.join(__dirname, &#x27;/dist&#x27;), //打包后的文件存放的地方 filename: &#x27;bundle.js&#x27; //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: &#x27;./dist&#x27;, // 本地服务器所加载文件的目录 port: &#x27;8088&#x27;, // 设置端口号为8088 inline: true, // 文件修改后实时刷新 historyApiFallback: true //不跳转 &#125;&#125; 5.2、package.json 文件中添加启动和打包命令package.json 文件修改如下 123456789101112131415161718&#123; &quot;name&quot;: &quot;webpack-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.23.1&quot;, &quot;webpack-cli&quot;: &quot;^3.1.2&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot; &#125;&#125; 这样我们就可以用以下命令进行本地运行或者打包文件了 npm run dev 启动本地服务器，webpack-dev-server 就是启动服务器的命令，–open 是用于启动完服务器后自动打开浏览器。 npm run build 执行打包命令 此时，我们只要输入 npm run dev 就可以在http://localhost:8088/中查看页面了。 6、配置常用 loaderloader 可以让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 Loaders 的配置包括以下几方面： test：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须） loader：loader 的名称（必须） include&#x2F;exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； options：为 loaders 提供额外的设置选项（可选） 配置 css-loader 和 sass-loader如果我们要加载一个 css 文件，需要安装配置 style-loader 和 css-loader。如果我们要使用 sass，就要配置 sass-loader 和 node-sass。 css-loader：加载.css 文件 style-loader：使用 style 标签将 css-loader 内部样式注入到我们的 HTML 页面 12345678910111213141516171819202122232425const path = require(&#x27;path&#x27;)module.exports = &#123; entry: path.join(__dirname, &#x27;/src/index.js&#x27;), // 入口文件 output: &#123; path: path.join(__dirname, &#x27;/dist&#x27;), //打包后的文件存放的地方 filename: &#x27;bundle.js&#x27; //打包后输出文件的文件名 &#125;, devServer: &#123; contentBase: &#x27;./dist&#x27;, // 本地服务器所加载文件的目录 port: &#x27;8088&#x27;, // 设置端口号为8088 inline: true, // 文件修改后实时刷新 historyApiFallback: true //不跳转 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 正则匹配以.css结尾的文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#123; test: /\\.(scss|sass)$/, // 正则匹配以.scss和.sass结尾的文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125; ] &#125;&#125; 配置 Babel-loaderBabel 其实是一个编译 JavaScript 的平台，它可以编译代码帮你达到以下目的： 让你能使用最新的 JavaScript 代码（ES6，ES7…）； 让你能使用基于 JavaScript 进行了拓展的语言，比如 React 的 JSX； 12345678910module: &#123; ... rules: [ &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, include: [resolve(&#x27;src&#x27;)] &#125; ]&#125; 处理图片处理图片资源时，我们常用的两种 loader 是 file-loader 或者 url-loader。当使用 url-loader 加载图片，图片小于上限值，则将图片转 base64 字符串，否则使用 file-loader 加载图片。 12345678910111213module: &#123; ... rules: [ &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;) &#125; &#125; ]&#125; 7、配置常用插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 7.1、自动生成 html 文件(HtmlWebpackPlugin)现在我们都是使用一开始建好的 index.html 文件，然后手动引入 bundle.js，如果以后我们引入不止一个 js 文件，那就得更改 index.html 中的 js 文件名，所以能不能自动生成 index.html 且自动引用打包后的 js 呢？HtmlWebpackPlugin 插件就是用来解决这个问题的： 安装插件 npm i html-webpack-plugin -D 把 dist 文件夹清空 在根目录新建 index.html,内容和原来的 html 一致，只是不引入 js 文件。 webpack.config.js 中我们引入了 HtmlWebpackPlugin 插件 123456789101112plugins: [ new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;index.html&#x27;, inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;)] 此时我们使用 npm run build 进行打包，你会发现，dist 文件夹和 html 文件都会自动生成。 7.2、清理&#x2F;dist 文件夹(CleanWebpackPlugin)在每次构建前清理&#x2F;dist 文件夹，生产最新的打包文件，这时候就用到 CleanWebpackPlugin 插件了。 安装 npm i clean-webpack-plugin -D 配置 webpack.config.js 12345678910111213plugins: [ new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;index.html&#x27;, inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;), new CleanWebpackPlugin([&#x27;dist&#x27;])] 7.3、热更新(HotModuleReplacementPlugin)我们要在修改代码后自动更新页面，这就需要 HotModuleReplacementPlugin（HMR）插件 devServer 配置项中添加 hot: true 参数。 因为 HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。 1234567891011121314plugins: [ new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;index.html&#x27;, inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;), new CleanWebpackPlugin([&#x27;dist&#x27;]) new webpack.HotModuleReplacementPlugin()] 7.4、增加 css 前缀平时我们写 css 时，一些属性需要手动加上前缀，比如-webkit-border-radius: 10px;，在 webpack 中我们可以让他自动加上 安装 npm i postcss-loader autoprefixer -D 在项目根目录下新建 postcss.config.js 文件 12345678910111213141516171819202122module.exports = &#123; plugins: [ require(&#x27;autoprefixer&#x27;) // 引用autoprefixer模块 ]&#125;module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\\.css$/, // 正则匹配以.css结尾的文件 use: [ &#123; loader: &#x27;style-loader&#x27; &#125;, // 这里采用的是对象配置loader的写法 &#123; loader: &#x27;css-loader&#x27; &#125;, &#123; loader: &#x27;postcss-loader&#x27; &#125; // 使用postcss-loader ] &#125; ... ] &#125; ...&#125; 7.5、css 分离 ExtractTextPlugin将 css 成生文件，而非内联。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。 安装 npm i extract-text-webpack-plugin@next -D 在 webpack.common.js 文件中引入并使用该插件： 123456789101112131415161718const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;) //引入分离插件module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, // 正则匹配以.css结尾的文件 use: ExtractTextPlugin.extract(&#123; // 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理 fallback: &#x27;style-loader&#x27;, use: [&#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;] &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&#x27;css/index.css&#x27;) // 将css分离到/dist文件夹下的css文件夹中的index.css ]&#125; 此时运行 npm run build 后会发现&#x2F;dist 文件夹内多出了&#x2F;css 文件夹及 index.css 文件。 7.6、消除冗余 css有时候我们 css 写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，以下方法可以优化 安装 npm i purifycss-webpack purify-css glob -D 引入 clean-webpack-plugin 及 glob 插件并使用 12345678const PurifyCssWebpack = require(&#x27;purifycss-webpack&#x27;) // 引入PurifyCssWebpack插件const glob = require(&#x27;glob&#x27;) // 引入glob模块,用于扫描全部html文件中所引用的cssplugins: [ new PurifyCssWebpack(&#123; paths: glob.sync(path.join(__dirname, &#x27;src/*.html&#x27;)) // 同步扫描所有html文件中所引用的css &#125;)] 至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。","categories":[],"tags":[]},{"title":"webpack 异步加载原理","slug":"webpack的异步加载及分包策略","date":"2022-04-24T01:46:49.515Z","updated":"2022-04-24T01:59:32.198Z","comments":true,"path":"2022/04/24/webpack的异步加载及分包策略/","link":"","permalink":"https://data-cz.github.io/2022/04/24/webpack%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%88%86%E5%8C%85%E7%AD%96%E7%95%A5/","excerpt":"webpack 异步加载原理webpack ensure 有人称它为异步加载，也有人称为代码切割，他其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 script 对象，加入到 document.head 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作。 举个例子需求：main.js 依赖两个 js 文件：A.js 是点击 aBtn 按钮后，才执行的逻辑，B.js 是点击 bBtn 按钮后，才执行的逻辑。 webpack.config.js，我们先来写一下 webpack 打包的配置的代码","text":"webpack 异步加载原理webpack ensure 有人称它为异步加载，也有人称为代码切割，他其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 script 对象，加入到 document.head 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作。 举个例子需求：main.js 依赖两个 js 文件：A.js 是点击 aBtn 按钮后，才执行的逻辑，B.js 是点击 bBtn 按钮后，才执行的逻辑。 webpack.config.js，我们先来写一下 webpack 打包的配置的代码 12345678910111213141516171819const path = require(&#x27;path&#x27;) // 路径处理模块const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;) // 引入CleanWebpackPlugin插件module.exports = &#123; entry: &#123; index: path.join(__dirname, &#x27;/src/main.js&#x27;), &#125;, output: &#123; path: path.join(__dirname, &#x27;/dist&#x27;), filename: &#x27;index.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;/index.html&#x27;), &#125;), new CleanWebpackPlugin(), // 所要清理的文件夹名称 ],&#125; index.html 代码如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button id=&quot;aBtn&quot;&gt;按钮A&lt;/button&gt; &lt;button id=&quot;bBtn&quot;&gt;按钮B&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 入口文件 main.js 如下 12345678910import A from &#x27;./A&#x27;import B from &#x27;./B&#x27;document.getElementById(&#x27;aBtn&#x27;).onclick = function () &#123; alert(A)&#125;document.getElementById(&#x27;bBtn&#x27;).onclick = function () &#123; alert(B)&#125; A.js 和 B.js 的代码分别如下 1234567// A.jsconst A = &#x27;hello A&#x27;module.exports = A// B.jsconst B = &#x27;hello B&#x27;module.exports = B 此时，我们对项目进行 npm run build， 打包出来的只有两个文件 index.html index.js 由此可见，此时 webpack 把 main.js 依赖的两个文件都同时打包到同一个 js 文件，并在 index.html 中引入。但是 A.js 和 B.js 都是点击相应按钮才会执行的逻辑，如果用户并没有点击相应按钮，而且这两个文件又是比较大的话，这样是不是就导致首页默认加载的 js 文件太大，从而导致首页渲染较慢呢？那么有能否实现当用户点击按钮的时候再加载相应的依赖文件呢？ webpack.ensure 就解决了这个问题。 require.ensure 异步加载下面我们将 main.js 改成异步加载的方式 123456789101112131415document.getElementById(&#x27;aBtn&#x27;).onclick = function () &#123; //异步加载A require.ensure([], function () &#123; let A = require(&#x27;./A.js&#x27;) alert(A) &#125;)&#125;document.getElementById(&#x27;bBtn&#x27;).onclick = function () &#123; //异步加载b require.ensure([], function () &#123; let B = require(&#x27;./B.js&#x27;) alert(B) &#125;)&#125; 此时，我们再进行一下打包，发现多了 1.index.js 和 2.index.js 两个文件。而我们打开页面时只引入了 index.js 一个文件，当点击按钮 A 的时候才引入 1.index.js 文件，点击按钮 B 的时候才引入 2.index.js 文件。这样就满足了我们按需加载的需求。 require.ensure 这个函数是一个代码分离的分割线，表示回调里面的 require 是我们想要进行分割出去的，即 require(&#39;./A.js&#39;)，把 A.js 分割出去，形成一个 webpack 打包的单独 js 文件。它的语法如下 1require.ensure(dependencies: String[], callback: function(require), chunkName: String) 我们打开 1.index.js 文件，发现它的代码如下 123456789;(window.webpackJsonp = window.webpackJsonp || []).push([ [1], [ , function (o, n) &#123; o.exports = &#x27;hello A&#x27; &#125;, ],]) 由上面的代码可以看出： 异步加载的代码，会保存在一个全局的 webpackJsonp 中。 webpackJsonp.push 的的值，两个参数分别为异步加载的文件中存放的需要安装的模块对应的 id 和异步加载的文件中存放的需要安装的模块列表。 在满足某种情况下，会执行具体模块中的代码。 import() 按需加载webpack4 官方文档提供了模块按需切割加载，配合 es6 的按需加载 import() 方法，可以做到减少首页包体积，加快首页的请求速度，只有其他模块，只有当需要的时候才会加载对应 js。 import()的语法十分简单。该函数只接受一个参数，就是引用包的地址，并且使用了 promise 式的回调，获取加载的包。在代码中所有被 import()的模块，都将打成一个单独的包，放在 chunk 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。 下面我们将上述代码改成 import()方式。 12345678910111213document.getElementById(&#x27;aBtn&#x27;).onclick = function () &#123; //异步加载A import(&#x27;./A&#x27;).then((data) =&gt; &#123; alert(data.A) &#125;)&#125;document.getElementById(&#x27;bBtn&#x27;).onclick = function () &#123; //异步加载b import(&#x27;./B&#x27;).then((data) =&gt; &#123; alert(data.B) &#125;)&#125; 此时打包出来的文件和 webpack.ensure 方法是一样的。 路由懒加载为什么需要懒加载？ 像 vue 这种单页面应用，如果没有路由懒加载，运用 webpack 打包后的文件将会很大，造成进入首页时，需要加载的内容过多，出现较长时间的白屏，运用路由懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。 vue 路由懒加载有以下三种方式 vue 异步组件 ES6 的 import() webpack 的 require.ensure() vue 异步组件这种方法主要是使用了 resolve 的异步机制，用 require 代替了 import 实现按需加载 123456789101112export default new Router(&#123; routes: [ &#123; path: &#x27;/home&#x27;,&#x27;, component: (resolve) =&gt; require([&#x27;@/components/home&#x27;], resolve), &#125;, &#123; path: &#x27;/about&#x27;,&#x27;, component: (resolve) =&gt; require([&#x27;@/components/about&#x27;], resolve), &#125;, ],&#125;) require.ensure这种模式可以通过参数中的 webpackChunkName 将 js 分开打包。 123456789101112export default new Router(&#123; routes: [ &#123; path: &#x27;/home&#x27;, component: (resolve) =&gt; require.ensure([], () =&gt; resolve(require(&#x27;@/components/home&#x27;)), &#x27;home&#x27;), &#125;, &#123; path: &#x27;/about&#x27;, component: (resolve) =&gt; require.ensure([], () =&gt; resolve(require(&#x27;@/components/about&#x27;)), &#x27;about&#x27;), &#125;, ],&#125;) ES6 的 import()vue-router 在官网提供了一种方法，可以理解也是为通过 Promise 的 resolve 机制。因为 Promise 函数返回的 Promise 为 resolve 组件本身，而我们又可以使用 import 来导入组件。 123456789101112export default new Router(&#123; routes: [ &#123; path: &#x27;/home&#x27;, component: () =&gt; import(&#x27;@/components/home&#x27;), &#125;, &#123; path: &#x27;/about&#x27;, component: () =&gt; import(&#x27;@/components/home&#x27;), &#125;, ],&#125;) webpack 分包策略在 webpack 打包过程中，经常出现 vendor.js， app.js 单个文件较大的情况，这偏偏又是网页最先加载的文件，这就会使得加载时间过长，从而使得白屏时间过长，影响用户体验。所以我们需要有合理的分包策略。 CommonsChunkPlugin在 Webapck4.x 版本之前，我们都是使用 CommonsChunkPlugin 去做分离 1234567891011121314151617plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, minChunks: function (module, count) &#123; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(path.join(__dirname, &#x27;./node_modules&#x27;)) === 0 ) &#125;, &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;common&#x27;, chunks: &#x27;initial&#x27;, minChunks: 2, &#125;),] 我们把以下文件单独抽离出来打包 node_modules 文件夹下的，模块 被 3 个 入口 chunk 共享的模块 optimization.splitChunkswebpack 4 最大的改动就是废除了 CommonsChunkPlugin 引入了 optimization.splitChunks。如果你的 mode 是 production，那么 webpack4 就会自动开启 Code Splitting。 它内置的代码分割策略是这样的： 新的 chunk 是否被共享或者是来自 node_modules 的模块 新的 chunk 体积在压缩之前是否大于 30kb 按需加载 chunk 的并发请求数量小于等于 5 个 页面初始加载时的并发请求数量小于等于 3 个 虽然在 webpack4 会自动开启 Code Splitting，但是随着项目工程的最大，这往往不能满足我们的需求，我们需要再进行个性化的优化。 应用实例我们先找到一个优化空间较大的项目来进行操作。这是一个后台管理系统项目，大部分内容由 3-4 个前端开发，平时开发周期较短，且大部分人没有优化意识，只是写好业务代码完成需求，日子一长，造成打包出来的文件较大，大大影响性能。 我们先用 webpack-bundle-analyzer 分析打包后的模块依赖及文件大小，确定优化的方向在哪。 然后我们再看下打包出来的 js 文件 看到这两张图的时候，我内心是崩溃的，槽点如下 打包后生成多个将近 1M 的 js 文件，其中不乏 vendor.js 首页必须加载的大文件 xlsx.js 这样的插件没必要使用，导出 excel 更好的方法应该是后端返回文件流格式给前端处理 echart 和 iview 文件太大，应该使用 cdn 引入的方法 吐槽完之后我们就要开始做正事了。正是因为有这么多槽点，我们才更好用来验证我们优化方法的可行性。 抽离 echart 和 iview由上面分析可知，echart 和 iview 文件太大，此时我们就用到 webpack4 的 optimization.splitChunks 进行代码分割了，把他们单独抽离打包成文件。(为了更好地呈现优化效果，我们先把 xlsx.js 去掉) vue.config.js 修改如下： 123456789101112131415161718192021222324252627282930chainWebpack: config =&gt; &#123; config.optimization.splitChunks(&#123; chunks: &#x27;all&#x27;, cacheGroups: &#123; vendors: &#123; name: &#x27;chunk-vendors&#x27;, test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: &#x27;initial&#x27; &#125;, iview: &#123; name: &#x27;chunk-iview&#x27;, priority: 20, test: /[\\\\/]node_modules[\\\\/]_?iview(.*)/ &#125;, echarts: &#123; name: &#x27;chunk-echarts&#x27;, priority: 20, test: /[\\\\/]node_modules[\\\\/]_?echarts(.*)/ &#125;, commons: &#123; name: &#x27;chunk-commons&#x27;, minChunks: 2, priority: 5, chunks: &#x27;initial&#x27;, reuseExistingChunk: true &#125; &#125; &#125;) &#125;, 此时我们再用 webpack-bundle-analyzer 分析一下 打包出来的 js 文件 从这里可以看出我们已经成功把 echart 和 iview 单独抽离出来了，同时 vendor.js 也相应地减小了体积。此外，我们还可以继续抽离其他更多的第三方模块。 CDN 方式虽然第三方模块是单独抽离出来了，但是在首页或者相应路由加载时还是要加载这样一个几百 kb 的文件，还是不利于性能优化的。这时，我们可以用 CDN 的方式引入这样插件或者 UI 组件库。 在 index.html 引入相应 cdn 链接 12345678910&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcdn.net/ajax/libs/iview/3.5.4/styles/iview.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.8/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/iview/3.5.4/iview.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/xlsx/0.16.8/xlsx.mini.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/xlsx/0.16.8/cpexcel.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; vue.config.js 配置 externals 12345678configureWebpack: (config) =&gt; &#123; config.externals = &#123; vue: &#x27;Vue&#x27;, xlsx: &#x27;XLSX&#x27;, iview: &#x27;iView&#x27;, iView: &#x27;ViewUI&#x27;, &#125;&#125; 删除之前的引入方式并卸载相应 npm 依赖包 1npm uninstall vue iview echarts xlsx --save 此时我们在来看一下打包后的情况 打包出来的 js 文件 well done ! 这时基本没有打包出大文件了，首页加载需要的 vendor.js 也只有几十 kb，而且我们还可以进一步优化，就是把 vue 全家桶的一些模块再通过 cdn 的方法引入，比如 vue-router，vuex，axios 等。这时页面特别是首页加载的性能就得到大大地优化了。","categories":[],"tags":[]},{"title":"webpack 插件原理","slug":"webpack插件原理分析","date":"2022-04-24T01:46:49.511Z","updated":"2022-04-24T01:59:32.130Z","comments":true,"path":"2022/04/24/webpack插件原理分析/","link":"","permalink":"https://data-cz.github.io/2022/04/24/webpack%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"webpack 插件原理在 webpack 中，专注于处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。它和 loader 有以下区别： loader 是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。webpack 自身只支持 js 和 json 这两种格式的文件，对于其他文件需要通过 loader 将其转换为 commonJS 规范的文件后，webpack 才能解析到。 plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。","text":"webpack 插件原理在 webpack 中，专注于处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。它和 loader 有以下区别： loader 是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。webpack 自身只支持 js 和 json 这两种格式的文件，对于其他文件需要通过 loader 将其转换为 commonJS 规范的文件后，webpack 才能解析到。 plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。 plugin 的特征 webpack 插件有以下特征 是一个独立的模块。 模块对外暴露一个 js 函数。 函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply 方法。 apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback。 完成自定义子编译流程并处理 complition 对象的内部数据。 如果异步编译插件的话，数据处理完成后执行 callback 回调。 12345678910111213141516171819class HelloPlugin &#123; // 在构造函数中获取用户给该插件传入的配置 constructor(options) &#123;&#125; // Webpack 会调用 HelloPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply(compiler) &#123; // 在emit阶段插入钩子函数，用于特定时机处理额外的逻辑； compiler.hooks.emit.tap(&#x27;HelloPlugin&#x27;, (compilation) =&gt; &#123; // 在功能流程完成后可以调用 webpack 提供的回调函数； &#125;) // 如果事件是异步的，会带两个参数，第二个参数为回调函数， compiler.plugin(&#x27;emit&#x27;, function (compilation, callback) &#123; // 处理完毕后执行 callback 以通知 Webpack // 如果不执行 callback，运行流程将会一直卡在这不往下执行 callback() &#125;) &#125;&#125;module.exports = HelloPlugin webpack 读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例。 初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin (事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。 事件流机制webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 Tapable。 Webpack 的 Tapable 事件流机制保证了插件的有序性，将各个插件串联起来， Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条 webapck 机制中，去改变 webapck 的运作，使得整个系统扩展性良好。 Tapable 也是一个小型的 library，是 Webpack 的一个核心工具。类似于 node 中的 events 库，核心原理就是一个订阅发布模式。作用是提供类似的插件接口。方法如下： 1234567// 广播事件compiler.apply(&#x27;event-name&#x27;, params)compilation.apply(&#x27;event-name&#x27;, params)// 监听事件compiler.plugin(&#x27;event-name&#x27;, function (params) &#123;&#125;)compilation.plugin(&#x27;event-name&#x27;, function (params) &#123;&#125;) 我们来看下 Tapable 1234567891011121314151617181920212223242526function Tapable() &#123; this._plugins = &#123;&#125;&#125;//发布name消息Tapable.prototype.applyPlugins = function applyPlugins(name) &#123; if (!this._plugins[name]) return var args = Array.prototype.slice.call(arguments, 1) var plugins = this._plugins[name] for (var i = 0; i &lt; plugins.length; i++) &#123; plugins[i].apply(this, args) &#125;&#125;// fn订阅name消息Tapable.prototype.plugin = function plugin(name, fn) &#123; if (!this._plugins[name]) &#123; this._plugins[name] = [fn] &#125; else &#123; this._plugins[name].push(fn) &#125;&#125;//给定一个插件数组，对其中的每一个插件调用插件自身的apply方法注册插件Tapable.prototype.apply = function apply() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; arguments[i].apply(this) &#125;&#125; Tapable 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。webpack 中目前有十种 hooks，在 Tapable 源码中可以看到，他们是： 12345678910exports.SyncHook = require(&#x27;./SyncHook&#x27;)exports.SyncBailHook = require(&#x27;./SyncBailHook&#x27;)exports.SyncWaterfallHook = require(&#x27;./SyncWaterfallHook&#x27;)exports.SyncLoopHook = require(&#x27;./SyncLoopHook&#x27;)exports.AsyncParallelHook = require(&#x27;./AsyncParallelHook&#x27;)exports.AsyncParallelBailHook = require(&#x27;./AsyncParallelBailHook&#x27;)exports.AsyncSeriesHook = require(&#x27;./AsyncSeriesHook&#x27;)exports.AsyncSeriesBailHook = require(&#x27;./AsyncSeriesBailHook&#x27;)exports.AsyncSeriesLoopHook = require(&#x27;./AsyncSeriesLoopHook&#x27;)exports.AsyncSeriesWaterfallHook = require(&#x27;./AsyncSeriesWaterfallHook&#x27;) Tapable 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为： tap：可以注册同步钩子和异步钩子。 tapAsync：回调方式注册异步钩子。 tapPromise：Promise 方式注册异步钩子。 webpack 里的几个非常重要的对象，Compiler, Compilation 和 JavascriptParser 都继承了 Tapable 类，它们身上挂着丰富的钩子。 编写一个插件一个 webpack 插件由以下组成： 一个 JavaScript 命名函数。 在插件函数的 prototype 上定义一个 apply 方法。 指定一个绑定到 webpack 自身的事件钩子。 处理 webpack 内部实例的特定数据。 功能完成后调用 webpack 提供的回调。 下面实现一个最简单的插件 123456789101112class WebpackPlugin1 &#123; constructor(options) &#123; this.options = options &#125; apply(compiler) &#123; compiler.hooks.done.tap(&#x27;MYWebpackPlugin&#x27;, () =&gt; &#123; console.log(this.options) &#125;) &#125;&#125;module.exports = WebpackPlugin1 然后在 webpack 的配置中注册使用就行，只需要在 webpack.config.js 里引入并实例化就可以了： 123456789101112const WebpackPlugin1 = require(&#x27;./src/plugin/plugin1&#x27;)module.exports = &#123; entry: &#123; index: path.join(__dirname, &#x27;/src/main.js&#x27;), &#125;, output: &#123; path: path.join(__dirname, &#x27;/dist&#x27;), filename: &#x27;index.js&#x27;, &#125;, plugins: [new WebpackPlugin1(&#123; msg: &#x27;hello world&#x27; &#125;)],&#125; 此时我们执行一下 npm run build 就能看到效果了 Compiler 对象 （负责编译）Compiler 对象包含了当前运行 Webpack 的配置，包括 entry、output、loaders 等配置，这个对象在启动 Webpack 时被实例化，而且是全局唯一的。Plugin 可以通过该对象获取到 Webpack 的配置信息进行处理。 compiler 上暴露的一些常用的钩子： 下面来举个例子 1234567891011121314151617181920class WebpackPlugin2 &#123; constructor(options) &#123; this.options = options &#125; apply(compiler) &#123; compiler.hooks.run.tap(&#x27;run&#x27;, () =&gt; &#123; console.log(&#x27;开始编译...&#x27;) &#125;) compiler.hooks.compile.tap(&#x27;compile&#x27;, () =&gt; &#123; console.log(&#x27;compile&#x27;) &#125;) compiler.hooks.done.tap(&#x27;compilation&#x27;, () =&gt; &#123; console.log(&#x27;compilation&#x27;) &#125;) &#125;&#125;module.exports = WebpackPlugin2 此时我们执行一下 npm run build 就能看到效果了 有一些编译插件中的步骤是异步的，这样就需要额外传入一个 callback 回调函数，并且在插件运行结束时执行这个回调函数 123456789101112131415class WebpackPlugin2 &#123; constructor(options) &#123; this.options = options &#125; apply(compiler) &#123; compiler.hooks.beforeCompile.tapAsync(&#x27;compilation&#x27;, (compilation, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;编译中...&#x27;) cb() &#125;, 1000) &#125;) &#125;&#125;module.exports = WebpackPlugin2 Compilation 对象Compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 Compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。Compilation 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。 简单来说，Compilation 的职责就是构建模块和 Chunk，并利用插件优化构建过程。 Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译，只要文件有改动，compilation 就会被重新创建。 Compilation 上暴露的一些常用的钩子： Compiler 和 Compilation 的区别 Compiler 代表了整个 Webpack 从启动到关闭的生命周期 Compilation 只是代表了一次新的编译，只要文件有改动，compilation 就会被重新创建。 手写插件 1：文件清单在每次 webpack 打包之后，自动产生一个一个 markdown 文件清单，记录打包之后的文件夹 dist 里所有的文件的一些信息。 思路： 通过 compiler.hooks.emit.tapAsync() 来触发生成资源到 output 目录之前的钩子 通过 compilation.assets 获取文件数量 定义 markdown 文件的内容，将文件信息写入 markdown 文件内 给 dist 文件夹里添加一个资源名称为 fileListName 的变量 写入资源的内容和文件大小 执行回调，让 webpack 继续执行 123456789101112131415161718192021222324252627282930313233343536373839class FileListPlugin &#123; constructor(options) &#123; // 获取插件配置项 this.filename = options &amp;&amp; options.filename ? options.filename : &#x27;FILELIST.md&#x27; &#125; apply(compiler) &#123; // 注册 compiler 上的 emit 钩子 compiler.hooks.emit.tapAsync(&#x27;FileListPlugin&#x27;, (compilation, cb) =&gt; &#123; // 通过 compilation.assets 获取文件数量 let len = Object.keys(compilation.assets).length // 添加统计信息 let content = `# $&#123;len&#125; file$&#123;len &gt; 1 ? &#x27;s&#x27; : &#x27;&#x27;&#125; emitted by webpack\\n\\n` // 通过 compilation.assets 获取文件名列表 for (let filename in compilation.assets) &#123; content += `- $&#123;filename&#125;\\n` &#125; // 往 compilation.assets 中添加清单文件 compilation.assets[this.filename] = &#123; // 写入新文件的内容 source: function () &#123; return content &#125;, // 新文件大小（给 webapck 输出展示用） size: function () &#123; return content.length &#125;, &#125; // 执行回调，让 webpack 继续执行 cb() &#125;) &#125;&#125;module.exports = FileListPlugin 手写插件 2：去除注释开发一个插件能够去除打包后代码的注释，这样我们的 bundle.js 将更容易阅读 思路： 通过 compiler.hooks.emit.tap() 来触发生成文件后的钩子 通过 compilation.assets 拿到生产后的文件，然后去遍历各个文件 通过 .source() 获取构建产物的文本，然后用正则去 replace 调注释的代码 更新构建产物对象 执行回调，让 webpack 继续执行 12345678910111213141516171819202122232425262728class RemoveCommentPlugin &#123; constructor(options) &#123; this.options = options &#125; apply(compiler) &#123; // 去除注释正则 const reg = /(&quot;([^\\\\\\&quot;]*(\\\\.)?)*&quot;)|(&#x27;([^\\\\\\&#x27;]*(\\\\.)?)*&#x27;)|(\\/&#123;2,&#125;.*?(\\r|\\n))|(\\/\\*(\\n|.)*?\\*\\/)|(\\/\\*\\*\\*\\*\\*\\*\\/)/g compiler.hooks.emit.tap(&#x27;RemoveComment&#x27;, (compilation) =&gt; &#123; // 遍历构建产物，.assets中包含构建产物的文件名 Object.keys(compilation.assets).forEach((item) =&gt; &#123; // .source()是获取构建产物的文本 let content = compilation.assets[item].source() content = content.replace(reg, function (word) &#123; // 去除注释后的文本 return /^\\/&#123;2,&#125;/.test(word) || /^\\/\\*!/.test(word) || /^\\/\\*&#123;3,&#125;\\//.test(word) ? &#x27;&#x27; : word &#125;) // 更新构建产物对象 compilation.assets[item] = &#123; source: () =&gt; content, size: () =&gt; content.length, &#125; &#125;) &#125;) &#125;&#125;module.exports = RemoveCommentPlugin","categories":[{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/tags/webpack/"}]},{"title":"webpack 优化打包大全","slug":"webpack优化打包大全","date":"2022-04-24T01:46:49.505Z","updated":"2022-04-24T01:59:32.010Z","comments":true,"path":"2022/04/24/webpack优化打包大全/","link":"","permalink":"https://data-cz.github.io/2022/04/24/webpack%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E5%A4%A7%E5%85%A8/","excerpt":"webpack 优化打包大全随着我们的项目项目越做越大，引入的第三方库会越来越多，打包的依赖也越来越多，每次 build 的时间越来越长，打包出来的文件会越来越大。最糟糕的是单页面应用首页白屏时间长，用户体验差。 此时优化 webpack 打包方法不可回避。下面我们来整理一下常用的 webpack 打包优化方法。 我们的目的 减小打包后的文件大小 首页按需引入文件，减少白屏时间 优化 webpack 打包时间","text":"webpack 优化打包大全随着我们的项目项目越做越大，引入的第三方库会越来越多，打包的依赖也越来越多，每次 build 的时间越来越长，打包出来的文件会越来越大。最糟糕的是单页面应用首页白屏时间长，用户体验差。 此时优化 webpack 打包方法不可回避。下面我们来整理一下常用的 webpack 打包优化方法。 我们的目的 减小打包后的文件大小 首页按需引入文件，减少白屏时间 优化 webpack 打包时间 分析 webpack 打包性能瓶颈 首先我们来分析一下 webpack 打包性能瓶颈，找出问题所在，然后才能对症下药。 1、webpack-bundle-analyzer 分析体积 vue-cli3 需要安装依赖 webpack-bundle-analyzer 12345npm install webpack-bundle-analyzer -Dconst &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;);plugins:[ new BundleAnalyzerPlugin(),] vue-cli2 直接在命令行输入 npm run build --report, 构建完成后会在 8888 端口展示大小 2、测量构建时间我们可以通过 speed-measure-webpack-plugin 测量你的 webpack 构建期间各个阶段花费的时间。 步骤一：安装依赖包 1npm install speed-measure-webpack-plugin --save-dev 配置 vue.config.js 123456789// 分析打包时间const SpeedMeasurePlugin = require(&#x27;speed-measure-webpack-plugin&#x27;)const smp = new SpeedMeasurePlugin()// ...module.exports = &#123; configureWebpack: smp.wrap(&#123; plugins: [new BundleAnalyzerPlugin()], &#125;),&#125; 打包构建后会看到以下输出 找出问题所在后我们开始来总结一下优化方法。 1、 按需加载1.1 路由组件按需加载 12345678910const router = [ &#123; path: &#x27;/index&#x27;, component: (resolve) =&gt; require.ensure([], () =&gt; resolve(require(&#x27;@/components/index&#x27;))), &#125;, &#123; path: &#x27;/about&#x27;, component: (resolve) =&gt; require.ensure([], () =&gt; resolve(require(&#x27;@/components/about&#x27;))), &#125;,] 1.2 第三方组件和插件。按需加载需引入第三方组件 12345678// 引入全部组件import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(ElementUI)// 按需引入组件import &#123; Button &#125; from &#x27;element-ui&#x27;Vue.component(Button.name, Button) 1.3 对于一些插件，如果只是在个别组件中用的到，也可以不要在 main.js 里面引入，而是在组件中按需引入 1234567// 在main.js引入import Vue from vueimport Vuelidate from &#x27;vuelidate&#x27;Vue.use(Vuelidate)// 按组件按需引入import &#123; Vuelidate &#125; from &#x27;vuelidate&#x27; 1.4 去除打包后文件的预加载 prefetch&#x2F;preload vuecli 3 默认开启 prefetch(预先加载模块)，提前获取用户未来可能会访问的内容，在首屏会把这十几个路由文件，都一口气下载了。所以我们要关闭这个功能 1234567//细节配置修改chainWebpack: (config) =&gt; &#123; // 移除 prefetch 插件 config.plugins.delete(&#x27;prefetch-index&#x27;) // 移除 preload 插件 config.plugins.delete(&#x27;preload-index&#x27;)&#125; preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源 prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源 当 prefetch 插件被禁用时，你可以通过 webpack 的内联注释手动选定要提前获取的代码区块： 1import(/* webpackPrefetch: true */ &#x27;./someAsyncComponent.vue&#x27;) 2、缩小构建目标优化 loader 配置排除 Webpack 不需要解析的模块，即使用 loader 的时候，在尽量少的模块中去使用。 优化正则匹配 通过 cacheDirectory 选项开启缓存 通过 include、exclude 来减少被处理的文件。 123456789module: &#123; rules: [ &#123; test: /\\.js$/, loader: &#x27;babel-loader?cacheDirectory&#x27;, include: [resolve(&#x27;src&#x27;)], &#125;, ]&#125; 注意：保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。 合理使用 resolve.extensions在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 resolve.extensions 顺序从前到后查找，Webpack 默认支持的后缀是 js 与 json。 配置别名 aliasalias 的意思为 别名，能把原导入路径映射成一个新的导入路径，我们可以使用 alias 配置来减少查找过程。 1234567resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;, &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#125;&#125;, 使用 module.noParse:让 webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 因为如 jQuery 、echart 等库庞大又没有采用模块化标准，让 webpack 去解析这些文件耗时又没有意义。 1234module:&#123; noParse:/jquery/,//不去解析jquery中的依赖库 ...&#125;, 4、生产环境关闭 sourceMapsourceMap 本质上是一种映射关系，打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。在生产环境，打包速度减慢，生产文件变大，所以开发环境使用 sourceMap，生产环境则关闭。 sourceMap 的种类 source-map: 会生成 map 格式的文件，里面包含映射关系的代码 inline-source-map: 不会生成 map 格式的文件，包含映射关系的代码会放在打包后生成的代码中 inline-cheap-source-map: 一是将错误只定位到行，不定位到列。二是映射业务代码，不映射 loader 和第三方库等。会提升打包构建的速度。 inline-cheap-module-source-map: module 会映射 loader 和第三方库 eval: 用 eval 的方式生成映射关系代码，效率和性能最佳。但是当代码复杂时，提示信息可能不精确。 5、代码压缩UglifyJSUglifyJS 是 vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢。 12345678910plugins: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: true, parallel: true &#125;) ParallelUglifyPluginParallelUglifyPlugin 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 12345678910111213141516plugins: [ new ParallelUglifyPlugin(&#123; //缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回， //cacheDir 用于配置缓存存放的目录路径。 cacheDir: &#x27;.cache/&#x27;, sourceMap: true, uglifyJS: &#123; output: &#123; comments: false, &#125;, compress: &#123; warnings: false, &#125;, &#125;, &#125;),] 打包速度和打包后的文件大小啊对比 方法 文件大小 打包速度 不用插件 14.6M 32s UglifyJsPlugin 12.9M 33s ParallelUglifyPlugi 7.98M 17s terser-webpack-pluginWebpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。 123456789101112const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;) // 压缩js代码const OptimizeCSSAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;) // 压缩css代码optimization: &#123; minimizer: [ new TerserPlugin(&#123; parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1 cache: true, // 是否缓存 sourceMap: false, &#125;), ]&#125; CSS 压缩我们可以借助 optimize-css-assets-webpack-plugin 插件来压缩 css，其默认使用的压缩引擎是 cssnano 12345678const OptimizeCSSAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;) // 压缩css代码optimization: &#123; minimizer: [ // 压缩css new OptimizeCSSAssetsPlugin(&#123;&#125;), ]&#125; 6、提取公共代码在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 react，lodash，vue 我们希望能和自己的代码分离开，webpack 社区有以下两种方案： CommonsChunkPlugin 及 splitChunks通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。 webpack3 使用 CommonsChunkPlugin 的实现： 12345678910111213141516171819plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, minChunks: function (module, count) &#123; console.log(module.resource, `引用次数$&#123;count&#125;`) //&quot;有正在处理文件&quot; + &quot;这个文件是 .js 后缀&quot; + &quot;这个文件是在 node_modules 中&quot; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(path.join(__dirname, &#x27;./node_modules&#x27;)) === 0 ) &#125;, &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;common&#x27;, chunks: &#x27;initial&#x27;, minChunks: 2, &#125;),] webpack4 使用 splitChunks 的实现： 12345678910111213141516171819module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; priority: 1, //添加权重 test: /node_modules/, //把这个目录下符合下面几个条件的库抽离出来 chunks: &#x27;initial&#x27;, //刚开始就要抽离 minChunks: 2, //重复2次使用的时候需要抽离出来 &#125;, common: &#123; //公共的模块 chunks: &#x27;initial&#x27;, minChunks: 2, &#125;, &#125;, &#125;, &#125;,&#125; DLLPluginwebpack.DllPlugin 就是来解决这个问题的插件，使用它可以在第一次编译打包后就生成一份不变的代码供其他模块引用，这样下一次构建的时候就可以节省开发时编译打包的时间。 1、在 build 下创建 webpack.dll.config.js 123456789101112131415161718192021222324252627282930313233const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; entry: &#123; vendor: [ &#x27;vue-router&#x27;, &#x27;vuex&#x27;, &#x27;vue/dist/vue.common.js&#x27;, &#x27;vue/dist/vue.js&#x27;, &#x27;vue-loader/lib/component-normalizer.js&#x27;, &#x27;vue&#x27;, &#x27;axios&#x27;, &#x27;echarts&#x27;, ], &#125;, output: &#123; path: path.resolve(&#x27;./dist&#x27;), filename: &#x27;[name].dll.js&#x27;, library: &#x27;[name]_library&#x27;, &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.resolve(&#x27;./dist&#x27;, &#x27;[name]-manifest.json&#x27;), name: &#x27;[name]_library&#x27;, &#125;), // 建议加上代码压缩插件，否则dll包会比较大。 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125;, &#125;), ],&#125; library 的意思其实就是将 dll 文件以一个全局变量的形式导出出去，便于接下来引用。 mainfest.json 文件是一个映射关系，它的作用就是帮助 webpack 使用我们之前打包好的 ***.dll.js 文件，而不是重新再去 node_modules 中去寻找。 2、在 webpack.prod.conf.js 的 plugin 后面加入配置 123new webpack.DllReferencePlugin(&#123; manifest: require(&#x27;../dist/vendor-manifest.json&#x27;),&#125;) 3、package.json文件中添加快捷命令(build:dll) 1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;build:dll&quot;: &quot;webpack --config build/webpack.dll.conf.js&quot;&#125; 生产环境打包的时候先npm run build:dll命令会在打包目录下生成 vendor-manifest.json 文件与 vendor.dll.js 文件。然后npm run build生产其他文件。 4、根目录下的入口 index.html 加入引用 1&lt;script type=&quot;text/javascript&quot; src=&quot;./vendor.dll.js&quot;&gt;&lt;/script&gt; 7、CDN 优化 随着项目越做越大，依赖的第三方 npm 包越来越多，构建之后的文件也会越来越大。 再加上又是单页应用，这就会导致在网速较慢或者服务器带宽有限的情况出现长时间的白屏。 1、将 vue、vue-router、vuex、element-ui 和 axios 这五个库，全部改为通过 CDN 链接获取，在 index.html 里插入 相应链接。 123456789101112&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/element-ui/2.0.7/theme-chalk/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.6.1/index.js&quot;&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt; 2、在 webpack.config.js 配置文件 12345678910module.exports = &#123; ··· externals: &#123; &#x27;vue&#x27;: &#x27;Vue&#x27;, &#x27;vuex&#x27;: &#x27;Vuex&#x27;, &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;, &#x27;element-ui&#x27;: &#x27;ELEMENT&#x27;, &#x27;Axios&#x27;:&#x27;axios&#x27; &#125; &#125;, 3、卸载依赖的 npm 包 1npm uninstall axios element-ui vue vue-router vuex 4、修改 main.js 文件里之前的引包方式 12345678910111213141516171819202122// import Vue from &#x27;vue&#x27;// import ElementUI from &#x27;element-ui&#x27;// import &#x27;element-ui/lib/theme-chalk/index.css&#x27;// import VueRouter from &#x27;vue-router&#x27;import App from &#x27;./App.vue&#x27;import routes from &#x27;./router&#x27;import utils from &#x27;./utils/Utils&#x27;Vue.use(ELEMENT)Vue.use(VueRouter)const router = new VueRouter(&#123; mode: &#x27;hash&#x27;, //路由的模式 routes,&#125;)new Vue(&#123; router, el: &#x27;#app&#x27;, render: (h) =&gt; h(App),&#125;) html-webpack-externals-plugin这种方法每次都需要在 index.html 模板中手动引入需要的 cdn 文件，然后还要在 webpack 里配置，有点繁琐了html-webpack-externals-plugin这样的插件就应运而生了。 123456789101112131415161718192021222324// webpack.config.js文件const HtmlWebpackExternalsPlugin = require(&#x27;html-webpack-externals-plugin&#x27;)module.exports = &#123; plugins: [ new HtmlWebpackExternalsPlugin(&#123; externals: [ &#123; // 引入的模块 module: &#x27;jquery&#x27;, // cdn的地址 entry: &#x27;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&#x27;, // 挂载到了window上的名称 global: &#x27;jQuery&#x27;, &#125;, &#123; module: &#x27;vue&#x27;, entry: &#x27;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&#x27;, global: &#x27;Vue&#x27;, &#125;, ], &#125;), ],&#125; 8、多进程解析和处理文件由于运行在 Node.js 之上的 webpack 是单线程模型的，所以 webpack 需要处理的事情需要一件一件的做，不能多件事一起做。当 webpack 需要打包大量文件时，打包时间就会比较漫长。 以下两个方法能让 webpack 在同一时刻处理多个任务发挥多核 CPU 电脑的功能，提升构建速度。 thread loader把这个 thread loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。 在 worker 池(worker pool)中运行的 loader 是受到限制的。例如： 这些 loader 不能产生新的文件。 这些 loader 不能使用定制的 loader API（也就是说，通过插件）。 这些 loader 无法获取 webpack 的选项设置。 每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。 1234567891011module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, include: path.resolve(&#x27;src&#x27;), use: [&#x27;thread-loader&#x27;, &#x27;expensive-loader&#x27;], &#125;, ], &#125;,&#125; HappyPackHappyPack 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 HappyPack 对 file-loader、url-loader 支持的不友好，所以不建议对该 loader 使用。 使用方法如下： 1、 HappyPack 插件安装 1npm i -D happypack 2、 webpack.base.conf.js 文件对 module.rules 进行配置 1234567891011121314module: &#123; rules: [ &#123; test: /\\.js$/, use: [&#x27;happypack/loader?id=babel&#x27;], include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)], exclude: path.resolve(__dirname, &#x27;node_modules&#x27;), &#125;, &#123; test: /\\.vue$/, use: [&#x27;happypack/loader?id=vue&#x27;], &#125;, ]&#125; 3、在生产环境 webpack.prod.conf.js 文件进行配置 12345678910111213141516171819202122const HappyPack = require(&#x27;happypack&#x27;)// 构造出共享进程池，在进程池中包含5个子进程const HappyPackThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;)plugins: [ new HappyPack(&#123; // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件 id: &#x27;babel&#x27;, // 如何处理.js文件，用法和Loader配置中一样 loaders: [&#x27;babel-loader?cacheDirectory&#x27;], threadPool: HappyPackThreadPool, &#125;), new HappyPack(&#123; id: &#x27;vue&#x27;, // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件 loaders: [ &#123; loader: &#x27;vue-loader&#x27;, options: vueLoaderConfig, &#125;, ], threadPool: HappyPackThreadPool, &#125;),] 注意，当项目较小时，多线程打包反而会使打包速度变慢。 启用 gzip 压缩使用 Gzip 两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。 1、安装依赖 1npm i compression-webpack-plugin --save 2、在 vue.congig.js 中引入并修改 webpack 配置 12345678910111213141516const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)module.exports = &#123; configureWebpack: (config) =&gt; &#123; if (progress.env.NODE_ENV === &#x27;production&#x27;) &#123; return &#123; plugins: [ new CompressionPlugin(&#123; test: /\\.js$|\\.html$|.\\css/, //匹配文件名 threshold: 10240, //对超过10k的数据压缩 deleteOriginalAssets: false, //不删除源文件 &#125;), ], &#125; &#125; &#125;,&#125; 总结 比较实用的方法: 按需加载，优化 loader 配置，关闭生产环境的 sourceMap，CDN 优化。 vue-cli 已做的优化： 代码压缩，提取公共代码，再优化空间不大。 根据项目实际需要和自身开发水平选择优化方法，必须避免因为优化产生 bug。","categories":[],"tags":[]},{"title":"Vue 应用","slug":"总结vue知识体系之高级应用篇","date":"2022-04-24T01:45:19.126Z","updated":"2022-04-24T01:59:31.946Z","comments":true,"path":"2022/04/24/总结vue知识体系之高级应用篇/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E7%AF%87/","excerpt":"","text":"Vue.use我们使用的第三方 Vue.js 插件。如果插件是一个对象，必须提供install方法。如果插件是一个函数，它会被作为install方法。install方法调用时，会将Vue作为参数传入。该方法需要在调用new Vue()之前被调用。 我们在使用插件或者第三方组件库的时候用到Vue.use这个方法，比如 12import iView from &#x27;iview&#x27;Vue.use(iView) 那么Vue.use到底做了些什么事情呢？我们先来看一下源码 123456789101112131415161718192021import &#123; toArray &#125; from &#x27;../util/index&#x27;export function initUse(Vue: GlobalAPI) &#123; Vue.use = function(plugin: Function | Object) &#123; const installedPlugins = this._installedPlugins || (this._installedPlugins = []) if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this &#125; // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === &#x27;function&#x27;) &#123; plugin.install.apply(plugin, args) &#125; else if (typeof plugin === &#x27;function&#x27;) &#123; plugin.apply(null, args) &#125; installedPlugins.push(plugin) return this &#125;&#125; 我们由以上可以看出，plugin参数为函数或者对象类型，首先Vue会去寻找这个插件在已安装的插件列表里有没有，如果没有，则进行安装插件，如果有则跳出函数，这保证插件只被安装一次。 接着通过toArray方法将参数变成数组，再判断plugin的install属性是否为函数，或者plugin本身就是函数，最后执行plugin.install或者plugin的方法。 举个例子下面我们来举个实际例子1、编写两个插件 1234567891011const Plugin1 = &#123; install(a) &#123; console.log(a) &#125;&#125;function Plugin2(b) &#123; console.log(b)&#125;export &#123; Plugin1, Plugin2 &#125; 2、引入并 use 这两个插件 12345import Vue from &#x27;vue&#x27;import &#123; Plugin1, Plugin2 &#125; from &#x27;./plugins&#x27;Vue.use(Plugin1, &#x27;参数1&#x27;)Vue.use(Plugin2, &#x27;参数2&#x27;) 此时我们运行项目代码就可以用到上面两个插件了。 Vue.mixin混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 1、定义一个 mixin.js 123456789101112131415161718192021export default mixin &#123; data() &#123; return &#123; name: &#x27;mixin&#x27; &#125; &#125;, created() &#123; console.log(&#x27;mixin...&#x27;, this.name); &#125;, mounted() &#123;&#125;, methods: &#123; //日期转换 formatDate (dateTime, fmt = &#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#123; if (!dateTime) &#123; return &#x27;&#x27; &#125; moment.locale(&#x27;zh-CN&#x27;) dateTime = moment(dateTime).format(fmt) return dateTime &#125; &#125;&#125; 2、在vue文件中使用mixin 12345678910import &#x27;@/mixin&#x27;; // 引入mixin文件export default &#123; mixins: [mixin], //用法 data() &#123; return &#123; userName: &quot;adimin&quot;, time: this.formatDate(new Date()) //这个vue文件的数据源data里面的time就是引用混入进来的方法 &#125; &#125;&#125; 或者在全局中使用在main.js中，所有页面都能使用了 12import mixin from &#x27;./mixin&#x27;Vue.mixin(mixin) 合并选项当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。 data对象在内部会进行递归合并，并在发生冲突时以组件数据优先。 同名钩子函数将合并为一个数组，因此都将被调用。混入对象的钩子将在组件自身钩子之前调用。 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 Vue.extendVue.extend 属于 Vue 的全局 API。它使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。如下： 12345678910111213&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;var Profile = Vue.extend(&#123; template: &#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/p&gt;&#x27;, data: function () &#123; return &#123; firstName: &#x27;Walter&#x27;, lastName: &#x27;White&#x27; &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount(&#x27;#app&#x27;) 应用实例我们常用 Vue.extend 封装一些全局插件，比如 toast， diolog 等。 下面以封装一个 toast 组件为例。 1、编写组件 根据传入的 type 确定弹窗的类型（成功提示，失败提示，警告，加载，纯文字） 设置弹窗消失的时间123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div class=&quot;little-tip&quot; v-show=&quot;showTip&quot;&gt; &lt;img src=&quot;/success.png&quot; alt=&quot;&quot; width=&quot;36&quot; v-if=&quot;type==&#x27;success&#x27;&quot; /&gt; &lt;img src=&quot;/fail.png&quot; alt=&quot;&quot; width=&quot;36&quot; v-if=&quot;type==&#x27;fail&#x27;&quot; /&gt; &lt;img src=&quot;/warning.png&quot; alt=&quot;&quot; width=&quot;36&quot; v-if=&quot;type==&#x27;warning&#x27;&quot; /&gt; &lt;img src=&quot;/loading.png&quot; alt=&quot;&quot; width=&quot;36&quot; v-if=&quot;type==&#x27;loading&#x27;&quot; class=&quot;loading&quot; /&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; showTip: true, msg: &#x27;&#x27;, type: &#x27;&#x27; &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.showTip = false &#125;, 1500) &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt; /* 样式略 */&lt;/style&gt; 2、利用 Vue.extend 构造器把 toast 组件挂载到 vue 实例下 12345678910111213141516import Vue from &#x27;vue&#x27;import Main from &#x27;./toast.vue&#x27;let Toast = Vue.extend(Main)let instanceconst toast = function(options) &#123; options = options || &#123;&#125; instance = new Toast(&#123; data: options &#125;) instance.vm = instance.$mount() document.body.appendChild(instance.vm.$el) return instance.vm&#125;export default toast 3、在 main.js 引入 toast 组价并挂载在 vue 原型上 123import Vue from &#x27;vue&#x27;import toast from &#x27;./components/toast&#x27;Vue.prototype.$toast = toast 4、在项目中调用 123456this.$toast(&#123; msg: &#x27;手机号码不能为空&#x27; &#125;)this.$toast(&#123; msg: &#x27;成功提示&#x27;, type: &#x27;success&#x27;&#125;) Vue.extend 和 Vue.component 的区别 component是需要先进行组件注册后，然后在 template 中使用注册的标签名来实现组件的使用。Vue.extend 则是编程式的写法。 控制component的显示与否，需要在父组件中传入一个状态来控制或者在组件外部用 v-if/v-show 来实现控制，而 Vue.extend 的显示与否是手动的去做组件的挂载和销毁。 Vue.directive注册或获取全局指令。指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 应用实例下面封装一个复制粘贴文本的例子。 1、编写指令 copy.js 1234567891011121314151617181920212223242526272829303132333435363738394041const vCopy = &#123; bind (el, &#123; value &#125;) &#123; el.$value = value // 用一个全局属性来存传进来的值 el.handler = () =&gt; &#123; if (!el.$value) &#123; alert(&#x27;无复制内容&#x27;) return &#125; // 动态创建 textarea 标签 const textarea = document.createElement(&#x27;textarea&#x27;) // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = &#x27;readonly&#x27; textarea.style.position = &#x27;absolute&#x27; textarea.style.left = &#x27;-9999px&#x27; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value // 将 textarea 插入到 body 中 document.body.appendChild(textarea) // 选中值并复制 textarea.select() // textarea.setSelectionRange(0, textarea.value.length); const result = document.execCommand(&#x27;Copy&#x27;) if (result) &#123; alert(&#x27;复制成功&#x27;) &#125; document.body.removeChild(textarea) &#125; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener(&#x27;click&#x27;, el.handler) &#125;, // 当传进来的值更新的时候触发 componentUpdated (el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind (el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;&#125;export default vCopy 2、注册指令 12345678910111213import copy from &#x27;./copy&#x27;// 自定义指令const directives = &#123; copy&#125;// 这种写法可以批量注册指令export default &#123; install (Vue) &#123; Object.keys(directives).forEach((key) =&gt; &#123; Vue.directive(key, directives[key]) &#125;) &#125;&#125; 3、在 main.js 引入并 use 123import Vue from &#x27;vue&#x27;import Directives from &#x27;./JS/directives&#x27;Vue.use(Directives) 这样就可以在项目直接用 vCopy 指令了。","categories":[],"tags":[]},{"title":"","slug":"总结vue知识体系之实用技巧","date":"2022-04-24T01:45:19.122Z","updated":"2022-04-24T01:59:32.023Z","comments":true,"path":"2022/04/24/总结vue知识体系之实用技巧/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"title: Vue 监听组件的生命周期date: 2019&#x2F;3&#x2F;26 hh:mm:ss # 时间 监听组件的生命周期比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，常规的写法可能如下： 1234567 // Parent.vue&lt;Child @mounted=&quot;doSomething&quot;/&gt;// Child.vuemounted() &#123; this.$emit(&quot;mounted&quot;);&#125; 此外，还有一种特别简单的方式，子组件不需要任何处理，只需要在父组件引用的时候通过@hook 来监听即可，代码如下： 1&lt;Child @hook:mounted=&quot;doSomething&quot; /&gt; &lt;Child @hook:updated=&quot;doSomething&quot; /&gt; 当然这里不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以。 watch 的初始立即执行观察和响应 Vue 实例上的数据变动。类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。 但是当 watch 一个变量的时候，初始化时并不会执行，如下面的例子，你需要在 created 的时候手动调用一次。 123456created() &#123; this.getList();&#125;,watch: &#123; keyWord: &#x27;getList&#x27;,&#125; 上面这样的做法可以使用，但很麻烦，我们可以添加 immediate 属性，这样初始化的时候就会自动触发(不用再写 created 去调用了)，然后上面的代码就能简化为： 123456watch: &#123; keyWord: &#123; handler: &#x27;getList&#x27;, immediate: true &#125;&#125; watch 有三个参数 handler：其值是一个回调函数。即监听到变化时应该执行的函数 deep：其值是 true 或 false；确认是否深入监听。 immediate：其值是 true 或 false，确认是否以当前的初始值执行 handler 的函数 路由参数变化组件不更新同一path的页面跳转时路由参数变化，但是组件没有对应的更新。 原因：主要是因为获取参数写在了created或者mounted路由钩子函数中，路由参数变化的时候，这个生命周期不会重新执行。 解决方案 1：watch监听路由 12345678910111213141516watch: &#123; // 方法1 //监听路由是否变化 &#x27;$route&#x27; (to, from) &#123; if(to.query.id !== from.query.id)&#123; this.id = to.query.id; this.init();//重新加载数据 &#125; &#125;&#125;//方法 2 设置路径变化时的处理函数watch: &#123;&#x27;$route&#x27;: &#123; handler: &#x27;init&#x27;, immediate: true &#125;&#125; 解决方案 2 ：为了实现这样的效果可以给router-view添加一个不同的key，这样即使是公用组件，只要 url 变化了，就一定会重新创建这个组件。 1&lt;router-view :key=&quot;$route.fullpath&quot;&gt;&lt;/router-view&gt; 路由懒加载Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式： 12345678910111213141516// 1、Vue异步组件技术： &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: resolve =&gt; reqire([&#x27;path路径&#x27;], resolve) &#125;// 2、es6提案的import() const Home = () =&gt; import(&#x27;path路径&#x27;)// 3、webpack提供的require.ensure() &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: r =&gt; require.ensure([],() =&gt; r(require(&#x27;path路径&#x27;)), &#x27;demo&#x27;) &#125; require.context()require.context(directory,useSubdirectories,regExp) directory：说明需要检索的目录 useSubdirectories：是否检索子目录 regExp: 匹配文件的正则表达式,一般是文件名 场景:如页面需要导入多个组件,原始写法: 123456import titleCom from &#x27;@/components/home/titleCom&#x27;import bannerCom from &#x27;@/components/home/bannerCom&#x27;import cellCom from &#x27;@/components/home/cellCom&#x27;components: &#123; titleCom, bannerCom, cellCom&#125; 这样就写了大量重复的代码,利用 require.context 可以写成 12345678const path = require(&#x27;path&#x27;)const files = require.context(&#x27;@/components/home&#x27;, false, /\\.vue$/)const modules = &#123;&#125;files.keys().forEach((key) =&gt; &#123; const name = path.basename(key, &#x27;.vue&#x27;) modules[name] = files(key).default || files(key)&#125;)components: modules 递归组件 递归组件: 组件在它的模板内可以递归的调用自己，只要给组件设置 name 组件就可以了。 不过需要注意的是，必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded 组件递归用来开发一些具体有未知层级关系的独立组件。比如：联级选择器和树形控件 123456789101112131415161718192021&lt;template&gt; &lt;div v-for=&quot;(item,index) in treeArr&quot;&gt; &#123;&#123;index&#125;&#125; &lt;br/&gt; &lt;tree :item=&quot;item.arr&quot; v-if=&quot;item.flag&quot;&gt;&lt;/tree&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 必须定义name，组件内部才能递归调用 name: &#x27;tree&#x27;, data()&#123; return &#123;&#125; &#125;, // 接收外部传入的值 props: &#123; item: &#123; type:Array, default: ()=&gt;[] &#125; &#125;&#125;&lt;/script&gt; 清除定时器或者事件监听由于项目中有些页面难免会碰到需要定时器或者事件监听。但是在离开当前页面的时候，定时器如果不及时合理地清除，会造成业务逻辑混乱甚至应用卡死的情况，这个时就需要清除定时器事件监听，即在页面卸载（关闭）的生命周期函数里，清除定时器。 1234567891011121314151617181920methods:&#123; resizeFun () &#123; this.tableHeight = window.innerHeight - document.getElementById(&#x27;table&#x27;).offsetTop - 128 &#125;, setTimer() &#123; this.timer = setInterval(() =&gt; &#123; &#125;) &#125;, clearTimer() &#123;//清除定时器 clearInterval(this.timer) this.timer = null &#125;&#125;,mounted() &#123; this.setTimer() window.addEventListener(&#x27;resize&#x27;, this.resizeFun)&#125;,beforeDestroy() &#123; window.removeEventListener(&#x27;resize&#x27;, this.resizeFun) this.clearTimer()&#125; 自定义路径别名我们也可以在基础配置文件中添加自己的路径别名 12345678resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;, &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#x27;assets&#x27;: resolve(&#x27;src/assets&#x27;) &#125; &#125; 然后我们导入组件的时候就可以这样写： 12// import YourComponent from &#x27;/src/assets/YourComponent&#x27;import YourComponent from &#x27;assets/YourComponent&#x27; 这样既解决了路径过长的麻烦，又解决了相对路径的烦恼。 动态给修改 dom 的样式原因：因为我们在写.vue 文件中的样式都会追加 scoped。这样针对模板 dom 中的样式就可以生效，但其生效后的最终样式并不是我们写的样式名，而是编码后的。比如： 12345678&lt;template&gt; &lt;div class=&quot;box&quot;&gt;dom&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt; .box &#123; background: red; &#125;&lt;/style&gt; vue 将代码转译成如下，所以我们在 js 中拼接上的 dom 结构样式并不会生效。 1234.box[data-v-11c6864c]&#123; background:red; &#125;&lt;template&gt; &lt;div class=&quot;box&quot; data-v-11c6864c&gt;dom&lt;/div&gt;&lt;/template&gt; 解决方法：将要改变的样式写在非 scoped 样式标签中。 长列表性能优化我们应该都知道 vue 会通过 object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间。 所以，我们可以通过 object.freeze 方法来冻结一个对象，这个对象一旦被冻结，vue 就不会对数据进行劫持了。 123456789101112export default &#123; data: () =&gt; (&#123; list: [], &#125;), async created() &#123; const list = await axios.get(&#x27;xxxx&#x27;) this.list = Object.freeze(list) &#125;, methods: &#123; // 此处做的操作都不能改变list的值 &#125;,&#125; 另外需要说明的是，这里只是冻结了 list 的值，引用不会被冻结，当我们需要 reactive 数据的时候，我们可以重新给 list 赋值。 内容分发(slot)插槽 slot，也是组件的一块 HTML 模板，这一块模板显示不显示、以及怎样显示由父组件来决定。实际上，一个 slot 最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。 默认插槽又名单个插槽、匿名插槽，这类插槽没有具体名字，一个组件只能有一个该类插槽。 12345678910111213141516171819&lt;!-- 父组件 parent.vue --&gt;&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h1&gt;父容器&lt;/h1&gt; &lt;child&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 子组件 child.vue --&gt;&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h1&gt;子组件&lt;/h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽匿名插槽没有 name 属性，所以叫匿名插槽。那么，插槽加了 name 属性，就变成了具名插槽。具名插槽可以在一个组件中出现 N 次，出现在不同的位置，只需要使用不同的 name 属性区分即可。 123456789101112131415161718192021222324252627282930&lt;!-- 父组件 parent.vue --&gt;&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h1&gt;父容器&lt;/h1&gt; &lt;child&gt; &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt; &lt;span&gt;菜单up-1&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt; &lt;span&gt;菜单down-1&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单-&gt;1&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 子组件 child.vue --&gt;&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;!-- 具名插槽 --&gt; &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;!-- 具名插槽 --&gt; &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt; &lt;!-- 匿名插槽 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽作用域插槽可以是默认插槽，也可以是具名插槽，不一样的地方是，作用域插槽可以为 slot 标签绑定数据，让其父组件可以获取到子组件的数据。 12345678910111213141516171819202122232425262728293031&lt;!-- parent.vue --&gt;&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &lt;child &gt;&gt; &lt;template slot=&quot;default&quot; slot-scope=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.name &#125;&#125; &lt;/template&gt; &lt;/child &gt;&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 子组件 child.vue --&gt;&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;slot :user=&quot;user&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; user: &#123; name: &#x27;小赵&#x27;, &#125;, &#125; &#125;, &#125;&lt;/script&gt;","categories":[],"tags":[]},{"title":"Vue 的优缺点是什么","slug":"总结vue知识体系之基础入门篇","date":"2022-04-24T01:45:19.118Z","updated":"2022-04-24T01:59:31.553Z","comments":true,"path":"2022/04/24/总结vue知识体系之基础入门篇/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/","excerpt":"","text":"Vue 的优缺点是什么优点： 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom，这样大大加快了访问速度和提升用户体验。而且他的第三方 ui 库很多节省开发时间 缺点：不利于 SEO，社区维护力度不强，相比还不够成熟 vue 常用指令 v-html / v-text：把值中的标签渲染出来 v-model： 放在表单元素上的，实现双向数据绑定 v-bind（缩写 :）：用于绑定行内属性 v-if / v-show 是否能显示，true 能显示，false 不能显示 v-cloak：需要配合 css 使用：解决小胡子显示问题 v-once 对应的标签只渲染一次 v-for ：循环显示元素 v-on 事件绑定 事件修饰符Vue.js 为 v-on 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的。 stop：阻止事件继续传播 prevent：阻止事件默认行为 capture：添加事件监听器时使用事件捕获模式 self：当前元素触发时才触发事件处理函数 once：事件只触发一次 passive：告诉浏览器你不想阻止事件的默认行为，不能和.prevent 一起使用。 123456789101112131415161718192021222324&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;toDo&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;toSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;toDo&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;toDo&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;div v-on:click.self=&quot;toDo&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=&quot;toDo&quot;&gt;&lt;/a&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt; 表单修饰符 .lazy 在输入框输入完内容，光标离开时才更新视图 .trim 过滤首尾空格 .number 如果先输入数字，那它就会限制你输入的只能是数字;如果先输入字符串，那就相当于没有加.number 过滤器 filter过滤器是对即将显示的数据做进一步的筛选处理，然后进行显示，值得注意的是过滤器并没有改变原来的数据，只是在原数据的基础上产生新的数据。 定义过滤器全局注册 123Vue.filter(&#x27;myFilter&#x27;, function (value1[,value2,...] ) &#123;// 代码逻辑&#125;) 局部注册 1234567new Vue(&#123; filters: &#123; &#x27;myFilter&#x27;: function (value1[,value2,...] ) &#123; // 代码逻辑 &#125; &#125; &#125;) 使用过滤器 12345&lt;!-- 在双花括号中 --&gt;&lt;div&gt;&#123;&#123; message | myFilter &#125;&#125;&lt;/div&gt;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;message | myFilter&quot;&gt;&lt;/div&gt; 计算属性 computed依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； 1234567891011121314151617181920&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: &#123; message: &#x27;Hello&#x27; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function() &#123; // `this` 指向 vm 实例 return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125; &#125;)&lt;/script&gt; 监听属性 watch观察和响应 Vue 实例上的数据变动。类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。它可以有三个参数 handler：其值是一个回调函数。即监听到变化时应该执行的函数 deep：其值是 true 或 false；确认是否深入监听。 immediate：其值是 true 或 false，确认是否以当前的初始值执行 handler 的函数 123456789watch:&#123; message:&#123; handler:function(val, oldVal)&#123; console.log(val, oldVal) &#125;, deep: true, immediate: true &#125;&#125; computed 和 watch 的区别 computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。 运用场景 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 生命周期函数 beforeCreate(创建前) vue 实例的挂载元素$el 和数据对象 data 都是 undefined, 还未初始化 created(创建后) 完成了 data 数据初始化, el 还未初始化 beforeMount(载入前) vue 实例的$el 和 data 都初始化了, 相关的 render 函数首次被调用 mounted(载入后) 此过程中进行 ajax 交互 beforeUpdate(更新前) updated(更新后) beforeDestroy(销毁前) destroyed(销毁后) Vue 的父组件和子组件生命周期钩子执行顺序是什么? 渲染过程：父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的 mounted 在子组件 mouted 之后。 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程： 影响到父组件：父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted 不影响父组件：子 beforeUpdate -&gt; 子 updated 父组件更新过程： 影响到子组件：父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted 不影响子组件：父 beforeUpdate -&gt; 父 updated 销毁过程： 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 组件注册组件（component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件的使用过程包括定义和注册的过程。 定义组件 12345// 方法一 Vue.extendvar MyComponent = Vue.extend(&#123; template: &#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27;&#125;)// 方法二：新建一个.vue 文件 注册组件 12345678910// 全局注册Vue.component(&#x27;my-component&#x27;, MyComponent)// 局部注册new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; &#x27;my-component&#x27;: MyComponent &#125;&#125;) 使用组件 123&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 组件传值1. props 父组件给子组件传值props 值可以是一个数组或对象; 1234567891011121314151617// 数组:不建议使用props:[]// 对象props:&#123; inpVal:&#123; type:Number, //传入值限定类型 // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认 required: true, //是否必传 default:200, //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[] validator:(value) &#123; // 这个值必须匹配下列字符串中的一个 return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1 &#125; &#125;&#125; 2. $emit 子组件给父组件传值触发子组件触发父组件给自己绑定的事件,其实就是子传父的方法 1234// 父组件&lt;v-Header @title=&quot;title&quot;&gt;// 子组件this.$emit(&#x27;title&#x27;,&#123;title: &#x27;这是title&#x27;&#125;) 3. vuex 数据状态管理 state:定义存贮数据的仓库 ,可通过 this.$store.state 或 mapState 访问 getter:获取 store 值,可认为是 store 的计算属性,可通过 this.$store.getter 或 mapGetters 访问 mutation:同步改变 store 值,可通过 mapMutations 调用 action:异步调用函数执行 mutation,进而改变 store 值,可通过 this.$dispatch 或 mapActions 访问 modules:模块,如果状态过多,可以拆分成模块,最后在入口通过…解构引入 4. attrs 和 listenersattrs 获取子传父中未在 props 定义的值 1234567891011121314151617// 父组件&lt;home title=&quot;这是标题&quot; width=&quot;80&quot; height=&quot;80&quot; imgUrl=&quot;imgUrl&quot;/&gt;// 子组件mounted() &#123; console.log(this.$attrs) //&#123;title: &quot;这是标题&quot;, width: &quot;80&quot;, height: &quot;80&quot;, imgUrl: &quot;imgUrl&quot;&#125;&#125;// 相对应的如果子组件定义了 props,打印的值就是剔除定义的属性props: &#123; width: &#123; type: String, default: &#x27;&#x27; &#125;&#125;,mounted() &#123; console.log(this.$attrs) //&#123;title: &quot;这是标题&quot;, height: &quot;80&quot;, imgUrl: &quot;imgUrl&quot;&#125;&#125; listeners:场景:子组件需要调用父组件的方法。解决:父组件的方法可以通过 v-on=&quot;listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用 1234567// 父组件&lt;home @change=&quot;change&quot;/&gt;// 子组件mounted() &#123; console.log(this.$listeners) //即可拿到 change 事件&#125; 5. provide 和 injectprovide 和 inject 主要为高阶插件&#x2F;组件库提供用例。并不推荐直接用于应用程序代码中; 并且这对选项需要一起使用; 以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 123456789101112131415//父组件:provide: &#123; //provide 是一个对象,提供一个属性或方法 foo: &#x27;这是 foo&#x27;, fooMethod:()=&gt;&#123; console.log(&#x27;父组件 fooMethod 被调用&#x27;) &#125;&#125;,// 子或者孙子组件inject: [&#x27;foo&#x27;,&#x27;fooMethod&#x27;], //数组或者对象,注入到子组件mounted() &#123; this.fooMethod() console.log(this.foo)&#125;//在父组件下面所有的子组件都可以利用inject 6. $refs通常用于父组件调用子组件的方法 123456// 父组件&lt;home ref=&quot;child&quot;/&gt;mounted()&#123; console.log(this.$refs.child) //即可拿到子组件的实例,就可以直接操作 data 和 methods&#125; 7. EventBus 就是声明一个全局 Vue 实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上; 类似于 Vuex。但这种方式只适用于极小的项目 3.原理就是利用 emit 并实例化一个全局 vue 实现数据共享 12345678910// 在 main.jsVue.prototype.$eventBus = new Vue()// 传值组件this.$eventBus.$emit(&#x27;eventTarget&#x27;, &#x27;这是eventTarget传过来的值&#x27;)// 接收组件this.$eventBus.$on(&#x27;eventTarget&#x27;, v =&gt; &#123; console.log(&#x27;eventTarget&#x27;, v) //这是eventTarget传过来的值&#125;) 路由配置和使用 配置路由信息123456789101112131415161718let routes = [ &#123; path: &#x27;/home&#x27;, component: home &#125;, &#123; path: &#x27;/list&#x27;, component: list &#125;]let router = new VueRouter(&#123; routes: routes&#125;)let vm = new Vue(&#123; el: &#x27;#app&#x27;, router&#125;) 在html使用 12345&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&#x27;/home&#x27; active-class=&#x27;current&#x27;&gt;首页&lt;/router-link&gt; &lt;router-link to=&#x27;/list&#x27; tag=&#x27;div&#x27;&gt;列表&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 此外，vue-router还可以通过一下方式配置动态路由 query传参（问号传参） params传参（路径传参） 路由懒加载Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式： 12345678910111213141516// 1、Vue异步组件技术：&#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: resolve =&gt; reqire([&#x27;path路径&#x27;], resolve)&#125;// 2、es6提案的import()const Home = () =&gt; import(&#x27;path路径&#x27;)// 3、webpack提供的require.ensure()&#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: r =&gt; require.ensure([],() =&gt; r(require(&#x27;path路径&#x27;)), &#x27;demo&#x27;)&#125; 路由守卫vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 全局前置守卫常用于判断登录状态和菜单权限校验 12345678router.beforeEach((to, from, next) =&gt; &#123; let isLogin = sessionStorage.getItem(&#x27;isLogin&#x27;) || &#x27;&#x27; if (!isLogin &amp;&amp; to.meta.auth) &#123; next(&#x27;/login&#x27;) &#125; else &#123; next() &#125;&#125;) to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 组件内的守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 路由缓存 keepalivekeep-alive 是 Vue 提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在 v 页面渲染完毕后不会被渲染成一个 DOM 元素。 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 当组件在 keep-alive 内被切换时组件的 activated、deactivated 这两个生命周期钩子函数会被执行 1. 使用参数include&#x2F;exclude include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 123456&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;keep-alive exclude=&quot;c&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; include 属性表示只有 name 属性为 a，b 的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存。exclude 属性表示除了 name 属性为 c 的组件不会被缓存，其它组件都会被缓存。 2. 使用$route.meta 的 keepAlive 属性需要在 router 中设置 router 的元信息 meta 1234567891011121314151617181920export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;Hello&#x27;, component: Hello, meta: &#123; keepAlive: false // 不需要缓存 &#125; &#125;, &#123; path: &#x27;/page1&#x27;, name: &#x27;Page1&#x27;, component: Page1, meta: &#123; keepAlive: true // 需要被缓存 &#125; &#125; ]&#125;) 在 app.vue 进行区别缓存和不用缓存的页面 123456&lt;div id=&quot;app&quot;&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/div&gt; hash 和 history模式 hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取。特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。 history 模式：history 采用 HTML5 的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 hash 模式中（ http://localhost:8080#home），即使不需要配置，静态服务器始终会去寻找index.html并返回给我们，然后vue-router会获取 #后面的字符作为参数，对前端页面进行变换。 history 模式中，我们所想要的情况就是：输入http://localhost:8080/home，但最终返回的也是index.html，然后vue-router会获取 home 作为参数，对前端页面进行变换。那么在nginx中，谁能做到这件事呢？答案就是try_files。","categories":[],"tags":[]},{"title":"Vue 自定义指令","slug":"分享8个Vue自定义指令","date":"2022-04-24T01:45:19.110Z","updated":"2022-04-24T01:59:31.928Z","comments":true,"path":"2022/04/24/分享8个Vue自定义指令/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E5%88%86%E4%BA%AB8%E4%B8%AAVue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"Vue 自定义指令在 Vue，除了核心功能默认内置的指令 ( v-model 和 v-show )，Vue 也允许注册自定义指令。它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作。 Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。 批量注册指令，新建 directives/index.js 文件","text":"Vue 自定义指令在 Vue，除了核心功能默认内置的指令 ( v-model 和 v-show )，Vue 也允许注册自定义指令。它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作。 Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。 批量注册指令，新建 directives/index.js 文件 123456789101112131415import copy from &#x27;./copy&#x27;import longpress from &#x27;./longpress&#x27;// 自定义指令const directives = &#123; copy, longpress,&#125;export default &#123; install(Vue) &#123; Object.keys(directives).forEach((key) =&gt; &#123; Vue.directive(key, directives[key]) &#125;) &#125;,&#125; 在 main.js 引入并调用 123import Vue from &#x27;vue&#x27;import Directives from &#x27;./JS/directives&#x27;Vue.use(Directives) 指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 下面分享几个实用的 Vue 自定义指令 复制粘贴指令 v-copy 长按指令 v-longpress 输入框防抖指令 v-debounce 禁止表情及特殊字符 v-emoji 图片懒加载 v-LazyLoad 权限校验指令 v-premission 实现页面水印 v-waterMarker 拖拽指令 v-draggable v-copy需求：实现一键复制文本内容，用于鼠标右键粘贴。 思路： 动态创建 textarea 标签，并设置 readOnly 属性及移出可视区域 将要复制的值赋给 textarea 标签的 value 属性，并插入到 body 选中值 textarea 并复制 将 body 中插入的 textarea 移除 在第一次调用时绑定事件，在解绑时移除事件 1234567891011121314151617181920212223242526272829303132333435363738394041const copy = &#123; bind(el, &#123; value &#125;) &#123; el.$value = value el.handler = () =&gt; &#123; if (!el.$value) &#123; // 值为空的时候，给出提示。可根据项目UI仔细设计 console.log(&#x27;无复制内容&#x27;) return &#125; // 动态创建 textarea 标签 const textarea = document.createElement(&#x27;textarea&#x27;) // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = &#x27;readonly&#x27; textarea.style.position = &#x27;absolute&#x27; textarea.style.left = &#x27;-9999px&#x27; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value // 将 textarea 插入到 body 中 document.body.appendChild(textarea) // 选中值并复制 textarea.select() const result = document.execCommand(&#x27;Copy&#x27;) if (result) &#123; console.log(&#x27;复制成功&#x27;) // 可根据项目UI仔细设计 &#125; document.body.removeChild(textarea) &#125; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener(&#x27;click&#x27;, el.handler) &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;,&#125;export default copy 使用：给 Dom 加上 v-copy 及复制的文本即可 12345678910111213&lt;template&gt; &lt;button v-copy=&quot;copyText&quot;&gt;复制&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; copyText: &#x27;a copy directives&#x27;, &#125; &#125;, &#125;&lt;/script&gt; v-longpress需求：实现长按，用户需要按下并按住按钮几秒钟，触发相应的事件 思路： 创建一个计时器， 2 秒后执行函数 当用户按下按钮时触发 mousedown 事件，启动计时器；用户松开按钮时调用 mouseout 事件。 如果 mouseup 事件 2 秒内被触发，就清除计时器，当作一个普通的点击事件 如果计时器没有在 2 秒内清除，则判定为一次长按，可以执行关联的函数。 在移动端要考虑 touchstart，touchend 事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const longpress = &#123; bind: function (el, binding, vNode) &#123; if (typeof binding.value !== &#x27;function&#x27;) &#123; throw &#x27;callback must be a function&#x27; &#125; // 定义变量 let pressTimer = null // 创建计时器（ 2秒后执行函数 ） let start = (e) =&gt; &#123; if (e.type === &#x27;click&#x27; &amp;&amp; e.button !== 0) &#123; return &#125; if (pressTimer === null) &#123; pressTimer = setTimeout(() =&gt; &#123; handler() &#125;, 2000) &#125; &#125; // 取消计时器 let cancel = (e) =&gt; &#123; if (pressTimer !== null) &#123; clearTimeout(pressTimer) pressTimer = null &#125; &#125; // 运行函数 const handler = (e) =&gt; &#123; binding.value(e) &#125; // 添加事件监听器 el.addEventListener(&#x27;mousedown&#x27;, start) el.addEventListener(&#x27;touchstart&#x27;, start) // 取消计时器 el.addEventListener(&#x27;click&#x27;, cancel) el.addEventListener(&#x27;mouseout&#x27;, cancel) el.addEventListener(&#x27;touchend&#x27;, cancel) el.addEventListener(&#x27;touchcancel&#x27;, cancel) &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;,&#125;export default longpress 使用：给 Dom 加上 v-longpress 及回调函数即可 123456789101112&lt;template&gt; &lt;button v-longpress=&quot;longpress&quot;&gt;长按&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; longpress () &#123; alert(&#x27;长按指令生效&#x27;) &#125; &#125;&#125; v-debounce背景：在开发中，有些提交保存按钮有时候会在短时间内被点击多次，这样就会多次重复请求后端接口，造成数据的混乱，比如新增表单的提交按钮，多次点击就会新增多条重复的数据。 需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。 思路： 定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。 将时间绑定在 click 方法上。 123456789101112131415const debounce = &#123; inserted: function (el, binding) &#123; let timer el.addEventListener(&#x27;keyup&#x27;, () =&gt; &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; binding.value() &#125;, 1000) &#125;) &#125;,&#125;export default debounce 使用：给 Dom 加上 v-debounce 及回调函数即可 123456789101112&lt;template&gt; &lt;button v-debounce=&quot;debounceClick&quot;&gt;防抖&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; debounceClick () &#123; console.log(&#x27;只触发一次&#x27;) &#125; &#125;&#125; v-emoji背景：开发中遇到的表单输入，往往会有对输入内容的限制，比如不能输入表情和特殊字符，只能输入数字或字母等。 我们常规方法是在每一个表单的 on-change 事件上做处理。 1234567891011121314&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;note&quot; @change=&quot;vaidateEmoji&quot; /&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; vaidateEmoji() &#123; var reg = /[^\\u4E00-\\u9FA5|\\d|\\a-zA-Z|\\r\\n\\s,.?!，。？！…—&amp;$=()-+/*&#123;&#125;[\\]]|\\s/g this.note = this.note.replace(reg, &#x27;&#x27;) &#125;, &#125;, &#125;&lt;/script&gt; 这样代码量比较大而且不好维护，所以我们需要自定义一个指令来解决这问题。 需求：根据正则表达式，设计自定义处理表单输入规则的指令，下面以禁止输入表情和特殊字符为例。 123456789101112131415161718192021222324252627282930let findEle = (parent, type) =&gt; &#123; return parent.tagName.toLowerCase() === type ? parent : parent.querySelector(type)&#125;const trigger = (el, type) =&gt; &#123; const e = document.createEvent(&#x27;HTMLEvents&#x27;) e.initEvent(type, true, true) el.dispatchEvent(e)&#125;const emoji = &#123; bind: function (el, binding, vnode) &#123; // 正则规则可根据需求自定义 var regRule = /[^\\u4E00-\\u9FA5|\\d|\\a-zA-Z|\\r\\n\\s,.?!，。？！…—&amp;$=()-+/*&#123;&#125;[\\]]|\\s/g let $inp = findEle(el, &#x27;input&#x27;) el.$inp = $inp $inp.handle = function () &#123; let val = $inp.value $inp.value = val.replace(regRule, &#x27;&#x27;) trigger($inp, &#x27;input&#x27;) &#125; $inp.addEventListener(&#x27;keyup&#x27;, $inp.handle) &#125;, unbind: function (el) &#123; el.$inp.removeEventListener(&#x27;keyup&#x27;, el.$inp.handle) &#125;,&#125;export default emoji 使用：将需要校验的输入框加上 v-emoji 即可 123&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;note&quot; v-emoji /&gt;&lt;/template&gt; v-LazyLoad背景：在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。 需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。 思路： 图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的 拿到所有的图片 Dom ，遍历每个图片判断当前图片是否到了可视区范围内 如果到了就设置图片的 src 属性，否则显示默认图片 图片懒加载有两种方式可以实现，一是绑定 srcoll 事件进行监听，二是使用 IntersectionObserver 判断图片是否到了可视区域，但是有浏览器兼容性问题。 下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 IntersectionObserver API，如果支持就使用 IntersectionObserver 实现懒加载，否则则使用 srcoll 事件监听 + 节流的方法实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const LazyLoad = &#123; // install方法 install(Vue, options) &#123; const defaultSrc = options.default Vue.directive(&#x27;lazy&#x27;, &#123; bind(el, binding) &#123; LazyLoad.init(el, binding.value, defaultSrc) &#125;, inserted(el) &#123; if (IntersectionObserver) &#123; LazyLoad.observe(el) &#125; else &#123; LazyLoad.listenerScroll(el) &#125; &#125;, &#125;) &#125;, // 初始化 init(el, val, def) &#123; el.setAttribute(&#x27;data-src&#x27;, val) el.setAttribute(&#x27;src&#x27;, def) &#125;, // 利用IntersectionObserver监听el observe(el) &#123; var io = new IntersectionObserver((entries) =&gt; &#123; const realSrc = el.dataset.src if (entries[0].isIntersecting) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;) io.observe(el) &#125;, // 监听scroll事件 listenerScroll(el) &#123; const handler = LazyLoad.throttle(LazyLoad.load, 300) LazyLoad.load(el) window.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; handler(el) &#125;) &#125;, // 加载真实图片 load(el) &#123; const windowHeight = document.documentElement.clientHeight const elTop = el.getBoundingClientRect().top const elBtm = el.getBoundingClientRect().bottom const realSrc = el.dataset.src if (elTop - windowHeight &lt; 0 &amp;&amp; elBtm &gt; 0) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;, // 节流 throttle(fn, delay) &#123; let timer let prevTime return function (...args) &#123; const currTime = Date.now() const context = this if (!prevTime) prevTime = currTime clearTimeout(timer) if (currTime - prevTime &gt; delay) &#123; prevTime = currTime fn.apply(context, args) clearTimeout(timer) return &#125; timer = setTimeout(function () &#123; prevTime = Date.now() timer = null fn.apply(context, args) &#125;, delay) &#125; &#125;,&#125;export default LazyLoad 使用，将组件内 标签的 src 换成 v-LazyLoad 1&lt;img v-LazyLoad=&quot;xxx.jpg&quot; /&gt; v-permission背景：在一些后台管理系统，我们可能需要根据用户角色进行一些操作权限的判断，很多时候我们都是粗暴地给一个元素添加 v-if / v-show 来进行显示隐藏，但如果判断条件繁琐且多个地方需要判断，这种方式的代码不仅不优雅而且冗余。针对这种情况，我们可以通过全局自定义指令来处理。 需求：自定义一个权限指令，对需要权限判断的 Dom 进行显示隐藏。 思路： 自定义一个权限数组 判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom 123456789101112131415161718192021222324function checkArray(key) &#123; let arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;] let index = arr.indexOf(key) if (index &gt; -1) &#123; return true // 有权限 &#125; else &#123; return false // 无权限 &#125;&#125;const permission = &#123; inserted: function (el, binding) &#123; let permission = binding.value // 获取到 v-permission的值 if (permission) &#123; let hasPermission = checkArray(permission) if (!hasPermission) &#123; // 没有权限 移除Dom元素 el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125; &#125;,&#125;export default permission 使用：给 v-permission 赋值判断即可 123456&lt;div class=&quot;btns&quot;&gt; &lt;!-- 显示 --&gt; &lt;button v-permission=&quot;&#x27;1&#x27;&quot;&gt;权限按钮1&lt;/button&gt; &lt;!-- 不显示 --&gt; &lt;button v-permission=&quot;&#x27;10&#x27;&quot;&gt;权限按钮2&lt;/button&gt;&lt;/div&gt; vue-waterMarker需求：给整个页面添加背景水印 思路： 使用 canvas 特性生成 base64 格式的图片文件，设置其字体大小，颜色等。 将其设置为背景图片，从而实现页面或组件水印效果 123456789101112131415161718192021222324function addWaterMarker(str, parentNode, font, textColor) &#123; // 水印文字，父元素，字体，文字颜色 var can = document.createElement(&#x27;canvas&#x27;) parentNode.appendChild(can) can.width = 200 can.height = 150 can.style.display = &#x27;none&#x27; var cans = can.getContext(&#x27;2d&#x27;) cans.rotate((-20 * Math.PI) / 180) cans.font = font || &#x27;16px Microsoft JhengHei&#x27; cans.fillStyle = textColor || &#x27;rgba(180, 180, 180, 0.3)&#x27; cans.textAlign = &#x27;left&#x27; cans.textBaseline = &#x27;Middle&#x27; cans.fillText(str, can.width / 10, can.height / 2) parentNode.style.backgroundImage = &#x27;url(&#x27; + can.toDataURL(&#x27;image/png&#x27;) + &#x27;)&#x27;&#125;const waterMarker = &#123; bind: function (el, binding) &#123; addWaterMarker(binding.value.text, el, binding.value.font, binding.value.textColor) &#125;,&#125;export default waterMarker 使用，设置水印文案，颜色，字体大小即可 123&lt;template&gt; &lt;div v-waterMarker=&quot;&#123;text:&#x27;lzg版权所有&#x27;,textColor:&#x27;rgba(180, 180, 180, 0.4)&#x27;&#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt; v-draggable需求：实现一个拖拽指令，可在页面可视区域任意拖拽元素。 思路： 设置需要拖拽的元素为相对定位，其父元素为绝对定位。 鼠标按下(onmousedown)时记录目标元素当前的 left 和 top 值。 鼠标移动(onmousemove)时计算每次移动的横向距离和纵向距离的变化值，并改变元素的 left 和 top 值 鼠标松开(onmouseup)时完成一次拖拽 123456789101112131415161718192021222324252627282930313233const draggable = &#123; inserted: function (el) &#123; el.style.cursor = &#x27;move&#x27; el.onmousedown = function (e) &#123; let disx = e.pageX - el.offsetLeft let disy = e.pageY - el.offsetTop document.onmousemove = function (e) &#123; let x = e.pageX - disx let y = e.pageY - disy let maxX = document.body.clientWidth - parseInt(window.getComputedStyle(el).width) let maxY = document.body.clientHeight - parseInt(window.getComputedStyle(el).height) if (x &lt; 0) &#123; x = 0 &#125; else if (x &gt; maxX) &#123; x = maxX &#125; if (y &lt; 0) &#123; y = 0 &#125; else if (y &gt; maxY) &#123; y = maxY &#125; el.style.left = x + &#x27;px&#x27; el.style.top = y + &#x27;px&#x27; &#125; document.onmouseup = function () &#123; document.onmousemove = document.onmouseup = null &#125; &#125; &#125;,&#125;export default draggable 使用: 在 Dom 上加上 v-draggable 即可 123&lt;template&gt; &lt;div class=&quot;el-dialog&quot; v-draggable&gt;&lt;/div&gt;&lt;/template&gt;","categories":[],"tags":[]},{"title":"vue构建","slug":"从零构建到优化一个类似vue-cli的脚手架","date":"2022-04-24T01:45:19.105Z","updated":"2022-04-24T01:59:32.060Z","comments":true,"path":"2022/04/24/从零构建到优化一个类似vue-cli的脚手架/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%88%B0%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCvue-cli%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"前言想必大多数人在开发 vue 等 SPA 项目都时候都会直接用 vue-cli 等脚手架开发，一是方便省去了好多配置上的功夫，二是 vue-cli 毕竟是久经考验较为成熟的东西，遇到问题也能在网上找到相应解决方案。 但是，如果我们要更好地理解脚手架的配置及其构建打包的机制，我们就有必要从零开始，依葫芦画瓢自己配置一个类似于 vue-cli 这样的项目了。在此，我做了以下简单配置，请各位大佬批评指正，并诚心希望能得到大佬的指点，解决文章最后关于 Tree Shaking 导致打包缺失 css 的问题。","text":"前言想必大多数人在开发 vue 等 SPA 项目都时候都会直接用 vue-cli 等脚手架开发，一是方便省去了好多配置上的功夫，二是 vue-cli 毕竟是久经考验较为成熟的东西，遇到问题也能在网上找到相应解决方案。 但是，如果我们要更好地理解脚手架的配置及其构建打包的机制，我们就有必要从零开始，依葫芦画瓢自己配置一个类似于 vue-cli 这样的项目了。在此，我做了以下简单配置，请各位大佬批评指正，并诚心希望能得到大佬的指点，解决文章最后关于 Tree Shaking 导致打包缺失 css 的问题。 本文主要包括如下配置： 区分环境变量及合并配置 webpack-dev-server 本地服务器 HtmlWebpackPlugin 生成 html CleanWebpackPlugin 清理文件夹 loader 及 babel 配置 HotModuleReplacementPlugin 热更新 postcss-loader 增加 css 前缀 vue SPA 引入及解析 vue-router 安装与使用 mini-css-extract-plugin 分离 css purifycss-webpack purify-css 消除冗余 css optimize-css-assets-webpack-plugin 压缩 css terser-webpack-plugin 压缩 js splitChunks 提取公共代码 image-webpack-loader 图片压缩 gZip 加速优化 项目源码：https://github.com/Michael-lzg/webpack-vue-cli 如果对 webpack 基本配置还不了解的小伙伴，可查看以下文章从零开始构建一个 webpack 项目搭建一个 vue-cli4+webpack 移动端框架（开箱即用） 废话不多说，老司机带你立刻上路。 搭建 webpack 项目框架构建项目结构 创建 webpack-vue-cli 文件夹，npm-init-y 初始化项目 安装 webpack 相关依赖 1npm i webpack webpack-cli webpack-dev-server webpack-merge --save-dev 如果 webpack 和 webpack-cli 没有全局安装的话，要先全局安装 建立项目文件夹 1234567├── src // webpack配置文件 |——main.js // 入口文件├── static // 项目打包路径├── index.html // 模板html├── webpack.base.js // 打包基本配置├── webpack.dev.js // 本地环境配置├── webpack.prod.js // 生产环境配置 index.html 和 main.js 的代码不多说，直接进入 webpack 配置环节。 区分环境为了更好的优化打包，我们将 webpack 的配置分开开发环境和生产环境。 webpack.base.js 公共配置文件 webpack.dev.js 开发环境的配置文件 webpack.prod.js 生产环境的配置文件 在 webpack.dev.js 和 webpack.prod.js，我们可以利用 webpack-merge 进行配置的合并。 然后，我们在 package.json 定义不同环境的打包命令 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js --mode development&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;&#125; 公共配置我们先来看一下 webpack.base.js 的公共配置，定义好入口文件和出口文件 123456789module.exports = &#123; entry: &#123; index: path.join(__dirname, &#x27;/src/main.js&#x27;), &#125;, output: &#123; path: path.join(__dirname, &#x27;/dist&#x27;), //打包后的文件存放的地方 filename: &#x27;js/[name].[hash].js&#x27;, // 每次保存 hash 都变化 &#125;,&#125; webpack-dev-serverwebpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，所以在 webpack.dev.js 进行配置 1234567891011121314const merge = require(&#x27;webpack-merge&#x27;) // 引入webpack-merge功能模块const common = require(&#x27;./webpack.base.js&#x27;) // 引入webpack.common.jsmodule.exports = merge(common, &#123; // 将webpack.common.js合并到当前文件 devServer: &#123; contentBase: &#x27;./dist&#x27;, // 本地服务器所加载文件的目录 port: &#x27;8899&#x27;, // 设置端口号为8088 inline: true, // 文件修改后实时刷新 historyApiFallback: true, //不跳转 hot: true, // 热更新 &#125;, mode: &#x27;development&#x27;, // 设置mode&#125;) HtmlWebpackPluginHtmlWebpackPlugin 简化了 HTML 文件的创建，它可以根据 html 模板在打包后自动为你生产打包后的 html 文件。这对于在文件名中包含每次会随着编译而发生变化哈希的bundle。 12345plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;/index.html&#x27;), // new一个这个插件的实例，并传入相关的参数 &#125;),] 至此就搭建好一个乞丐版的 webpack 项目了，你可以随意编写代码，分别在开发环境和生产环境执行命令查看效果。 loader 配置loader 可以让 webpack 能够去处理那些非 javaScript 文件（webpack 自身只理解 javaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 对于 loader 的科普和配置，在这里不做一一说明，直接奉上代码，分别是处理样式，js 和文件的 loader。 12345678910111213141516171819202122232425module: &#123; rules: [ &#123; test: /\\.css$/, // 正则匹配以.css结尾的文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], &#125;, &#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;], &#125;, &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, include: [resolve(&#x27;src&#x27;)], &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;), &#125;, &#125;, ]&#125; 为了更方便的配置和优化 babel-loader，我们可以将其提取出来，在根目录下新建 .babelrc 文件 123&#123; &quot;presets&quot;: [&quot;env&quot;]&#125; CleanWebpackPlugin在每次构建前清理&#x2F;dist 文件夹，生产最新的打包文件，这时候就用到 CleanWebpackPlugin 插件了。 123456plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;/index.html&#x27;), // new一个这个插件的实例，并传入相关的参数 &#125;), new CleanWebpackPlugin(), // 所要清理的文件夹名称] HotModuleReplacementPluginHotModuleReplacementPlugin（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果，在开发环境使用。 devServer 配置项中设置 hot: true HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。 123plugins: [ new webpack.HotModuleReplacementPlugin(), // 热更新插件] 增加 css 前缀平时我们写 css 时，一些属性需要手动加上前缀，比如-webkit-border-radius: 10px;，在 webpack 中我们可以让他自动加上 安装依赖 1npm i postcss-loader autoprefixer -D 在项目根目录下新建 postcss.config.js 文件 12345module.exports = &#123; plugins: [ require(&#x27;autoprefixer&#x27;), // 引用autoprefixer模块 ],&#125; 修改样式 loader 12345678910rules: [ &#123; test: /\\.css$/, // 正则匹配以.css结尾的文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;], &#125;, &#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;, &#x27;less-loader&#x27;], &#125;,] 至此，一个 webpack 项目基本搭建而成，下面介绍 vue 的引用和项目优化。 搭建 vue SPA 模板vue SPA1、搭建一个类似于 vue-cli 的脚手架，首先我们来依葫芦画瓢，在 main.js 写上一下代码 123456import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;new Vue(&#123; el: &#x27;#app&#x27;, render: (h) =&gt; h(App),&#125;) 2、然后在 src 文件夹下新建 APP.vue 1&lt;div id=&quot;app&quot;&gt;SPA项目&lt;/div&gt; 3、安装相关依赖 到这里，我们 npm run dev 试一下就报错了。因为我们没有安装相关依赖，下面我们下来安装一下依赖 1npm install vue vue-loader vue-template-compiler -D vue: vue 的源码 vue-loader：解析.vue 文件 vue-template-compiler： 编译 vue 4、在 webpack 配置 vue-loader 123456789101112const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, &#125;, ], &#125;, plugins: [new VueLoaderPlugin()],&#125; vue-router1、安装依赖 1npm install vue-router -D 2、在 src 文件夹下新建 router&#x2F;index 12345678910111213141516171819import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router)const router = new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;../views/Home.vue&#x27;), &#125;, &#123; path: &#x27;/admin&#x27;, component: () =&gt; import(&#x27;../views/admin.vue&#x27;), &#125;, ],&#125;)export default router 3、在 main.js 引用 123456789import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;new Vue(&#123; el: &#x27;#app&#x27;, router, render: (h) =&gt; h(App),&#125;) 就这样，一个类似于 vue-cli 的脚手架就搭建好了，你可以愉快地写 .vue 文件进行 SPA 开发。 webpack 优化打包分离 css虽然 webpack 的理念是把 css、js 全都打包到一个文件里，但要是我们想把 css 分离出来，这里我们用到 mini-css-extract-plugin。对比另一个插件 extract-text-webpack-plugin，它有以下优点: 异步加载 不重复编译，性能更好 更容易使用 只针对 CSS 但是mini-css-extract-plugin 不支持 HMR，所以我们只能在生产环境使用它。 1、安装依赖 1npm install mini-css-extract-plugin -D 2、在webpack.prod.js 配置 loader 和 plugin 123456789101112131415161718192021222324module: &#123; rules: [ &#123; test: /\\.(le|c)ss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: &#x27;../&#x27; &#125;, &#125;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;, &#x27;less-loader&#x27;, ] &#125; ]&#125;,plugins: [ new MiniCssExtractPlugin(&#123; filename: &quot;css/[name].[contenthash:8].css&quot;, chunkFilename: &#x27;css/[id].[contenthash:8].css&#x27; &#125;)] 分离 css 需要将 css loader 中的 style-loader 替换为 MiniCssExtractPlugin 消除冗余 css有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。 1、安装依赖 1npm i purifycss-webpack purify-css glob -D 2、webpack.prod.js 配置 1234567891011const path = require(&#x27;path&#x27;)const PurifyCssWebpack = require(&#x27;purifycss-webpack&#x27;) // 引入PurifyCssWebpack插件const glob = require(&#x27;glob&#x27;) // 引入glob模块,用于扫描全部html文件中所引用的cssmodule.exports = merge(common, &#123; plugins: [ new PurifyCssWebpack(&#123; paths: glob.sync(path.join(__dirname, &#x27;src/*.html&#x27;)), &#125;), ],&#125;) 压缩 css我们希望减小 css 打包后的体积，可以用到 optimize-css-assets-webpack-plugin。1、安装依赖 1npm install optimize-css-assets-webpack-plugin -D 2、webpack.prod.js 配置 1234567const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;) // 压缩css代码optimization: &#123; minimizer: [ // 压缩css new OptimizeCSSAssetsPlugin(&#123;&#125;) ] 压缩 jsWebpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。 1、安装依赖 1npm install terser-webpack-plugin -D 2、webpack.prod.js 配置 12345678910111213const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;) // 压缩js代码optimization: &#123; minimizer: [ new TerserPlugin(&#123; parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1 cache: true, // 是否缓存 sourceMap: false, &#125;), // 压缩css new OptimizeCSSAssetsPlugin(&#123;&#125;), ]&#125; 提取公共代码在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 vue 全家桶的一些东西， 我们希望能和自己的代码分离开。webpack4 使用 splitChunks 的方法进行配置。 1234567891011121314optimization: &#123; // 分离chunks splitChunks: &#123; chunks: &#x27;all&#x27;, cacheGroups: &#123; vendor: &#123; name: &quot;vendor&quot;, test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: &quot;initial&quot; // 只打包初始时依赖的第三方 &#125;, &#125; &#125;&#125; 图片压缩在项目中有些图片太大影响加载，我们用 image-webpack-loader 进行压缩。 1、安装依赖 1npm install image-webpack-loader -D 2、配置 loader 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; test: /\\.(png|jpg|svg|gif)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; esModule: false, limit: 1000, // 限制只有小于1kb的图片才转为base64 outputPath: &#x27;images&#x27;, // 设置打包后图片存放的文件夹名称 name: &#x27;[name][hash:8].[ext]&#x27; &#125; &#125;, &#123; loader: &#x27;image-webpack-loader&#x27;, options: &#123; // 压缩 jpeg 的配置 mozjpeg: &#123; progressive: true, quality: 65 &#125;, // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭 optipng: &#123; enabled: false, &#125;, // // 使用 imagemin-pngquant 压缩 png pngquant: &#123; quality: [0.65, 0.90], speed: 4 &#125;, // 压缩 gif 的配置 gifsicle: &#123; interlaced: false, &#125;, // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 webp: &#123; quality: 75 &#125; &#125; &#125; ]&#125; gZip 加速优化所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。 gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。 12345678910111213const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; config.plugins.push( new CompressionPlugin(&#123; // gzip压缩配置 test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 对超过10kb的数据进行压缩 deleteOriginalAssets: false, // 是否删除原文件 &#125;) ) &#125;&#125; tree-shaking（求助，生产环境打包生成不了样式）按以上的方式构建项目，在开发环境一直都是顺顺利利的，然而一执行 npm run build，打开页面，发现样式全都缺失了。打开 dist/css 文件夹，发现三个 css 文件，只有 index.css 有部分文件（是 main.js 引入额初始化样式，但也是不全的），另外两个 css 文件则是空空如也，也就是.vue 里面的样式全都缺失了。 查看资源，初步判断为 webpack4 默认使用 tree-shaking，会把 在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果。但是我已经按相关资源在 package.json 配置了 sideEffects 了，但是还是没用，实在苦恼！！！ 12345&quot;sideEffects&quot;: [ &quot;*.less&quot;, &quot;*.css&quot;, &quot;*.vue&quot; ]","categories":[],"tags":[]},{"title":"基于 vue 的自定义指令集合","slug":"vue 自定义指令","date":"2022-04-24T01:45:19.101Z","updated":"2022-04-24T01:59:31.912Z","comments":true,"path":"2022/04/24/vue 自定义指令/","link":"","permalink":"https://data-cz.github.io/2022/04/24/vue%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"v-directives基于 vue 的自定义指令集合，包含 复制粘贴指令 v-copy 长按指令 v-longpress 输入框防抖指令 v-debounce 禁止表情及特殊字符 v-emoji 图片懒加载 v-LazyLoad 权限校验指令 v-premission 实现页面水印 v-waterMarker 拖拽指令 v-draggable","text":"v-directives基于 vue 的自定义指令集合，包含 复制粘贴指令 v-copy 长按指令 v-longpress 输入框防抖指令 v-debounce 禁止表情及特殊字符 v-emoji 图片懒加载 v-LazyLoad 权限校验指令 v-premission 实现页面水印 v-waterMarker 拖拽指令 v-draggable v-copy 需求：实现一键复制文本内容，用于鼠标右键粘贴。 思路： 动态创建 textarea 标签，并设置 readOnly 属性及移出可视区域 将要 copy 的值赋给 textarea 标签的 value 属性，并插入到 body 选中值 textarea 并复制 将 body 中插入的 textarea 移除 在第一次调用时绑定事件，在解绑时移除事件 1234567891011121314151617181920212223242526272829303132333435363738394041const copy = &#123; bind(el, &#123; value &#125;) &#123; el.$value = value el.handler = () =&gt; &#123; if (!el.$value) &#123; // 值为空的时候，给出提示。可根据项目UI仔细设计 console.log(&#x27;无复制内容&#x27;) return &#125; // 动态创建 textarea 标签 const textarea = document.createElement(&#x27;textarea&#x27;) // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = &#x27;readonly&#x27; textarea.style.position = &#x27;absolute&#x27; textarea.style.left = &#x27;-9999px&#x27; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value // 将 textarea 插入到 body 中 document.body.appendChild(textarea) // 选中值并复制 textarea.select() const result = document.execCommand(&#x27;Copy&#x27;) if (result) &#123; console.log(&#x27;复制成功&#x27;) // 可根据项目UI仔细设计 &#125; document.body.removeChild(textarea) &#125; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener(&#x27;click&#x27;, el.handler) &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;,&#125;export default copy 使用：给 Dom 加上 v-copy 及复制的文本即可 12345678910111213&lt;template&gt; &lt;button v-copy=&quot;copyText&quot;&gt;复制&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; copyText: &#x27;a copy directives&#x27;, &#125; &#125;, &#125;&lt;/script&gt; v-longpress需求：实现长按，用户需要按下并按住按钮几秒钟，触发相应的事件 思路： 创建一个计时器， 2 秒后执行函数 当用户按下按钮时触发 mousedown 事件，启动计时器；用户松开按钮时调用 mouseout 事件。 如果 mouseup 事件 2 秒内被触发，就清除计时器，当作一个普通的点击事件 如果计时器没有在 2 秒内清除，则判定为一次长按，可以执行关联的函数。 在移动端要考虑 touchstart，touchend 事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const longpress = &#123; bind: function (el, binding, vNode) &#123; if (typeof binding.value !== &#x27;function&#x27;) &#123; throw &#x27;callback must be a function&#x27; &#125; // 定义变量 let pressTimer = null // 创建计时器（ 2秒后执行函数 ） let start = (e) =&gt; &#123; if (e.type === &#x27;click&#x27; &amp;&amp; e.button !== 0) &#123; return &#125; if (pressTimer === null) &#123; pressTimer = setTimeout(() =&gt; &#123; handler() &#125;, 2000) &#125; &#125; // 取消计时器 let cancel = (e) =&gt; &#123; if (pressTimer !== null) &#123; clearTimeout(pressTimer) pressTimer = null &#125; &#125; // 运行函数 const handler = (e) =&gt; &#123; binding.value(e) &#125; // 添加事件监听器 el.addEventListener(&#x27;mousedown&#x27;, start) el.addEventListener(&#x27;touchstart&#x27;, start) // 取消计时器 el.addEventListener(&#x27;click&#x27;, cancel) el.addEventListener(&#x27;mouseout&#x27;, cancel) el.addEventListener(&#x27;touchend&#x27;, cancel) el.addEventListener(&#x27;touchcancel&#x27;, cancel) &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;,&#125;export default longpress 使用：给 Dom 加上 longpress 及回调函数即可 123456789101112&lt;template&gt; &lt;button v-longpress=&quot;longpress&quot;&gt;长按&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; longpress () &#123; alert(&#x27;长按指令生效&#x27;) &#125; &#125;&#125; v-debounce背景：在开发中，有些提交保存按钮有时候会在短时间内被点击多次，这样就会多次重复请求后端接口，造成数据的混乱，比如新增表单的提交按钮，多次点击就会新增多条重复的数据。 需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。 思路： 定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。 将时间绑定在 click 方法上。 123456789101112131415const debounce = &#123; inserted: function (el, binding) &#123; let timer el.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; binding.value() &#125;, 1000) &#125;) &#125;,&#125;export default debounce 使用：给 Dom 加上 v-debounce 及回调函数即可 123456789101112&lt;template&gt; &lt;button v-debounce=&quot;debounceClick&quot;&gt;防抖&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; debounceClick () &#123; console.log(&#x27;只触发一次&#x27;) &#125; &#125;&#125; v-emoji背景：开发中遇到的表单输入，往往会有对输入内容的限制，比如不能输入表情和特殊字符，只能输入数字或字母等。 我们常规方法是在每一个表单的@change 事件上做处理。 1234567891011121314&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;note&quot; @change=&quot;vaidateEmoji&quot; /&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; vaidateEmoji() &#123; var reg = /[^\\u4E00-\\u9FA5|\\d|\\a-zA-Z|\\r\\n\\s,.?!，。？！…—&amp;$=()-+/*&#123;&#125;[\\]]|\\s/g this.note = this.note.replace(reg, &#x27;&#x27;) &#125;, &#125;, &#125;&lt;/script&gt; 这样代码量比较大而且不好维护，所以我们需要自定义一个指令来解决这问题。 需求：根据正则表达式，设计自定义处理表单输入规则的指令，下面以禁止输入表情和特殊字符为例。 123456789101112131415161718192021222324252627282930let findEle = (parent, type) =&gt; &#123; return parent.tagName.toLowerCase() === type ? parent : parent.querySelector(type)&#125;const trigger = (el, type) =&gt; &#123; const e = document.createEvent(&#x27;HTMLEvents&#x27;) e.initEvent(type, true, true) el.dispatchEvent(e)&#125;const emoji = &#123; bind: function (el, binding, vnode) &#123; // 正则规则可根据需求自定义 var regRule = /[^\\u4E00-\\u9FA5|\\d|\\a-zA-Z|\\r\\n\\s,.?!，。？！…—&amp;$=()-+/*&#123;&#125;[\\]]|\\s/g let $inp = findEle(el, &#x27;input&#x27;) el.$inp = $inp $inp.handle = function () &#123; let val = $inp.value $inp.value = val.replace(regRule, &#x27;&#x27;) trigger($inp, &#x27;input&#x27;) &#125; $inp.addEventListener(&#x27;keyup&#x27;, $inp.handle) &#125;, unbind: function (el) &#123; el.$inp.removeEventListener(&#x27;keyup&#x27;, el.$inp.handle) &#125;,&#125;export default emoji 使用：将需要校验的输入框加上 v-emoji 即可 123&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;note&quot; v-emoji /&gt;&lt;/template&gt; v-LazyLoad背景：在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。 需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。 思路： 图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的 拿到所有的图片 dome ，遍历每个图片判断当前图片是否到了可视区范围内 如果到了就设置图片的 src 属性，否则显示默认图片 图片懒加载有两种方式可以实现，一是绑定 srcoll 事件进行监听，二是使用 IntersectionObserver 判断图片是否到了可视区域，但是有浏览器兼容性问题。 下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 IntersectionObserver API，如果支持就使用 IntersectionObserver 实现懒加载，否则则使用 srcoll 事件监听 + 节流的方法实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const LazyLoad = &#123; // install方法 install(Vue, options) &#123; const defaultSrc = options.default Vue.directive(&#x27;lazy&#x27;, &#123; bind(el, binding) &#123; LazyLoad.init(el, binding.value, defaultSrc) &#125;, inserted(el) &#123; if (IntersectionObserver) &#123; LazyLoad.observe(el) &#125; else &#123; LazyLoad.listenerScroll(el) &#125; &#125;, &#125;) &#125;, // 初始化 init(el, val, def) &#123; el.setAttribute(&#x27;data-src&#x27;, val) el.setAttribute(&#x27;src&#x27;, def) &#125;, // 利用IntersectionObserver监听el observe(el) &#123; var io = new IntersectionObserver((entries) =&gt; &#123; const realSrc = el.dataset.src if (entries[0].isIntersecting) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;) io.observe(el) &#125;, // 监听scroll事件 listenerScroll(el) &#123; const handler = LazyLoad.throttle(LazyLoad.load, 300) LazyLoad.load(el) window.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; handler(el) &#125;) &#125;, // 加载真实图片 load(el) &#123; const windowHeight = document.documentElement.clientHeight const elTop = el.getBoundingClientRect().top const elBtm = el.getBoundingClientRect().bottom const realSrc = el.dataset.src if (elTop - windowHeight &lt; 0 &amp;&amp; elBtm &gt; 0) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;, // 节流 throttle(fn, delay) &#123; let timer let prevTime return function (...args) &#123; const currTime = Date.now() const context = this if (!prevTime) prevTime = currTime clearTimeout(timer) if (currTime - prevTime &gt; delay) &#123; prevTime = currTime fn.apply(context, args) clearTimeout(timer) return &#125; timer = setTimeout(function () &#123; prevTime = Date.now() timer = null fn.apply(context, args) &#125;, delay) &#125; &#125;,&#125;export default LazyLoad 使用，将组件内 标签的 src 换成 v-LazyLoad 1&lt;img v-LazyLoad=&quot;xxx.jpg&quot; /&gt; v-permission背景：在一些后台管理系统，我们可能需要根据用户角色进行一些操作权限的判断，很多时候我们都是粗暴地给一个元素添加 v-if &#x2F; v-show 来进行显示隐藏，但如果判断条件繁琐且多个地方需要判断，这种方式的代码不仅不优雅而且冗余。针对这种情况，我们可以通过全局自定义指令来处理。 需求：自定义一个权限指令，对需要权限判断的 dom 进行显示隐藏。 思路： 自定义一个权限数组 判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom 123456789101112131415161718192021222324function checkArray(key) &#123; let arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;] let index = arr.indexOf(key) if (index &gt; -1) &#123; return true // 有权限 &#125; else &#123; return false // 无权限 &#125;&#125;const permission = &#123; inserted: function (el, binding) &#123; let permission = binding.value // 获取到 v-permission的值 if (permission) &#123; let hasPermission = checkArray(permission) if (!hasPermission) &#123; // 没有权限 移除Dom元素 el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125; &#125;,&#125;export default permission 使用：给 v-permission 赋值判断即可 123456&lt;div class=&quot;btns&quot;&gt; &lt;!-- 显示 --&gt; &lt;button v-permission=&quot;&#x27;1&#x27;&quot;&gt;权限按钮1&lt;/button&gt; &lt;!-- 不显示 --&gt; &lt;button v-permission=&quot;&#x27;10&#x27;&quot;&gt;权限按钮2&lt;/button&gt;&lt;/div&gt; vue-waterMarker需求：给整个页面添加背景水印 思路： 使用 canvas 特性生成 base64 格式的图片文件，设置其字体大小，颜色等。 将其设置为背景图片，从而实现页面或组件水印效果 123456789101112131415161718192021222324function addWaterMarker(str, parentNode, font, textColor) &#123; // 水印文字，父元素，字体，文字颜色 var can = document.createElement(&#x27;canvas&#x27;) parentNode.appendChild(can) can.width = 200 can.height = 150 can.style.display = &#x27;none&#x27; var cans = can.getContext(&#x27;2d&#x27;) cans.rotate((-20 * Math.PI) / 180) cans.font = font || &#x27;16px Microsoft JhengHei&#x27; cans.fillStyle = textColor || &#x27;rgba(180, 180, 180, 0.3)&#x27; cans.textAlign = &#x27;left&#x27; cans.textBaseline = &#x27;Middle&#x27; cans.fillText(str, can.width / 10, can.height / 2) parentNode.style.backgroundImage = &#x27;url(&#x27; + can.toDataURL(&#x27;image/png&#x27;) + &#x27;)&#x27;&#125;const waterMarker = &#123; bind: function (el, binding) &#123; addWaterMarker(binding.value.text, el, binding.value.font, binding.value.textColor) &#125;,&#125;export default waterMarker 使用，设置水印文案，颜色，字体大小即可 123&lt;template&gt; &lt;div v-waterMarker=&quot;&#123;text:&#x27;lzg版权所有&#x27;,textColor:&#x27;rgba(180, 180, 180, 0.4)&#x27;&#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt; v-draggable需求：实现一个拖拽指令，可在页面可视区域任意拖拽元素。 思路： 设置需要拖拽的元素为相对定位，其父元素为绝对定位。 鼠标按下(onmousedown)时记录目标元素当前的 left 和 top 值。 鼠标移动(onmousemove)时计算每次移动的横向距离和纵向距离的变化值，并改变元素的 left 和 top 值 鼠标松开(onmouseup)时完成一次拖拽 123456789101112131415161718192021222324252627282930313233const draggable = &#123; inserted: function (el) &#123; el.style.cursor = &#x27;move&#x27; el.onmousedown = function (e) &#123; let disx = e.pageX - el.offsetLeft let disy = e.pageY - el.offsetTop document.onmousemove = function (e) &#123; let x = e.pageX - disx let y = e.pageY - disy let maxX = document.body.clientWidth - parseInt(window.getComputedStyle(el).width) let maxY = document.body.clientHeight - parseInt(window.getComputedStyle(el).height) if (x &lt; 0) &#123; x = 0 &#125; else if (x &gt; maxX) &#123; x = maxX &#125; if (y &lt; 0) &#123; y = 0 &#125; else if (y &gt; maxY) &#123; y = maxY &#125; el.style.left = x + &#x27;px&#x27; el.style.top = y + &#x27;px&#x27; &#125; document.onmouseup = function () &#123; document.onmousemove = document.onmouseup = null &#125; &#125; &#125;,&#125;export default draggable 使用: 在 Dom 上加上 v-draggable 即可 123&lt;template&gt; &lt;div class=&quot;el-dialog&quot; v-draggable&gt;&lt;/div&gt;&lt;/template&gt; 源码链接地址:Vue自定义指令源码地址","categories":[],"tags":[]},{"title":"webSocket","slug":"浅谈webscoket原理及其应用","date":"2022-04-24T01:43:08.455Z","updated":"2022-04-24T01:59:32.113Z","comments":true,"path":"2022/04/24/浅谈webscoket原理及其应用/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%B5%85%E8%B0%88webscoket%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","excerpt":"","text":"什么是 webSocketWebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 WebSocket 解决了什么问题：在不使用 WebSocket 时，如果我们需要建立一条长连接，有以下几种方法： 轮询 长轮询（常用） SSE(Server Send Event) 当出现类似体育赛事、聊天室、实时位置之类的场景时，客户端要获取服务器端的变化，就只能通过轮询(定时请求)来了解服务器端有没有新的信息变化。WebSocket 的出现，让服务器端可以主动向服务器端发送信息，使得浏览器具备了实时双向通信的能力,这就是 WebSocket 解决的问题 带宽问题：WebSocket 相对于 HTTP 来说协议头更加小，同时按需传递。 数据实时性问题：WebSocket 相对于轮询和长轮询来说，能够实时传递数据，延迟更小。 状态问题：相较于 HTTP 的无状态请求，WebSocket 在建立连接后能够维持特定的状态。 WebSocket 与 HTTP 对比 基本使用客户端 123456789101112131415161718const ws = new WebSocket(&#x27;ws://localhost:8888&#x27;)ws.onopen = () =&gt; &#123; console.log(&#x27;WebSocket onopen&#x27;)&#125;ws.onmessage = e =&gt; &#123; console.log(e) console.log(e.data)&#125;ws.onclose = e =&gt; &#123; console.log(&#x27;WebSocket onclose&#x27;)&#125;ws.onerror = e =&gt; &#123; console.log(&#x27;WebSocket onerror&#x27;)&#125; WebSocket.onopen： 连接成功后调用 WebSocket.onmessage： 当接收到服务器消息时调用 WebSocket.onclose： 连接关闭后调用 WebSocket.onerror： 发生错误后调用 服务端例子(koa) 1234567891011121314151617const Koa = require(&#x27;koa&#x27;)const WebSocket = require(&#x27;ws&#x27;)const app = new Koa()const ws = new WebSocket.Server(&#123; port: 8888 &#125;)ws.on(&#x27;connection&#x27;, ws =&gt; &#123; console.log(&#x27;server connection&#x27;) ws.on(&#x27;message&#x27;, msg =&gt; &#123; console.log(&#x27;server receive msg：&#x27;, msg) &#125;) ws.send(&#x27;Information from the server&#x27;)&#125;)app.listen(3000) WebSocket 可以传递 String、ArrayBuffer 和 Blob 三种数据类型，因此在收到消息时可能是其中的任意一种。其中，String 和 ArrayBuffer 使用的最多。 如果是 String 类型，直接通过字符串处理函数即可进行相关转换，如 JSON 等格式。 如果是二进制 blob 类型，则需要使用 ArrayBuffer 和 DataView 来进行处理，下面简单介绍。 二进制数据包括：blob 对象和 Arraybuffer 对象，所以我们需要分开来处理。 1234567891011121314151617181920// 接收数据ws.onmessage = function(event) &#123; if (event.data instanceof ArrayBuffer) &#123; // 判断 ArrayBuffer 对象 &#125; if (event.data instanceof Blob) &#123; // 判断 Blob 对象 &#125;&#125;// 发送 Blob 对象的例子let file = document.querySelector(&#x27;input[type=&quot;file&quot;]&#x27;).files[0]ws.send(file)// 发送 ArrayBuffer 对象的例子var img = canvas_context.getImageData(0, 0, 400, 320)var binary = new Uint8Array(img.data.length)for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i]&#125;ws.send(binary.buffer) webSocket.bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去如果发送的二进制数据很大的话，可以这样判断 1234567var data = new ArrayBuffer(10000000)socket.send(data)if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; 总结 WebSocket 的优点 双向通信(一开始说的，也是最重要的一点)。 数据格式比较轻量，性能开销小，通信高效 协议控制的数据包头部较小，而 HTTP 协议每次通信都需要携带完整的头部 更好的二进制支持 没有同源限制，客户端可以与任意服务器通信 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器","categories":[],"tags":[]},{"title":"JS 基本知识","slug":"创建对象和原型链","date":"2022-04-24T01:43:08.451Z","updated":"2022-04-24T01:59:32.253Z","comments":true,"path":"2022/04/24/创建对象和原型链/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"1 前言1.1 面向对象的三大特性 封装 继承 多态 1.2 原型链的知识 原型链是面向对象的基础，是非常重要的部分。有以下几种知识： 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new 运算符 2 创建对象有几种方法2.1 方式一：字面量12var obj11 = &#123;name: &#x27;smyh&#x27;&#125;;var obj12 = new Object(name: `smyh`); //内置对象（内置的构造函数） 上面的两种写法，效果是一样的。因为，第一种写法，obj11会指向Object。 第一种写法是：字面量的方式。 第二种写法是：内置的构造函数 2.2 方式二：通过构造函数1234var M = function (name) &#123; this.name = name;&#125;var obj3 = new M(&#x27;smyhvae&#x27;); 2.3 方法三：Object.create12var p = &#123;name:&#x27;smyhvae&#x27;&#125;;var obj3 = Object.create(p); //此方法创建的对象，是用原型链连接的 第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的``原型（name是p原型里的属性），构造函数是Objecet&#96; 。 3 原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。 3.1 原型、构造函数、实例三者之间的关系 构造函数通过 new 生成实例 构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示： 12345var Foo = function (name) &#123; this.name = name;&#125;var fn = new Foo(&#x27;smyhvae&#x27;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true： 实例的__proto__指向原型。也就是说，Foo.__proto__ === M.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。 Foo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。 3.2 原型链原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。 Object是原型链的顶端。 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享： 1234//给Foo的原型添加 say 函数Foo.prototype.say = function () &#123; console.log(&#x27;&#x27;);&#125; 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。 3.3 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说： foo instance of Foo的结果为true，因为foo.__proto__ === M.prototype为true。 foo instance of Objecet的结果也为true，为Foo.prototype.__proto__ === Object.prototype为true。 但我们不能轻易的说：foo 一定是 由Object创建的实例&#96;。这句话是错误的。我们来看下一个问题就明白了。 3.4 分析一个问题问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？ 分析：这就要用到原型的constructor属性了。 foo.__proto__.constructor === M的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 4 new 运算符 当new Foo()时发生了什么： 创建一个新的空对象实例。 将此空对象的隐式原型指向其构造函数的显示原型。 执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。 如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。","categories":[],"tags":[]},{"title":"JS set map","slug":"你真的了解ES6的Set和Map吗","date":"2022-04-24T01:43:08.447Z","updated":"2022-04-24T01:59:32.277Z","comments":true,"path":"2022/04/24/你真的了解ES6的Set和Map吗/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E7%9A%84Set%E5%92%8CMap%E5%90%97/","excerpt":"map&#x2F;set之前在学习 ES6 的时候，看到 Set 和 Map，不知道其应用场景有哪些，只觉得很多时候会用在数组去重和数据存储，后来慢慢才领悟到 Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构。 SetSet 本身是一个构造函数，用来生成 Set 数据结构。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。","text":"map&#x2F;set之前在学习 ES6 的时候，看到 Set 和 Map，不知道其应用场景有哪些，只觉得很多时候会用在数组去重和数据存储，后来慢慢才领悟到 Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构。 SetSet 本身是一个构造函数，用来生成 Set 数据结构。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。 123456const s = new Set()[2, 3, 5, 4, 5, 2, 2].forEach((x) =&gt; s.add(x))for (let i of s) &#123; console.log(i)&#125;// 2 3 5 4 Set 中的特殊值Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复 undefined 与 undefined 是恒等的，所以不重复 NaN 与 NaN 是不恒等的，但是在 Set 中认为 NaN 与 NaN 相等，所有只能存在一个，不重复。 Set 的属性： size：返回集合所包含元素的数量 12const items = new Set([1, 2, 3, 4, 5, 5, 5, 5])items.size // 5 Set 实例对象的方法 add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。 delete(value)：删除某个值，删除成功返回 true，否则返回 false。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 1234567891011s.add(1).add(2).add(2)// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2)s.has(2) // false 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回键值对的遍历器。 forEach()：使用回调函数遍历每个成员。 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。 12345678910111213141516171819202122let set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;])for (let item of set.keys()) &#123; console.log(item)&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item)&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item)&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] Array 和 Set 对比 Array 的 indexOf 方法比 Set 的 has 方法效率低下 Set 不含有重复值（可以利用这个特性实现对一个数组的去重） Set 通过 delete 方法删除某个值，而 Array 只能通过 splice。两者的使用方便程度前者更优 Array 的很多新方法 map、filter、some、every 等是 Set 没有的（但是通过两者可以互相转换来使用） Set 的应用1、Array.from 方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5])const array = Array.from(items) 2、数组去重 1234// 去除数组的重复成员;[...new Set(array)]Array.from(new Set(array)) 3、数组的 map 和 filter 方法也可以间接用于 Set 1234567let set = new Set([1, 2, 3])set = new Set([...set].map((x) =&gt; x * 2))// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5])set = new Set([...set].filter((x) =&gt; x % 2 == 0))// 返回Set结构：&#123;2, 4&#125; 4、实现并集 (Union)、交集 (Intersect) 和差集 1234567891011121314let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b])// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter((x) =&gt; b.has(x)))// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter((x) =&gt; !b.has(x)))// Set &#123;1&#125; weakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。 成员都是数组和类似数组的对象，若调用 add() 方法时传入了非数组和类似数组的对象的参数，就会抛出错误。 12const b = [1, 2, [1, 2]]new WeakSet(b) // Uncaught TypeError: Invalid value used in weak set 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。 WeakSet 不可迭代，因此不能被用在 for-of 等循环中。 WeakSet 没有 size 属性。 MapMap 中存储的是 key-value 形式的键值对, 其中的 key 和 value 可以是任何类型的, 即对象也可以作为 key。 Map 的出现，就是让各种类型的值都可以当作键。Map 提供的是 “值-值”的对应。 Map 和 Object 的区别 Object 对象有原型， 也就是说他有默认的 key 值在对象上面， 除非我们使用 Object.create(null)创建一个没有原型的对象； 在 Object 对象中， 只能把 String 和 Symbol 作为 key 值， 但是在 Map 中，key 值可以是任何基本类型(String, Number, Boolean, undefined, NaN….)，或者对象(Map, Set, Object, Function , Symbol , null….); 通过 Map 中的 size 属性， 可以很方便地获取到 Map 长度， 要获取 Object 的长度， 你只能手动计算 Map 的属性 size: 返回集合所包含元素的数量 1234const map = new Map()map.set(&#x27;foo&#x27;, ture)map.set(&#x27;bar&#x27;, false)map.size // 2 Map 对象的方法 set(key, val): 向 Map 中添加新元素 get(key): 通过键值查找特定的数值并返回 has(key): 判断 Map 对象中是否有 Key 所对应的值，有返回 true，否则返回 false delete(key): 通过键值从 Map 中移除对应的数据 clear(): 将这个 Map 中的所有元素删除 123456789const m = new Map()const o = &#123; p: &#x27;Hello World&#x27; &#125;m.set(o, &#x27;content&#x27;)m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 12345678910111213141516171819202122232425262728293031323334353637const map = new Map([ [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2],])for (let key of map.keys()) &#123; console.log(key)&#125;// &quot;a&quot;// &quot;b&quot;for (let value of map.values()) &#123; console.log(value)&#125;// 1// 2for (let item of map.entries()) &#123; console.log(item)&#125;// [&quot;a&quot;, 1]// [&quot;b&quot;, 2]// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value)&#125;// &quot;a&quot; 1// &quot;b&quot; 2// for...of...遍历map等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value)&#125;// &quot;a&quot; 1// &quot;b&quot; 2 数据类型转化Map 转为数组 12let map = new Map()let arr = [...map] 数组转为 Map 1Map: map = new Map(arr) Map 转为对象 1234let obj = &#123;&#125;for (let [k, v] of map) &#123; obj[k] = v&#125; 对象转为 Map 123for( let k of Object.keys(obj)）&#123; map.set(k,obj[k])&#125; Map的应用在一些 Admin 项目中我们通常都对个人信息进行展示，比如将如下信息展示到页面上。传统方法如下。 123456789101112131415161718192021222324&lt;div class=&quot;info-item&quot;&gt; &lt;span&gt;姓名&lt;/span&gt; &lt;span&gt;&#123;&#123;info.name&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;info-item&quot;&gt; &lt;span&gt;年龄&lt;/span&gt; &lt;span&gt;&#123;&#123;info.age&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;info-item&quot;&gt; &lt;span&gt;性别&lt;/span&gt; &lt;span&gt;&#123;&#123;info.sex&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;info-item&quot;&gt; &lt;span&gt;手机号&lt;/span&gt; &lt;span&gt;&#123;&#123;info.phone&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;info-item&quot;&gt; &lt;span&gt;家庭住址&lt;/span&gt; &lt;span&gt;&#123;&#123;info.address&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;info-item&quot;&gt; &lt;span&gt;家庭住址&lt;/span&gt; &lt;span&gt;&#123;&#123;info.duty&#125;&#125;&lt;/span&gt;&lt;/div&gt; js 代码 12345678910mounted() &#123; this.info = &#123; name: &#x27;jack&#x27;, sex: &#x27;男&#x27;, age: &#x27;28&#x27;, phone: &#x27;13888888888&#x27;, address: &#x27;广东省广州市&#x27;, duty: &#x27;总经理&#x27; &#125;&#125; 我们通过 Map 来改造，将我们需要显示的 label 和 value 存到我们的 Map 后渲染到页面，这样减少了大量的html代码 12345678&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;info-item&quot; v-for=&quot;[label, value] in infoMap&quot; :key=&quot;value&quot;&gt; &lt;span&gt;&#123;&#123;label&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;value&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js 代码 12345678910111213141516171819202122data: () =&gt; (&#123; info: &#123;&#125;, infoMap: &#123;&#125;&#125;),mounted () &#123; this.info = &#123; name: &#x27;jack&#x27;, sex: &#x27;男&#x27;, age: &#x27;28&#x27;, phone: &#x27;13888888888&#x27;, address: &#x27;广东省广州市&#x27;, duty: &#x27;总经理&#x27; &#125; const mapKeys = [&#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;年龄&#x27;, &#x27;电话&#x27;, &#x27;家庭地址&#x27;, &#x27;身份&#x27;] const result = new Map() let i = 0 for (const key in this.info) &#123; result.set(mapKeys[i], this.info[key]) i++ &#125; this.infoMap = result&#125; WeakMapWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。 只接受对象作为键名（null 除外），不接受其他类型的值作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的 不能遍历，方法有 get、set、has、delete 总结Set 是一种叫做集合的数据结构(ES6新增的) 成员唯一、无序且不重复 [value, value]，键值与键名是一致的（或者说只有键值，没有键名） 允许储存任何类型的唯一值，无论是原始值或者是对象引用 可以遍历，方法有：add、delete、has、clear WeakSet 成员都是对象 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏 不能遍历，方法有 add、delete、has Map 是一种类似于字典的数据结构，本质上是键值对的集合 可以遍历，可以跟各种数据格式转换 操作方法有:set、get、has、delete、clear WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的 不能遍历，方法有 get、set、has、delete","categories":[],"tags":[]},{"title":"vue.\\$nextTick","slug":"从 js 事件循环看 Vue.nextTick 的原理和执行机制","date":"2022-04-24T01:43:08.443Z","updated":"2022-04-24T01:59:31.559Z","comments":true,"path":"2022/04/24/从 js 事件循环看 Vue.nextTick 的原理和执行机制/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E4%BB%8E%20js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9C%8B%20Vue.nextTick%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"vue.$nextTickVue 的特点之一就是响应式，但是有些时候数据更新了，我们看到页面上的 DOM 并没有立刻更新。如果我们需要在 DOM 更新之后再执行一段代码时，可以借助 nextTick 实现。","text":"vue.$nextTickVue 的特点之一就是响应式，但是有些时候数据更新了，我们看到页面上的 DOM 并没有立刻更新。如果我们需要在 DOM 更新之后再执行一段代码时，可以借助 nextTick 实现。 我们先来看一个例子 1234567891011121314151617export default &#123; data() &#123; return &#123; msg: 0 &#125; &#125;, mounted() &#123; this.msg = 1 this.msg = 2 this.msg = 3 &#125;, watch: &#123; msg() &#123; console.log(this.msg) &#125; &#125;&#125; 这里的结果是只输出一个 3，而非依次输出 1，2，3。这是为什么呢？vue 的官方文档是这样解释的 Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。 假如有这样一种情况，mounted钩子函数下一个变量 a 的值会被++循环执行 1000 次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run。 如果这时候没有异步更新视图，那么每次++都会直接操作 DOM 一次，这是非常消耗性能的。 所以 Vue 实现了一个queue队列，在下一个 Tick（或者是当前 Tick 的微任务阶段）的时候会统一执行queue中Watcher的run。同时，拥有相同 id 的Watcher不会被重复加入到该queue中去，所以不会执行 1000 次Watcher的run。最终的结果是直接把 a 的值从 1 变成 1000，大大提升了性能。 在 vue 中，数据监测都是通过 Object.defineProperty 来重写里面的 set 和 get 方法实现的，vue 更新 DOM 是异步的，每当观察到数据变化时，vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来，等到下一次 event loop，将会把队列清空，进行 dom 更新。 想要了解 vue.nextTick 的执行机制，我们先来了解一下 javascript 的事件循环。 js 事件循环js 的任务队列分为同步任务和异步任务，所有的同步任务都是在主线程里执行的。异步任务可能会在 macrotask 或者 microtask 里面，异步任务进入 Event Table 并注册函数。当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 macro-task(宏任务)：每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。浏览器为了能够使得 js 内部(macro)task与 DOM 任务能够有序执行，会在一个(macro)task执行结束后，在下一个(macro)task执行开始前，对页面进行重新渲染。宏任务主要包含： script(整体代码) setTimeout &#x2F; setInterval setImmediate(Node.js 环境) I&#x2F;O UI render postMessage MessageChannel micro-task(微任务)：可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。microtask 主要包含： process.nextTick(Node.js 环境) Promise Async&#x2F;Await MutationObserver(html5 新特性) 小结 先执行主线程 遇到宏队列（macrotask）放到宏队列（macrotask） 遇到微队列（microtask）放到微队列（microtask） 主线程执行完毕 执行微队列（microtask），微队列（microtask）执行完毕 执行一次宏队列（macrotask）中的一个任务，执行完毕 执行微队列（microtask），执行完毕 依次循环。。。 Vue.nextTick 源码vue 是采用双向数据绑定的方法驱动数据更新的，虽然这样能避免直接操作 dom，提高了性能，但有时我们也不可避免需要操作 DOM，这时就该 Vue.nextTick(callback)出场了，它接受一个回调函数，在 DOM 更新完成后，这个回调函数就会被调用。不管是 vue.nextTick 还是 vue.prototype.$nextTick 都是直接用的 nextTick 这个闭包函数。 123456789101112131415export const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; ...&#125;)() 使用数组 callbacks 保存回调函数，pending 表示当前状态，使用函数 nextTickHandler 来执行回调队列。在该方法内，先通过 slice(0)保存了回调队列的一个副本，通过设置 callbacks.length &#x3D; 0 清空回调队列，最后使用循环执行在副本里的所有函数。 12345678910111213141516171819202122232425if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) if (isIOS) setTimeout(noop) &#125;&#125; else if (typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (isNative(MutationObserver) || MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125;&#125; else &#123; timeFunc = () =&gt; &#123; setTimeout(nextTickHandle, 0) &#125;&#125; 队列控制的最佳选择是 microtask，而 microtask 的最佳选择是 Promise。但如果当前环境不支持 Promise，就检测到浏览器是否支持 MO，是则创建一个文本节点，监听这个文本节点的改动事件，以此来触发 nextTickHandler（也就是 DOM 更新完毕回调）的执行。此外因为兼容性问题，vue 不得不做了 microtask 向 macrotask 的降级方案。 为让这个回调函数延迟执行，vue 优先用 promise 来实现，其次是 html5 的 MutationObserver，然后是 setTimeout。前两者属于 microtask，后一个属于 macrotask。下面来看最后一部分。 12345678910111213141516return function queueNextTick(cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) cb.call(ctx) if (_resolve) _resolve(ctx) &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 这就是我们真正调用的 nextTick 函数，在一个 event loop 内它会将调用 nextTick 的 cb 回调函数都放入 callbacks 中，pending 用于判断是否有队列正在执行回调，例如有可能在 nextTick 中还有一个 nextTick，此时就应该属于下一个循环了。最后几行代码是 promise 化，可以将 nextTick 按照 promise 方式去书写（暂且用的较少）。 应用场景场景一、点击按钮显示原本以 v-show &#x3D; false 隐藏起来的输入框，并获取焦点。 12345&lt;input id=&quot;keywords&quot; v-if=&quot;showit&quot;&gt;showInput()&#123; this.showit = true document.getElementById(&quot;keywords&quot;).focus() 以上的写法在第一个 tick 里，因为获取不到输入框，自然也获取不到焦点。如果我们改成以下的写法，在 DOM 更新后就可以获取到输入框焦点了。 1234567showsou()&#123; this.showit = true this.$nextTick(function () &#123; // DOM 更新了 document.getElementById(&quot;keywords&quot;).focus() &#125;)&#125; 场景二、获取元素属，点击获取元素宽度。 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p ref=&quot;myWidth&quot; v-if=&quot;showMe&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;getMyWidth&quot;&gt;获取p元素宽度&lt;/button&gt;&lt;/div&gt;getMyWidth() &#123; this.showMe = true; this.message = this.$refs.myWidth.offsetWidth; //报错 TypeError: this.$refs.myWidth is undefined this.$nextTick(()=&gt;&#123; //dom元素更新后执行，此时能拿到p元素的属性 this.message = this.$refs.myWidth.offsetWidth;&#125;)&#125;","categories":[],"tags":[]},{"title":"JS 高级函数","slug":"js高级函数","date":"2022-04-24T01:43:08.437Z","updated":"2022-04-24T01:59:31.592Z","comments":true,"path":"2022/04/24/js高级函数/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/","excerpt":"前言高阶函数是对其他函数进行操作的函数，可以将它们作为参数或通过返回它们。简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回。 例如Array.prototype.map，Array.prototype.filter，Array.prototype.reduce 都是一些高阶函数。","text":"前言高阶函数是对其他函数进行操作的函数，可以将它们作为参数或通过返回它们。简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回。 例如Array.prototype.map，Array.prototype.filter，Array.prototype.reduce 都是一些高阶函数。 尾调用和尾递归尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚。就是指某个函数的最后一步是调用另一个函数。 12345678function g(x) &#123; console.log(x)&#125;function f(x) &#123; return g(x)&#125;console.log(f(1))//上面代码中，函数f的最后一步是调用函数g，这就是尾调用。 上面代码中，函数 f 的最后一步是调用函数 g，这就是尾调用。尾调用不一定出现在函数尾部，只要是最后一步操作即可。 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生栈溢出错误。但是队伍尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出错误。 123456function factorial(n) &#123; if (n === 1) &#123; return 1 &#125; return n * factorial(n - 1)&#125; 上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用数据，复杂度为 O（n），如果改写成尾调用，只保留一个调用记录，复杂度为 O（1）。 123456function factor(n, total) &#123; if (n === 1) &#123; return total &#125; return factor(n - 1, n * total)&#125; 斐波拉切数列也是可以用于尾调用。 12345678910111213function Fibonacci(n) &#123; if (n &lt;= 1) &#123; return 1 &#125; return Fibonacci(n - 1) + Fibonacci(n - 2)&#125;//尾递归function Fibona(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) &#123; return ac2 &#125; return Fibona(n - 1, ac2, ac1 + ac2)&#125; 柯理化函数在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。所谓柯里化就是把具有较多参数的函数转换成具有较少参数的函数的过程。举个例子 1234567891011//普通函数function fn(a, b, c, d, e) &#123; console.log(a, b, c, d, e)&#125;//生成的柯里化函数let _fn = curry(fn)_fn(1, 2, 3, 4, 5) // print: 1,2,3,4,5_fn(1)(2)(3, 4, 5) // print: 1,2,3,4,5_fn(1, 2)(3, 4)(5) // print: 1,2,3,4,5_fn(1)(2)(3)(4)(5) // print: 1,2,3,4,5 柯理化函数的实现 1234567891011121314151617181920212223242526272829303132333435// 对求和函数做curry化let f1 = curry(add, 1, 2, 3)console.log(&#x27;复杂版&#x27;, f1()) // 6// 对求和函数做curry化let f2 = curry(add, 1, 2)console.log(&#x27;复杂版&#x27;, f2(3)) // 6// 对求和函数做curry化let f3 = curry(add)console.log(&#x27;复杂版&#x27;, f3(1, 2, 3)) // 6// 复杂版curry函数可以多次调用，如下：console.log(&#x27;复杂版&#x27;, f3(1)(2)(3)) // 6console.log(&#x27;复杂版&#x27;, f3(1, 2)(3)) // 6console.log(&#x27;复杂版&#x27;, f3(1)(2, 3)) // 6// 复杂版(每次可传入不定数量的参数，当所传参数总数不少于函数的形参总数时，才会执行)function curry(fn) &#123; // 闭包 // 缓存除函数fn之外的所有参数 let args = Array.prototype.slice.call(arguments, 1) return function () &#123; // 连接已缓存的老的参数和新传入的参数(即把每次传入的参数全部先保存下来，但是并不执行) let newArgs = args.concat(Array.from(arguments)) if (newArgs.length &lt; fn.length) &#123; // 累积的参数总数少于fn形参总数 // 递归传入fn和已累积的参数 return curry.call(this, fn, ...newArgs) &#125; else &#123; // 调用 return fn.apply(this, newArgs) &#125; &#125;&#125; 柯里化的用途柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。来看一个例子： 我们工作中会遇到各种需要通过正则检验的需求，比如校验电话号码、校验邮箱、校验身份证号、校验密码等， 这时我们会封装一个通用函数 checkByRegExp ,接收两个参数，校验的正则对象和待校验的字符串 123456function checkByRegExp(regExp, string) &#123; return regExp.text(string)&#125;checkByRegExp(/^1\\d&#123;10&#125;$/, &#x27;18642838455&#x27;) // 校验电话号码checkByRegExp(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, &#x27;test@163.com&#x27;) // 校验邮箱 我们每次进行校验的时候都需要输入一串正则，再校验同一类型的数据时，相同的正则我们需要写多次， 这就导致我们在使用的时候效率低下，并且由于 checkByRegExp 函数本身是一个工具函数并没有任何意义。此时，我们可以借助柯里化对 checkByRegExp 函数进行封装，以简化代码书写，提高代码可读性。 1234567891011121314//进行柯里化let _check = curry(checkByRegExp)//生成工具函数，验证电话号码let checkCellPhone = _check(/^1\\d&#123;10&#125;$/)//生成工具函数，验证邮箱let checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/)checkCellPhone(&#x27;18642838455&#x27;) // 校验电话号码checkCellPhone(&#x27;13109840560&#x27;) // 校验电话号码checkCellPhone(&#x27;13204061212&#x27;) // 校验电话号码checkEmail(&#x27;test@163.com&#x27;) // 校验邮箱checkEmail(&#x27;test@qq.com&#x27;) // 校验邮箱checkEmail(&#x27;test@gmail.com&#x27;) // 校验邮箱 柯里化函数参数 length函数 currying 的实现中，使用了 fn.length 来表示函数参数的个数，那 fn.length 表示函数的所有参数个数吗？并不是。 函数的 length 属性获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数，看下面的例子。 12345678910111213141516171819202122232425262728;((a, b, c) =&gt; &#123;&#125;) .length( // 3 (a, b, c = 3) =&gt; &#123;&#125; ) .length( // 2 (a, b = 2, c) =&gt; &#123;&#125; ) .length( // 1 (a = 1, b, c) =&gt; &#123;&#125; ) .length( // 0 (...args) =&gt; &#123;&#125; ).length// 0const fn = (...args) =&gt; &#123; console.log(args.length)&#125;fn(1, 2, 3)// 3 compose 函数compose 就是组合函数，将子函数串联起来执行，一个函数的输出结果是另一个函数的输入参数，一旦第一个函数开始执行，会像多米诺骨牌一样推导执行后续函数。 1234const greeting = (name) =&gt; `Hello $&#123;name&#125;`const toUpper = (str) =&gt; str.toUpperCase()toUpper(greeting(&#x27;Onion&#x27;)) // HELLO ONION compose 函数的特点 compose 接受函数作为参数，从右向左执行，返回类型函数 fn()全部参数传给最右边的函数，得到结果后传给倒数第二个，依次传递 compose 的实现 1234567891011121314151617var compose = function (...args) &#123; var len = args.length // args函数的个数 var count = len - 1 var result return function func(...args1) &#123; // func函数的args1参数枚举 result = args[count].call(this, args1) if (count &gt; 0) &#123; count-- return func.call(null, result) // result 上一个函数的返回结果 &#125; else &#123; //回复count初始状态 count = len - 1 return result &#125; &#125;&#125; 举个例子 1234var greeting = (name) =&gt; `Hello $&#123;name&#125;`var toUpper = (str) =&gt; str.toUpperCase()var fn = compose(toUpper, greeting)console.log(fn(&#x27;jack&#x27;)) 大家熟悉的 webpack 里面的 loader 执行顺序是从右到左，是因为 webpack 选择的是 compose 方式，从右到左依次执行 loader，每个 loader 是一个函数。 1rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;] 如上，webpack 使用了 style-loader 和 css-loader，它是先用 css-loader 加载.css 文件，然后 style-loader 将内部样式注入到我们的 html 页面。 webpack 里面的 compose 代码如下： 12345678const compose = (...fns) =&gt; &#123; return fns.reduce( (prevFn, nextFn) =&gt; &#123; return (value) =&gt; prevFn(nextFn(value)) &#125;, (value) =&gt; value )&#125;","categories":[],"tags":[]},{"title":"JS 继承","slug":"js继承的方法","date":"2022-04-24T01:43:08.433Z","updated":"2022-04-24T01:59:32.172Z","comments":true,"path":"2022/04/24/js继承的方法/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"JS 继承1、属性拷贝如果继承过来的成员是引用类型的话, 那么这个引用类型的成员在父对象和子对象之间是共享的, 也就是说修改了之后, 父子对象都会受到影响.","text":"JS 继承1、属性拷贝如果继承过来的成员是引用类型的话, 那么这个引用类型的成员在父对象和子对象之间是共享的, 也就是说修改了之后, 父子对象都会受到影响. 12345678910111213141516171819202122// 创建父对象var superObj = &#123; age: 25, friends: &#123; age: 33 &#125;, showName: function() &#123; console.log(this.name) &#125;&#125;// 创建需要继承的子对象var subObj = &#123;&#125;// 开始拷贝属性(使用for...in...循环)for (var i in superObj) &#123; subObj[i] = superObj[i]&#125;subObj.age = 20subObj.friends.age = 44console.log(subObj) // &#123;age:20,friends: &#123; age: 44 &#125;&#125;console.log(superObj) // &#123;age:25,friends: &#123; age: 44 &#125;&#125; 2、原型式继承 父构造函数的原型对象和子构造函数的原型对象上的成员有共享问题 只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员 1234567891011121314151617181920// 创建父构造函数function SuperClass(name) &#123; this.name = name this.showName = function() &#123; alert(this.name) &#125;&#125;// 设置父构造器的原型对象SuperClass.prototype.showAge = function() &#123; console.log(this.age)&#125;// 创建子构造函数function SubClass() &#123;&#125;// 设置子构造函数的原型对象实现继承SubClass.prototype = SuperClass.prototypevar child = new SubClass() 3、原型链继承不能给父构造函数传递参数，父子构造函数的原型对象之间有共享问题 1234567891011121314151617181920212223242526272829303132// 创建父构造函数function SuperClass() &#123; this.name = &#x27;liyajie&#x27; this.age = 25 this.showName = function() &#123; console.log(this.name) &#125;&#125;// 设置父构造函数的原型SuperClass.prototype.friends = [&#x27;小名&#x27;, &#x27;小强&#x27;]SuperClass.prototype.showAge = function() &#123; console.log(this.age)&#125;// 创建子构造函数function SubClass() &#123;&#125;// 实现继承SubClass.prototype = new SuperClass()// 修改子构造函数的原型的构造器属性SubClass.prototype.constructor = SubClassvar child = new SubClass()console.log(child.name) // liyajieconsole.log(child.age) // 25child.showName() // liyajiechild.showAge() // 25console.log(child.friends) // [&#x27;小名&#x27;,&#x27;小强&#x27;]// 当我们改变friends的时候, 父构造函数的原型对象的也会变化child.friends.push(&#x27;小王八&#x27;)console.log(child.friends) //[(&#x27;小名&#x27;, &#x27;小强&#x27;, &#x27;小王八&#x27;)]var father = new SuperClass()console.log(father.friends) //[(&#x27;小名&#x27;, &#x27;小强&#x27;, &#x27;小王八&#x27;)] 4、借用构造函数使用 call 和 apply 借用其他构造函数的成员, 可以解决给父构造函数传递参数的问题, 但是获取不到父构造函数原型上的成员.也不存在共享问题 1234567891011121314151617181920212223// 创建父构造函数function Person(name) &#123; this.name = name this.friends = [&#x27;小王&#x27;, &#x27;小强&#x27;] this.showName = function() &#123; console.log(this.name) &#125;&#125;Person.prototype.showAge = function() &#123; console.log(this.age)&#125;// 创建子构造函数function Student(name) &#123; // 使用call借用Person的构造函数 Person.call(this, name)&#125;// 测试是否有了 Person 的成员var stu = new Student(&#x27;Li&#x27;)stu.showName() // Liconsole.log(stu.friends) // [&#x27;小王&#x27;,&#x27;小强&#x27;]stu.showAge() // stu.showAge is not a function 5、组合继承 (借用构造函数 + 原型式继承) 解决了父构造函数的属性继承到了子构造函数的实例对象上了, 并且继承了父构造函数原型对象上的成员 解决了给父构造函数传递参数问题 存在共享的问题 12345678910111213141516171819// 创建父构造函数function Person(name, age) &#123; this.name = name this.age = age this.showName = function() &#123; console.log(this.name) &#125;&#125;// 设置父构造函数的原型对象Person.prototype.showAge = function() &#123; console.log(this.age)&#125;// 创建子构造函数function Student(name) &#123; Person.call(this, name)&#125;// 设置继承Student.prototype = Person.prototypeStudent.prototype.constructor = Student 6、借用构造函数 + 深拷贝这样就将 Person 的原型对象上的成员拷贝到了 Student 的原型上了, 这种方式没有属性共享的问题. 12345678910111213141516function Person(name,age)&#123; this.name = name; this.age = age; this.showName = function()&#123; console.log(this.name); &#125;&#125;Person.prototype.friends = [&#x27;小王&#x27;,&#x27;小强&#x27;,&#x27;小王八&#x27;];function Student(name,25)&#123; // 借用构造函数(Person) Person.call(this,name,25);&#125;// 使用深拷贝实现继承deepCopy(Student.prototype,Person.prototype);Student.prototype.constructor = Student;","categories":[],"tags":[]},{"title":"JS 算法","slug":"js算法经典案例","date":"2022-04-24T01:43:08.429Z","updated":"2022-04-24T01:59:31.865Z","comments":true,"path":"2022/04/24/js算法经典案例/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/","excerpt":"递归算法递归算法，是将问题转化为规模缩小的同类问题的子问题，每一个子问题都用一个同样的算法去解决。一个递归算法就是函数调用自身去解决它的子问题。 递归算法的特点： 在函数过程中调用自身。 必须有一个明确的条件判断递归的结束，既递归出口。 递归算法的步骤 假设递归函数已经写好 寻找递推关系 将递推关系的结构转换为递归体 将临界条件加入到递归体中","text":"递归算法递归算法，是将问题转化为规模缩小的同类问题的子问题，每一个子问题都用一个同样的算法去解决。一个递归算法就是函数调用自身去解决它的子问题。 递归算法的特点： 在函数过程中调用自身。 必须有一个明确的条件判断递归的结束，既递归出口。 递归算法的步骤 假设递归函数已经写好 寻找递推关系 将递推关系的结构转换为递归体 将临界条件加入到递归体中 阶乘 阶乘，定义为 n！，表示从 1 到 n 的整数的乘积。 方法 1： for 循环 12345678910const factorial = (n) =&gt; &#123; if (n &lt;= 1) return 1 let total = 1 for (let i = n; i &gt; 1; i--) &#123; total = total * i &#125; return total&#125;console.log(factorial(5)) // 120 方法 2：递归 123456const factorial = (n) =&gt; &#123; if (n &lt;= 1) return 1 return n * factorial(n - 1)&#125;console.log(factorial(5)) // 120 这种递归方法写起来很方便，但是也存在缺点，就是会保存很多个调用帧，比如上边的 factorial(5)，这个方法要执行 5 次，才能返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出。为了解决这个问题，我们可以使用尾递归。 当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。 123456const factorial = (n, total = 1) =&gt; &#123; if (n &lt;= 1) return total return factorial(n - 1, total * n)&#125;console.log(factorial(5)) // 120 这样，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。只需要一个帧即可。 斐波那契数列斐波那契数列从第三项开始，每一项都等于前两项之和。0, 1, 1, 2, 3, 5, 8, 13… 方法 1: 非递归，时间复杂度为 O(n) 123456789101112function fib(n) &#123; let a = 0 let b = 1 let c = a + b for (let i = 3; i &lt; n; i++) &#123; a = b b = c c = a + b &#125; return c&#125;console.log(fib(10)) // 34 方法 2：递归。时间复杂度为 O(2^n) 12345function fib(n) &#123; if (n === 1 || n === 2) return n - 1 return fib(n - 1) + fib(n - 2)&#125;console.log(fib(10)) // 34 方法 3：尾递归 1234567function fib(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) &#123; return ac2 &#125; return fib(n - 1, ac2, ac1 + ac2)&#125;console.log(fib(10)) // 34 爬楼梯问题描述：一共 10 级楼梯，每次可以走一步或两步，求一共多少种走法。 要想走到 N(N&#x3D;10)级,可以分为 2 种情况。 从 n-2 级迈两步 从 n-1 级迈一步 那么对于 n-2 和 n-1 的情况也是各自分为两种，以此类推。那么走法的和就是 n-2 的走法和 n-1 的走法之和。 12345function climbStairs(n) &#123; if (n == 1) return 1 if (n == 2) return 2 return climbStairs(n - 1) + climbStairs(n - 2)&#125; 最大公约数方法 1：短除法 123456789function gcd(a, b) &#123; var result = 1 for (var i = 1; i &lt;= a &amp;&amp; i &lt;= b; i++) &#123; if (a % i == 0 &amp;&amp; b % i == 0) &#123; result = i &#125; &#125; return result&#125; 方法 2：辗转相除法 123456function gcd(m, n) &#123; var a = Math.max(m, n) var b = Math.min(m, n) if (a % b == 0) return b return gcd(b, a % b)&#125; 二分法排序二分法排序的原理如下 取数组一个随机索引值作为比较值 数组每一项与比较值做大小比较，比之小的放在左边数组，比之大的放在右边数组 依次递归直到执行的数组长度为 1 concat() 方法连接两个或多个数组 1234567891011121314151617function quickSort(arr) &#123; if (arr.length &lt;= 1) return arr var leftArr = [] var rightArr = [] var pivot = Math.random(arr.length / 2) var baseNum = arr.splice(pivot, 1) arr.forEach(function (num) &#123; if (num &lt; baseNum) &#123; leftArr.push(num) &#125; else &#123; rightArr.push(num) &#125; &#125;) return quickSort(leftArr).concat(baseNum, quickSort(rightArr))&#125;console.log(quickSort([1, 10, 2, 5, 9, 12, 5, 2, 3]))","categories":[],"tags":[]},{"title":"JS 数组操作","slug":"js数组操作","date":"2022-04-24T01:43:08.425Z","updated":"2022-04-24T01:59:32.054Z","comments":true,"path":"2022/04/24/js数组操作/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","excerpt":"js 数组操作在开发中，数组的使用场景非常多，平日中也涉及到很多数组相关操作，对一些常见的操作方法进行总结和收藏，在开发中就能信手拈来，大大提高开发效率。 随机排序1、生成随机数 遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素","text":"js 数组操作在开发中，数组的使用场景非常多，平日中也涉及到很多数组相关操作，对一些常见的操作方法进行总结和收藏，在开发中就能信手拈来，大大提高开发效率。 随机排序1、生成随机数 遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素 123456789101112131415function randomSort1(arr) &#123; for (let i = 0, l = arr.length; i &lt; l; i++) &#123; let rc = parseInt(Math.random() * l) // 让当前循环的数组元素和随机出来的数组元素交换位置 const empty = arr[i] arr[i] = arr[rc] arr[rc] = empty &#125; return arr&#125;var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]// 下面两次的结果肯定是不一样的；console.log(randomSort1(arr1))console.log(randomSort1(arr1)) 2、生成新数组 申明一个新的空数组,利用 while 循环，如果数组长度大于 0，就继续循环； 每次循环都随机一个在数组长度范围内的数，将随机数位置上的元素 push 到新数组里， 并利用 splice（对 splice 不太理解的同学可以看这里）截取出随机数位置上的元素，同时也修改了原始数组的长度； 12345678910111213function randomSort2(arr) &#123; var mixedArr = [] while (arr.length &gt; 0) &#123; let rc = parseInt(Math.random() * arr.length) mixedArr.push(arr[rc]) arr.splice(rc, 1) &#125; return mixedArr&#125;// 例子var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(randomSort2(arr1)) 3、 arr.sort 如果 compareFunction(a, b)的返回值 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b)的返回值 等于 0 ，那么 a 和 b 的相对位置不变； 如果 compareFunction(a, b)的返回值 大于 0 ，那么 b 会被排列到 a 之前； 12345678910function randomSort3(arr) &#123; arr.sort(function (a, b) &#123; return Math.random() - 0.5 &#125;) return arr&#125;// 例子var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(randomSort3(arr1)) 数组对象排序1、单个属性排序 123456789101112131415function compare(property) &#123; return function (a, b) &#123; let value1 = a[property] let value2 = b[property] return value1 - value2 &#125;&#125;let arr = [ &#123; name: &#x27;zopp&#x27;, age: 10 &#125;, &#123; name: &#x27;gpp&#x27;, age: 18 &#125;, &#123; name: &#x27;yjj&#x27;, age: 8 &#125;,]console.log(arr.sort(compare(&#x27;age&#x27;))) 2、多个属性排序 123456789101112131415161718function by(name, minor) &#123; return function(o, p) &#123; let a, b if (o &amp;&amp; p &amp;&amp; typeof o === &#x27;object&#x27; &amp;&amp; typeof p === &#x27;object&#x27;) &#123; a = o[name] b = p[name] if (a === b) &#123; return typeof minor === &#x27;function&#x27; ? minor(o, p) : 0 &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1 &#125; return typeof a &lt; typeof b ? -1 : 1 &#125; else &#123; thro(&#x27;error&#x27;) &#125; &#125;&#125;, 数组扁平化1、调用 ES6 中的 flat 方法 123ary = arr.flat(Infinity)console.log([1, [2, 3, [4, 5, [6, 7]]]].flat(Infinity)) 2、普通递归 123456789101112131415let result = []let flatten = function (arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let item = arr[i] if (Array.isArray(arr[i])) &#123; flatten(item) &#125; else &#123; result.push(item) &#125; &#125; return result&#125;let arr = [1, 2, [3, 4], [5, [6, 7]]]console.log(flatten(arr)) 3、利用 reduce 函数迭代 12345678function flatten(arr) &#123; return arr.reduce((pre, cur) =&gt; &#123; return pre.concat(Array.isArray(cur) ? flatten(cur) : cur) &#125;, [])&#125;let arr = [1, 2, [3, 4], [5, [6, 7]]]console.log(flatten(arr)) 4、扩展运算符 123456789function flatten(arr) &#123; while (arr.some((item) =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125;let arr = [1, 2, [3, 4], [5, [6, 7]]]console.log(flatten(arr)) 数组去重1、利用数组的 indexOf 下标属性来查询 12345678910function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 2、先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。 1234567891011function unique(arr) &#123; var formArr = arr.sort() var newArr = [formArr[0]] for (let i = 1; i &lt; formArr.length; i++) &#123; if (formArr[i] !== formArr[i - 1]) &#123; newArr.push(formArr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 3、利用对象属性存在的特性，如果没有该属性则存入新数组。 123456789101112function unique(arr) &#123; var obj = &#123;&#125; var newArr = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; obj[arr[i]] = 1 newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 4、利用数组原型对象上的 includes 方法。 12345678910function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (!newArr.includes(arr[i])) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 5、利用数组原型对象上的 filter 和 includes 方法。 12345678function unique(arr) &#123; var newArr = [] newArr = arr.filter(function (item) &#123; return newArr.includes(item) ? &#x27;&#x27; : newArr.push(item) &#125;) return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 6、利用 ES6 的 set 方法。 1234function unique(arr) &#123; return Array.from(new Set(arr)) // 利用Array.from将Set结构转换成数组&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 根据属性去重方法一 1234function unique(arr) &#123; const res = new Map() return arr.filter((item) =&gt; !res.has(item.productName) &amp;&amp; res.set(item.productName, 1))&#125; 方法二 12345678910function unique(arr) &#123; let result = &#123;&#125; let obj = &#123;&#125; for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i].key]) &#123; result.push(arr[i]) obj[arr[i].key] = true &#125; &#125;&#125; 交集&#x2F;并集&#x2F;差集1、includes 方法结合 filter 方法 1234567891011121314let a = [1, 2, 3]let b = [2, 4, 5]// 并集let union = a.concat(b.filter((v) =&gt; !a.includes(v)))// [1,2,3,4,5]// 交集let intersection = a.filter((v) =&gt; b.includes(v))// [2]// 差集let difference = a.concat(b).filter((v) =&gt; !a.includes(v) || !b.includes(v))// [1,3,4,5] 2、ES6 的 Set 数据结构 1234567891011121314let a = new Set([1, 2, 3])let b = new Set([2, 4, 5])// 并集let union = new Set([...a, ...b])// Set &#123;1, 2, 3, 4,5&#125;// 交集let intersect = new Set([...a].filter((x) =&gt; b.has(x)))// set &#123;2&#125;// 差集let difference = new Set([...a].filter((x) =&gt; !b.has(x)))// Set &#123;1, 3, 4, 5&#125; 数组求和1、万能的 for 循环 123456789function sum(arr) &#123; var s = 0 for (var i = arr.length - 1; i &gt;= 0; i--) &#123; s += arr[i] &#125; return s&#125;sum([1, 2, 3, 4, 5]) // 15 2、递归方法 123456789101112function sum(arr) &#123; var len = arr.length if (len == 0) &#123; return 0 &#125; else if (len == 1) &#123; return arr[0] &#125; else &#123; return arr[0] + sum(arr.slice(1)) &#125;&#125;sum([1, 2, 3, 4, 5]) // 15 3、ES6 的 reduce 方法 1234567function sum(arr) &#123; return arr.reduce(function (prev, curr) &#123; return prev + curr &#125;, 0)&#125;sum([1, 2, 3, 4, 5]) // 15 类数组转化1、Array 的 slice 方法 1let arr = Array.prototype.slice.call(arguments) 2、ES6 的 Array.from() 1let arr = Array.from(arguments) 3、扩展运算符… 1let arr = [...arguments] 数组上下移动123456789101112131415161718function swapItems(arr, index1, index2) &#123; arr[index1] = arr.splice(index2, 1, arr[index1])[0] return arr&#125;function up(arr, index) &#123; if (index === 0) &#123; return &#125; this.swapItems(arr, index, index - 1)&#125;function down(arr, index) &#123; if (index === this.list.length - 1) &#123; return &#125; this.swapItems(arr, index, index + 1)&#125; 数组转化为树形结构将如下数据转化为树状结构 123456789101112131415161718192021222324252627282930313233343536let arr = [ &#123; id: 1, name: &#x27;1&#x27;, pid: 0, &#125;, &#123; id: 2, name: &#x27;1-1&#x27;, pid: 1, &#125;, &#123; id: 3, name: &#x27;1-1-1&#x27;, pid: 2, &#125;, &#123; id: 4, name: &#x27;1-2&#x27;, pid: 1, &#125;, &#123; id: 5, name: &#x27;1-2-2&#x27;, pid: 4, &#125;, &#123; id: 6, name: &#x27;1-1-1-1&#x27;, pid: 3, &#125;, &#123; id: 7, name: &#x27;2&#x27;, &#125;,] 实现方法 123456789101112131415161718function toTree(data, parentId = 0) &#123; var itemArr = [] for (var i = 0; i &lt; data.length; i++) &#123; var node = data[i] if (node.pid === parentId) &#123; var newNode = &#123; ...node, name: node.name, id: node.id, children: toTree(data, node.id), &#125; itemArr.push(newNode) &#125; &#125; return itemArr&#125;console.log(toTree(arr))","categories":[],"tags":[]},{"title":"JS 数组操作","slug":"js数据类型总结","date":"2022-04-24T01:43:08.420Z","updated":"2022-04-24T01:59:32.077Z","comments":true,"path":"2022/04/24/js数据类型总结/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"JS 数据类型JavaScript 是弱类型语言，而且 JavaScript 声明变量的时候并没有预先确定的类型，变量的类型就是其值的类型，也就是说变量当前的类型由其值所决定,夸张点说上一秒种的 String，下一秒可能就是个 Number 类型了，这个过程可能就进行了某些操作发生了强制类型转换。 js 数据分为两种类型：原始数据类型和引用数据类型。 基本数据类型有：string、number、boolean、undefined、null 和 symbol（符号） 引用数据类型有：Object、Function、Date、RegExp 等。","text":"JS 数据类型JavaScript 是弱类型语言，而且 JavaScript 声明变量的时候并没有预先确定的类型，变量的类型就是其值的类型，也就是说变量当前的类型由其值所决定,夸张点说上一秒种的 String，下一秒可能就是个 Number 类型了，这个过程可能就进行了某些操作发生了强制类型转换。 js 数据分为两种类型：原始数据类型和引用数据类型。 基本数据类型有：string、number、boolean、undefined、null 和 symbol（符号） 引用数据类型有：Object、Function、Date、RegExp 等。 栈和堆堆和栈的概念存在于数据结构中和操作系统内存中。 在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。 在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。 基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 基本数据类型的特点 基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值； 基本数据类型的值是不可变的，任何方法都无法改变一个基本数据类型的值 123456let name = &#x27;zhangsan&#x27;name.substr()console.log(name) // 输出：zhangsanlet age = &#x27;firstblood&#x27;age.toUpperCase()console.log(age) // 输出：firstblood substr()和 toUpperCase()方法后返回的是一个新的字符串，跟原来定义的变量 name 并没有什么关系。 基本数据类型不可以添加属性和方法 1234567let user = &#x27;zhangsan&#x27;user.age = 18user.method = function() &#123; console.log(&#x27;12345&#x27;)&#125;console.log(user.age) // 输出：undefinedconsole.log(user.method) // 输出：undefined 基本数据类型的赋值是简单的赋值(不影响原变量的值) 12345let a = 18let b = aa++console.log(a) // 输出：19console.log(b) // 输出：18 基本数据类型的比较是值的比较 123var a = &#x27;&#123;&#125;&#x27;var b = &#x27;&#123;&#125;&#x27;console.log(a === b) // 输出：true 基本类型的值在内存中占据固定大小的空间，被保存在栈内存中 引用数据类型引用类型是存放在堆内存中的对象，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存。 12345var obj1 = new Object()var obj2 = obj1obj2.name = &#x27;我有名字了&#x27;console.log(obj1.name) // 我有名字了 数据类型转换转为字符串1、toString()方法：注意，不可以转 null 和 underfined2、String()方法：都能转 123456789let ab = &#x27;zhangsan&#x27;let bc = nulllet cd = undefinedconsole.log(ab.toString()) // 输出：zhangsanconsole.log(bc.toString()) // error 报错console.log(cd.toString()) // error 报错console.log(String(ab)) // 输出：zhangsanconsole.log(String(bc)) // 输出：nullconsole.log(String(cd)) // 输出：undefined 3、隐式转换：num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 123var a = truevar str = a + &#x27;&#x27;console.log(&#x27;str&#x27;) 转为数值类型1、Number()：可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回 NaN 2、parseInt()&#x2F;parseFloat():parseFloat()把字符串转换成浮点数,parseFloat()和 parseInt 非常相似，不同之处在与 parseFloat 会解析第一个. 遇到第二个.或者非数字结束如果解析的内容里只有整数，解析成整数。 123456var a = &#x27;12.3px&#x27;console.log(parseInt(a)) // 12console.log(parseFloat(a)) // 12.3let b = &#x27;abc2.3&#x27;console.log(parseInt(b)) //NANconsole.log(parseFloat(b)) //NAN 3、隐式转换 123var str = &#x27;123&#x27;var num = str - 1console.log(num) // 122 4、isNaN()函数用于判断是否是一个非数字类型，如果传入的参数是一个非数字类型，那么返回 true，否则返回 false 转换为 Boolean()除了 0 ‘’(空字符串) null undefined NaN 会转换成 false 其它都会转换成 true 判断 JS 数据类型1、typeof()函数对于原始数据类型，我们可以使用 typeof()函数来判断他的数据类型。但他是没法用来区分引用数据类型的，因为所有的引用数据类型都会返回”object”。 12345678910typeof &#x27;seymoe&#x27; // &#x27;string&#x27;typeof true // &#x27;boolean&#x27;typeof 10 // &#x27;number&#x27;typeof Symbol() // &#x27;symbol&#x27;typeof null // &#x27;object&#x27; 无法判定是否为 nulltypeof undefined // &#x27;undefined&#x27;typeof &#123;&#125; // &#x27;object&#x27;typeof [] // &#x27;object&#x27;typeof (() =&gt; &#123;&#125;) // &#x27;function&#x27; 2、instanceof对于引用类型我们使用 instanceof 来进行类型判断。 1234var obj = &#123;&#125;obj instanceof Object //truevar arr = []arr instanceof Array //true 3、Object.prototype.toString.call()在 javascript 高级程序设计中提供了另一种方法，可以通用的来判断原始数据类型和引用数据类型 12345var arr = []Object.prototype.toString.call(arr) == &#x27;[object Array]&#x27; //truevar func = function() &#123;&#125;Object.prototype.toString.call(func) == &#x27;[object Function]&#x27; //true 4、constructorconstructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。 1234567var aa = [1, 2]console.log(aa.constructor === Array) //trueconsole.log(aa.constructor === RegExp) //falseconsole.log((1).constructor === Number) //truevar reg = /^$/console.log(reg.constructor === RegExp) //trueconsole.log(reg.constructor === Object) //false javascript 的内置方法 toString()方法返回一个表示该对象的字符串。 valueOf()方法返回指定对象的原始值。 123456789101112131415161718var str = new String(&#x27;123&#x27;)console.log(str.valueOf()) //123var num = new Number(123)console.log(num.valueOf()) //123var date = new Date()console.log(date.valueOf()) //1526990889729var bool = new Boolean(&#x27;123&#x27;)console.log(bool.valueOf()) //truevar obj = new Object(&#123; valueOf: () =&gt; &#123; return 1 &#125;&#125;)console.log(obj.valueOf()) //1 valueOf() 和 toString()在特定的场合下会自行调用。 包装对象（wrapper object）先来看一个例子 123let name = &#x27;marko&#x27;console.log(typeof name) // &quot;string&quot;console.log(name.toUpperCase()) // &quot;MARKO&quot; name 类型是 string，属于基本类型，所以它没有属性和方法，但是在这个例子中，我们调用了一个 toUpperCase()方法，它不会抛出错误，还返回了对象的变量值。 原因是基本类型的值被临时转换或强制转换为对象，因此 name 变量的行为类似于对象。name.toUpperCase()在幕后看起来如下： 1console.log(new String(name).toUpperCase()) // &quot;MARKO&quot; 除 null 和 undefined 之外的每个基本类型都有自己包装对象。也就是：String，Number，Boolean，Symbol 和 BigInt。","categories":[],"tags":[]},{"title":"JS 执行机制","slug":"js执行机制及eventLoop","date":"2022-04-24T01:43:08.415Z","updated":"2022-04-24T01:59:31.922Z","comments":true,"path":"2022/04/24/js执行机制及eventLoop/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8AeventLoop/","excerpt":"JS 执行机制js 是一门单线程语言。所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。 js 引擎有一个主线程（main thread）用来解释和执行 js 程序，还存在其他的线程。例如：处理 ajax 请求的线程、处理 DOM 事件的线程、定时器线程、读写文件的线程(例如在 node.js 中)等等。这些线程可能存在于 js 引擎之内，也可能存在于 js 引擎之外，在此我们不做区分。不妨叫它们工作线程。 为什么是 js 是单线程的呢？这是因为 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。为了避免 DOM 渲染的冲突，可以采用单线程或者死锁，JavaScript 采用了单线程方案。 但单线程有一个问题：如果任务队列里有一个任务耗时很长，导致这个任务后面的任务一直排队等待，就会发生页面卡死，严重影响用户体验。","text":"JS 执行机制js 是一门单线程语言。所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。 js 引擎有一个主线程（main thread）用来解释和执行 js 程序，还存在其他的线程。例如：处理 ajax 请求的线程、处理 DOM 事件的线程、定时器线程、读写文件的线程(例如在 node.js 中)等等。这些线程可能存在于 js 引擎之内，也可能存在于 js 引擎之外，在此我们不做区分。不妨叫它们工作线程。 为什么是 js 是单线程的呢？这是因为 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。为了避免 DOM 渲染的冲突，可以采用单线程或者死锁，JavaScript 采用了单线程方案。 但单线程有一个问题：如果任务队列里有一个任务耗时很长，导致这个任务后面的任务一直排队等待，就会发生页面卡死，严重影响用户体验。 JS 执行上下文当代码运行时，会产生一个对应的执行环境，在这个环境中，所有变量会被事先提出来（变量提升），有的直接赋值，有的为默认值 undefined，代码从上往下开始执行，就叫做执行上下文。 例子 1:变量提升 123456789101112foo // undefinedvar foo = function() &#123; console.log(&#x27;foo1&#x27;)&#125;foo() // foo1，foo赋值var foo = function() &#123; console.log(&#x27;foo2&#x27;)&#125;foo() // foo2，foo重新赋值 例子 2：函数提升 123456789101112foo() // foo2function foo() &#123; console.log(&#x27;foo1&#x27;)&#125;foo() // foo2function foo() &#123; console.log(&#x27;foo2&#x27;)&#125;foo() // foo2 例子 3：声明优先级，函数 &gt; 变量 123456789101112foo() // foo2var foo = function() &#123; console.log(&#x27;foo1&#x27;)&#125;foo() // foo1，foo重新赋值function foo() &#123; console.log(&#x27;foo2&#x27;)&#125;foo() // foo1 执行上下文类型。 全局执行上下文 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。 执行上下文特点 单线程，在主进程上运行 同步执行，从上往下按顺序执行 全局上下文只有一个，浏览器关闭时会被弹出栈 函数的执行上下文没有数目限制 函数每被调用一次，都会产生一个新的执行上下文环境 执行栈JavaScript 将任务的执行模式分为两种：同步和异步。同步任务都在主线程（这里的主线程就是 JavaScript 引擎线程）上执行，会形成一个 调用栈 ，又称执行栈。 当JavaScript代码被运行的时候，会创建一个全局上下文，并push到当前执行栈。之后当发生函数调用的时候，引擎会为函数创建一个函数执行上下文并push到栈顶。引擎会先执行调用栈顶部的函数，当函数执行完成后，当前函数的执行上下文会被移除当前执行栈。并移动到下一个上下文。 除了主线程外，还有一个任务队列（也称消息队列），用于管理异步任务的事件回调 ，在调用栈的任务执行完毕之后，系统会检查任务队列，看是否有可以执行的异步任务。 其实这是一个压栈出栈的过程——执行栈。 1234567891011121314var // 1.进入全局上下文环境 a = 10, fn, bar = function(x) &#123; var b = 20 fn(x + b) // 3.进入fn上下文环境 &#125;fn = function(y) &#123; var c = 20 console.log(y + c)&#125;bar(5) // 2.进入bar上下文环境 执行上下文生命周期 创建阶段 生成变量对 建立作用域 确定 this 指向 执行阶段 变量赋值 函数引用 执行其他代码 销毁阶段 执行完毕出栈，等待回收被销毁 栈溢出在我们执行 JavaScript 代码的时候，有时会出现栈溢出的情况： 1Uncaught RangeError: Maximum call stack size exceeded 这是一个典型的栈溢出。调用栈是用来管理执行上下文的一种数据结构，它是有大小的，当入栈的上下文过多的时候，它就会报栈溢出。比如 12345function add() &#123; return 1 + add()&#125;add() add 函数不断的递归，不断的入栈，调用栈的容量有限，它就溢出了，所以，我们日常的开发中，一定要注意此类代码的出现。 javascript 事件循环 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。浏览器为了能够使得 js 内部(macro)task与 DOM 任务能够有序执行，会在一个(macro)task执行结束后，在下一个(macro)task执行开始前，对页面进行重新渲染。宏任务主要包含： script(整体代码) setTimeout &#x2F; setInterval setImmediate(Node.js 环境) I&#x2F;O UI render postMessage MessageChannel micro-task(微任务)：可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。microtask 主要包含： process.nextTick(Node.js 环境) Promise Async&#x2F;Await MutationObserver(html5 新特性) 总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。 举个例子我们来分析一段较复杂的代码，看看你是否真的掌握了 js 的执行机制： 1234567891011121314151617181920212223242526272829303132333435363738console.log(&#x27;1&#x27;)setTimeout(function() &#123; console.log(&#x27;2&#x27;) process.nextTick(function() &#123; console.log(&#x27;3&#x27;) &#125;) new Promise(function(resolve) &#123; console.log(&#x27;4&#x27;) resolve() &#125;).then(function() &#123; console.log(&#x27;5&#x27;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&#x27;6&#x27;)&#125;)new Promise(function(resolve) &#123; console.log(&#x27;7&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;8&#x27;)&#125;)setTimeout(function() &#123; console.log(&#x27;9&#x27;) process.nextTick(function() &#123; console.log(&#x27;10&#x27;) &#125;) new Promise(function(resolve) &#123; console.log(&#x27;11&#x27;) resolve() &#125;).then(function() &#123; console.log(&#x27;12&#x27;) &#125;)&#125;)// 1,7,8,2,4,5,6,3,9,11,12,10 再来一段 1234567891011121314151617181920212223242526272829async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)async1()new Promise(function(resolve) &#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;)// script start// async1 start// async2// promise1// script end// async1 end// promise2// setTimeout node 的事件循环 timers 定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。 pending callbacks 待定回调：执行延迟到下一个循环迭代的 I&#x2F;O 回调。 idle, prepare：仅系统内部使用。 poll 轮询：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。 check 检测：setImmediate() 回调函数在这里执行。 close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on(‘close’, …)。 微任务和宏任务在 Node 的执行顺序Node 10 以前： 执行完一个阶段的所有任务 执行完 nextTick 队列里面的内容 然后执行完微任务队列的内容 Node 11 以后： 和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。 node 环境和浏览器的区别1、全局环境下 this 的指向 node 中 this 指向 global 浏览器中 this 指向 window 这就是为什么 underscore 中一上来就定义了一 root； 浏览器中的 window 下封装了不少的 API 比如 alert 、document、location、history 等等还有很多, 我们就不能在 node 环境中 xxx();或 window.xxx();了。因为这些 API 是浏览器级别的封装，存 javascript 中是没有的。当然 node 中也提供了不少 node 特有的 API。 2、js 引擎 在浏览器中不同的浏览器厂商提供了不同的浏览器内核，浏览器依赖这些内核解释折我们编写的 js。但是考虑到不同内核的少量差异，我们需要对应兼容性好在有一些优秀的库帮助我们处理这个问题。比如 jquery、underscore 等等。 nodejs 是基于 Chrome’s JavaScript runtime，也就是说，实际上它是对 GoogleV8 引擎（应用于 Google Chrome 浏览器)进行了封装。V8 引 擎执行 Javascript 的速度非常快，性能非常好。 3、DOM 操作 浏览器中的 js 大多数情况下是在直接或间接（一些虚拟 DOM 的库和框架）的操作 DOM。因为浏览器中的代码主要是在表现层工作。 node 是一门服务端技术。没有一个前台页面，所以我们不会再 node 中操作 DOM。 4、I&#x2F;O 读写与浏览器不同，我们需要像其他服务端技术一样读写文件，nodejs 提供了比较方便的组件。而浏览器（确保兼容性的）想在页面中直接打开一个本地的图片就麻烦了好多（别和我说这还不简单，相对路径。。。。。。试试就知道了要么找个库要么二进制流，要么上传上去有了网络地址在显示。不然人家为什么要搞一个 js 库呢），而这一切 node 都用一个组件搞定了。 5、模块加载 javascript 有个特点，就是原生没提供包引用的 API 一次性把要加载的东西全执行一遍，这里就要看各位闭包的功力了。所用东西都在一起，没有分而治之，搞的特别没有逻辑性和复用性。如果页面简单或网站当然我们可以通过一些 AMD、CMD 的 js 库（比如 requireJS 和 seaJS）搞定事实上很多大型网站都是这么干的。 nodeJS 中提供了 CMD 的模块加载的 API，如果你用过 seaJS，那么应该上手很快。node 还提供了 npm 这种包管理工具，能更有效方便的管理我们饮用的库 参考文献浏览器与Node的事件循环(Event Loop)有何区别?","categories":[],"tags":[]},{"title":"JS 异步处理","slug":"js异步处理","date":"2022-04-24T01:43:08.400Z","updated":"2022-04-24T01:59:32.124Z","comments":true,"path":"2022/04/24/js异步处理/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/","excerpt":"javascript语言的执行环境是单线程（single thread），就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯；但是只要耗时比较多，假如有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。","text":"javascript语言的执行环境是单线程（single thread），就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯；但是只要耗时比较多，假如有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 同步模式: 就是一个任务先执行，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的； 异步模式: 每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 Javascript处理异步的方法有以下几种： 回调函数回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行。回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署；缺点是容易产生回调地狱。 123456789ajax(&#x27;XXX1&#x27;, () =&gt; &#123; // callback 函数体 ajax(&#x27;XXX2&#x27;, () =&gt; &#123; // callback 函数体 ajax(&#x27;XXX3&#x27;, () =&gt; &#123; // callback 函数体 &#125;) &#125;)&#125;) 这就是所谓的回调地狱，回调地狱带来的负面作用有以下几点： 代码臃肿，可读性差，可维护性差。 代码复用性差。 容易滋生 bug。 只能在回调里处理异常。 事件监听这种方式，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 普通方式 1f1.on(&#x27;done&#x27;, f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。 onclick方法 12345678element.onclick=function()&#123; //处理函数&#125;element.onclick=handler1;element.onclick=handler2;element.onclick=handler3;// 只有handler3会被添加执行 优点：写法兼容到主流浏览器; 缺点：当同一个element元素绑定多个事件时，只有最后一个事件会被添加 addEvenListener123elment.addEvenListener(&quot;click&quot;,handler1,false);elment.addEvenListener(&quot;click&quot;,handler2,false);elment.addEvenListener(&quot;click&quot;,handler3,false); 该方法的第三个参数是一个布尔值：当为false时表示由里向外，true表示由外向里。 发布&#x2F;订阅模式我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布&#x2F;订阅模式”（publish-subscribe pattern） 首先，f2向信号中心jQuery订阅done信号。 1jQuery.subscribe(&#x27;done&#x27;, f2); 然后，f1进行如下改写： 12345function f1() &#123; setTimeout(function () &#123; jQuery.publish(&#x27;done&#x27;); &#125;, 1000);&#125; f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。f2完成执行后，可以取消订阅（unsubscribe） 1jQuery.unsubscribe(&#x27;done&#x27;, f2); 这种方式的优点：可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 promise以上都是ES6之前的异步处理方式。ES6之后出现了promise。它是异步编程的一种解决方案，比传统的解决方案(回调函数)——更合理和更强大。 Promise 对象有以下两个特点。 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果 基本用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。 1234567const promise = new Promise((resolve, reject) =&gt; &#123; if (/* 异步操作成功 */)&#123; resolve(success) &#125; else &#123; reject(error) &#125;&#125;) Promise接收一个函数作为参数，函数里有resolve和reject两个参数: resolve方法的作用是将Promise的pending状态变为fullfilled，在异步操作成功之后调用，可以将异步返回的结果作为参数传递出去。 reject方法的作用是将Promise的pending状态变为rejected，在异步操作失败之后调用，可以将异步返回的结果作为参数传递出去。 他们之间只能有一个被执行，不会同时被执行，因为Promise只能保持一种状态。 Promise 实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345678910111213promise.then((success) =&gt; &#123; // 对应于上面的resolve(success)方法&#125;, (error) =&gt; &#123; // 对应于上面的reject(error)方法&#125;// 还可以写成这样 (推荐使用这种写法)promise.then((success) =&gt; &#123; // 对应于上面的resolve(success)方法&#125;).catch((error) =&gt; &#123; // 对应于上面的reject(error)方法&#125;) then(onfulfilled,onrejected)方法中有两个参数，两个参数都是函数： 第一个参数执行的是resolve()方法(即异步成功后的回调方法) 第二参数执行的是reject()方法(即异步失败后的回调方法)(第二个参数可选)。 它返回的是一个新的Promise对象。 promise构造函数是同步执行的，then方法是异步执行的123456789101112const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4)// 1 2 4 3 Promise.finally()Promise.finally()用于指定不管 Promise 对象最后状态如何，都会执行的操作。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); Promise.all()Promise.all()用于处理多个异步处理，比如说一个页面上需要等多个 ajax 的数据回来才执行相关逻辑。 1const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promse.race()Promse.race()就是赛跑的意思，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 1const p = Promise.race([p1, p2, p3]) 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 async&#x2F;awaitasync&#x2F;await是JavaScript为了解决异步问题而提出的一种解决方案，许多人将其称为异步的终极解决方案。async 函数，就是 Generator 函数的语法糖。 相较于 Generator，Async 函数的改进在于下面四点： 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样。 更好的语义。async 和 await 相较于 * 和 yield 更加语义化。 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面可以是 Promise 或者原始类型（Number，string，boolean，但这时等同于同步）。 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。 async&#x2F;await使用规则 凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象 123456async function test() &#123; &#125;let result = test()console.log(result) //即便代码里test函数什么都没返回，我们依然打出了Promise对象 await必须在async函数里使用，不能单独使用 123456function test() &#123; let result = await Promise.resolve(&#x27;success&#x27;) console.log(result)&#125;test() //执行以后会报错 await 在等什么 如果await等到的不是一个promise对象，那跟着的表达式的运算结果就是它等到的东西； 如果是一个promise对象，await会阻塞后面的代码，等promise对象resolve，得到resolve的值作为await表达式的运算结果 虽然await阻塞了，但await在async中，async不会阻塞，它内部所有的阻塞都被封装在一个promise对象中异步执行","categories":[],"tags":[]},{"title":"JavaScript数组去重","slug":"js去重","date":"2022-04-24T01:43:08.396Z","updated":"2022-04-24T01:59:32.147Z","comments":true,"path":"2022/04/24/js去重/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E5%8E%BB%E9%87%8D/","excerpt":"","text":"JavaScript数组去重（12种方法，史上最全）数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中的10种，面试官很有可能对你刮目相看。在真实的项目中碰到的数组去重，一般都是后台去处理，很少让前端处理数组去重。虽然日常项目用到的概率比较低，但还是需要了解一下，以防面试的时候可能回被问到。数组去重的方法 一、利用ES6 Set去重（ES6中最常用） 1234function unique (arr) &#123; return Array.from(new Set(arr))&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;] 不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。 二、利用for嵌套for，然后splice去重（ES5中最常用） 123456789101112function unique(arr)&#123; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=i+1; j&lt;arr.length; j++)&#123; if(arr[i]==arr[j])&#123; //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; &#125; &#125; &#125;return arr;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr)) //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN和&#123;&#125;没有去重，两个null直接消失了 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。想快速学习更多常用的ES6语法，可以看我之前的文章《学习ES6笔记──工作中常用到的ES6语法》。 三、利用indexOf去重 1234567891011121314function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return &#125; var array = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (array .indexOf(arr[i]) === -1) &#123; array .push(arr[i]) &#125; &#125; return array;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr)) // [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN、&#123;&#125;没有去重 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。 四、利用sort() 12345678910111213141516function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return; &#125; arr = arr.sort() var arrry= [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i-1]) &#123; arrry.push(arr[i]); &#125; &#125; return arrry;&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined] //NaN、&#123;&#125;没有去重 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。 五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）12345678910111213141516171819function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return &#125; var arrry= []; var obj = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; arrry.push(arr[i]) obj[arr[i]] = 1 &#125; else &#123; obj[arr[i]]++ &#125; &#125; return arrry;&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))//[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;] //两个true直接去掉了，NaN和&#123;&#125;去重 六、利用includes123456789101112131415function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return &#125; var array =[]; for(var i = 0; i &lt; arr.length; i++) &#123; if( !array.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值 array.push(arr[i]); &#125; &#125; return array&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //&#123;&#125;没有去重 七、利用hasOwnProperty12345678function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(item, index, arr)&#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;] //所有的都去重了 利用hasOwnProperty 判断是否存在对象属性 八、利用filter12345678function unique(arr) &#123; return arr.filter(function(item, index, arr) &#123; //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; &#125;);&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] 九、利用递归去重123456789101112131415161718192021function unique(arr) &#123; var array= arr; var len = array.length; array.sort(function(a,b)&#123; //排序后更加方便去重 return a - b; &#125;) function loop(index)&#123; if(index &gt;= 1)&#123; if(array[index] === array[index-1])&#123; array.splice(index,1); &#125; loop(index - 1); //递归loop，然后数组去重 &#125; &#125; loop(len-1); return array;&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined] 十、利用Map数据结构去重123456789101112131415function arrayNonRepeatfy(arr) &#123; let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) &#123; if(map .has(arr[i])) &#123; // 如果有该key值 map .set(arr[i], true); &#125; else &#123; map .set(arr[i], false); // 如果没有该key值 array .push(arr[i]); &#125; &#125; return array ;&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined] 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。 十一、利用reduce+includes1234function unique(arr)&#123; return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] 十二、[…new Set(arr)] 1[...new Set(arr)] //代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）","categories":[],"tags":[]},{"title":"JS原型和原型链","slug":"js原型与原型链","date":"2022-04-24T01:43:08.392Z","updated":"2022-04-24T01:59:32.135Z","comments":true,"path":"2022/04/24/js原型与原型链/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"JS原型和原型链构造函数 每个构造函数(constructor)都有一个原型对象(prototype), 原型对象都包含一个指向构造函数的指针, 而实例(instance)都包含一个指向原型对象的内部指针. 我们先来看一个例子","text":"JS原型和原型链构造函数 每个构造函数(constructor)都有一个原型对象(prototype), 原型对象都包含一个指向构造函数的指针, 而实例(instance)都包含一个指向原型对象的内部指针. 我们先来看一个例子 12345678910function Person(name, age, job) &#123; this.name = name this.age = age this.job = job this.sayName = function() &#123; alert(this.name) &#125;&#125;var person1 = new Person(&#x27;Zaxlct&#x27;, 28, &#x27;Engineer&#x27;)var person2 = new Person(&#x27;Mick&#x27;, 23, &#x27;Doctor&#x27;) 上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即： 12console.log(person1.constructor == Person) //trueconsole.log(person2.constructor == Person) //true prototype每个构造函数都有一个 prototype 属性，指向调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = &#x27;Zaxlct&#x27;Person.prototype.age = 28Person.prototype.job = &#x27;Engineer&#x27;Person.prototype.sayName = function() &#123; alert(this.name)&#125;var person1 = new Person()person1.sayName() // &#x27;Zaxlct&#x27;var person2 = new Person()person2.sayName() // &#x27;Zaxlct&#x27;console.log(person1.sayName == person2.sayName) //true proto这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。 123function Person() &#123;&#125;var person1 = new Person()console.log(person1.__proto__ === Person.prototype) // true constructor每个原型都有一个 constructor 属性指向关联的构造函数 1234function Person() &#123;&#125;var person1 = new Person()console.log(Person === Person.prototype.constructor) // trueconsole.log(person1.__proto__ === Person.prototype) // true 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 1234567891011function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;var person = new Person()person.name = &#x27;Daisy&#x27;console.log(person.name) // Daisydelete person.nameconsole.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 Object.create()语法：Object.create(proto, [propertiesObject]) 方法创建一个新对象，使用现有的对象来提供新创建的对象的 proto。 new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。 Object.create() es6 创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。 12345678910111213// new Object() 方式创建var a = &#123; rep: &#x27;apple&#x27; &#125;var b = new Object(a)console.log(b) // &#123;rep: &quot;apple&quot;&#125;console.log(b.__proto__) // &#123;&#125;console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;// Object.create() 方式创建var a = &#123; rep: &#x27;apple&#x27; &#125;var b = Object.create(a)console.log(b) // &#123;&#125;console.log(b.__proto__) // &#123;rep: &quot;apple&quot;&#125;console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125; 经典面试题 1234567891011121314151617var obj1 = &#123; name: &#x27;one&#x27; &#125;obj2 = Object.create(obj1)obj2.name = &#x27;two&#x27;console.log(obj1.name)//onevar obj1 = &#123; prop: &#123; name: &#x27;one&#x27; &#125; &#125;obj2 = Object.create(obj1)obj2.prop.name = &#x27;two&#x27;console.log(obj1.prop.name)//twovar obj1 = &#123; list: [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;one&#x27;] &#125;obj2 = Object.create(obj1)obj2.list[0] = &#x27;two&#x27;console.log(obj1.list[0])//two 第二题先计算 obj2.prop 的值，在原型链中被发现，然后再计算 obj2.prop 对应的对象(不检查原型链)中是否存在 name 属性。 第三题是先计算 obj2.list 属性的值，然后赋值给 obj2.list 属性下标为 0（属性名为“0”）的属性。 私有变量、函数在函数内部定义的变量和函数如果不对外提供接口，那么外部将无法访问到，也就是变为私有变量和私有函数。 12345678910function Obj() &#123; var a = 0 //私有变量 var fn = function() &#123; //私有函数 &#125;&#125;var o = new Obj()console.log(o.a) //undefinedconsole.log(o.fn) //undefined 静态变量、函数当定义一个函数后通过 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。 123456789101112function Obj() &#123;&#125; Obj.a = 0 //静态变量 Obj.fn = function() &#123; //静态函数&#125;console.log(Obj.a) //0console.log(typeof Obj.fn) //functionvar o = new Obj()console.log(o.a) //undefinedconsole.log(typeof o.fn) //undefined 实例变量、函数在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，JavaScript也能做到这样。 123456789101112function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例方法 &#125;&#125; console.log(typeof Obj.a); //undefinedconsole.log(typeof Obj.fn); //undefined var o=new Obj();console.log(typeof o.a); //objectconsole.log(typeof o.fn); //function 一道综合面试题题目如下 123456789101112131415161718192021222324252627function Foo() &#123; getName = function() &#123; alert(1) &#125; return this&#125;Foo.getName = function() &#123; alert(2)&#125;Foo.prototype.getName = function() &#123; alert(3)&#125;var getName = function() &#123; alert(4)&#125;function getName() &#123; alert(5)&#125;//请写出以下输出结果：Foo.getName()getName()Foo().getName()getName()new Foo.getName()new Foo().getName()new new Foo().getName() 解读：首先定义了一个叫 Foo 的函数，之后为 Foo 创建了一个叫 getName 的静态属性存储了一个匿名函数，之后为 Foo 的原型对象新创建了一个叫 getName 的匿名函数。之后又通过函数变量表达式创建了一个 getName 的函数，最后再声明一个叫 getName 函数。 先来剧透一下答案，再来看看具体分析 12345678//答案：Foo.getName() //2getName() //4Foo().getName() //1getName() //1new Foo.getName() //2new Foo().getName() //3new new Foo().getName() //3 第一问:Foo.getName 自然是访问 Foo 函数上存储的静态属性，自然是 2 第二问，直接调用 getName 函数。既然是直接调用那么就是访问当前上文作用域内的叫 getName 的函数，所以跟 1 2 3 都没什么关系。但是此处有两个坑，一是变量声明提升，二是函数表达式。关于函数变量提示，此处省略一万字。。。。题中代码最终执行时的是 12345678910111213141516171819202122function Foo() &#123; getName = function() &#123; alert(1) &#125; return this&#125;var getName //只提升变量声明function getName() &#123; alert(5)&#125; //提升函数声明，覆盖var的声明Foo.getName = function() &#123; alert(2)&#125;Foo.prototype.getName = function() &#123; alert(3)&#125;getName = function() &#123; alert(4)&#125; //最终的赋值再次覆盖function getName声明getName() //最终输出4 第三问的 Foo().getName(); 先执行了 Foo 函数，然后调用 Foo 函数的返回值对象的 getName 属性函数。这里 Foo 函数的返回值是 this，this 指向 window 对象。所以第三问相当于执行 window.getName()。 然而这里 Foo 函数将此变量的值赋值为function()&#123;alert(1)&#125;。 第四问直接调用 getName 函数，相当于 window.getName()，答案和前面一样。 后面三问都是考察 js 的运算符优先级问题。","categories":[],"tags":[]},{"title":"JS 作用域与闭包","slug":"js作用域及闭包","date":"2022-04-24T01:43:08.387Z","updated":"2022-04-24T01:59:32.271Z","comments":true,"path":"2022/04/24/js作用域及闭包/","link":"","permalink":"https://data-cz.github.io/2022/04/24/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/","excerpt":"JS 作用域与闭包JS 作用域Javascript 变量的作用域无非就是两种：全局变量和局部变量。Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。 全局作用域(Global Scope)在代码中任何地方都能访问到的对象拥有全局作用域，一般来说一下几种情形拥有全局作用域： 最外层函数和在最外层函数外面定义的变量拥有全局作用域","text":"JS 作用域与闭包JS 作用域Javascript 变量的作用域无非就是两种：全局变量和局部变量。Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。 全局作用域(Global Scope)在代码中任何地方都能访问到的对象拥有全局作用域，一般来说一下几种情形拥有全局作用域： 最外层函数和在最外层函数外面定义的变量拥有全局作用域 1234567891011121314var name = &#x27;Jack&#x27; // 全局定义function foo() &#123; var age = 23 // 局部定义 function inner() &#123; // 局部函数 console.log(age) //age 23 &#125; inner()&#125;console.log(name) // yuanconsole.log(age) // Uncaught ReferenceError: age is not defined，在外部没有这个变量foo() // 内嵌函数的打印23inner() // Uncaught ReferenceError: inner is not defined 因为内嵌函数，找不到这个函数 所有末定义直接赋值的变量自动声明为拥有全局作用域 12345678var name = &#x27;yuan&#x27;function foo() &#123; age = 23 // 全局定义 var sex = &#x27;male&#x27; // 局部定义&#125;foo()console.log(age) // 23console.log(sex) // sex is not defined 所有 window 对象的属性拥有全局作用域一般情况下，window 对象的内置属性都都拥有全局作用域，例如 window.alert()、window.location、window.top 等等。 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条） 作用域链的前端，始终都是当前执行的代码所在环境的变量对象 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境 全局执行环境的变量对象始终都是作用域链上的最后一个对象 当在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找，直到全局作用域。如果在某个变量对象中找到则使用该变量对象中的变量值。 内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。变量提升ES6 之前我们一般使用 var 来声明变量，变量提升如下例子： 123456789101112function test() &#123; console.log(a) //undefined var a = 123&#125;// 它的实际执行顺序如下function test() &#123; var a console.log(a) a = 123&#125;test() 函数提升javascript 中不仅仅是变量声明有提升的现象，函数的声明也是一样。具名函数的声明有两种方式： 函数声明式 函数字面量式 1234//函数声明式function bar() &#123;&#125;//函数字面量式var foo = function() &#123;&#125; 函数提升是整个代码块提升到它所在的作用域的最开始执行 12345678910console.log(bar)function bar() &#123; console.log(1) //ƒ bar () &#123; console.log(1)&#125;&#125;// 实际执行顺序function bar() &#123; console.log(1)&#125;console.log(bar) 闭包闭包就是能够读取其他函数内部变量的函数，函数没有被释放，整条作用域链上的局部变量都将得到保留。由于在 javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 产生一个闭包创建闭包最常见方式，就是在一个函数内部创建另一个函数。闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。 123456789function fn() &#123; var a = 1, b = 2 function f1() &#123; return a + b &#125; return f1&#125; 上面例子中的 f1 就是一个闭包 闭包的应用 设计私有的方法和变量。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。 把有权访问私有变量的公有方法称为特权方法（privileged method）。 123456789101112function Animal() &#123; // 私有变量 var series = &#x27;哺乳动物&#x27; function run() &#123; console.log(&#x27;Run!!!&#x27;) &#125; // 特权方法 this.getSeries = function() &#123; return series &#125;&#125; 匿名函数最大的用途是创建闭包。减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。 123456789101112var objEvent = objEvent || &#123;&#125;(function() &#123; var addEvent = function() &#123; // some code &#125; function removeEvent() &#123; // some code &#125; objEvent.addEvent = addEvent objEvent.removeEvent = removeEvent&#125;)() addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它，这就大大减少了全局变量的使用，增强了网页的安全性。 定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部。123456789101112131415161718192021222324function module() &#123; var arr = []; function add(val) &#123; if (typeof val == &#x27;number&#x27;) &#123; arr.push(val); &#125; &#125; function get(index) &#123; if (index &lt; arr.length) &#123; return arr[index] &#125; else &#123; return null; &#125; &#125; return &#123; add: add, get: get &#125;&#125;var mod1 = module();mod1.add(1);mod1.add(2);mod1.add(&#x27;xxx&#x27;);console.log(mod1.get(2)); 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法时，在退出函数之前，将不使用的局部变量全部删除。 123456789101112131415function makeAdder(x) &#123; return function(y) &#123; return x + y &#125;&#125;var add5 = makeAdder(5)var add10 = makeAdder(10)console.log(add5(2)) // 7console.log(add10(2)) // 12// 释放对闭包的引用add5 = nulladd10 = null add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。最后通过 null 释放了 add5 和 add10 对闭包的引用。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。","categories":[],"tags":[]},{"title":"手写事件侦听器，并要求兼容浏览器","slug":"Handwritten-code","date":"2022-04-24T01:43:08.383Z","updated":"2022-04-24T01:59:32.140Z","comments":true,"path":"2022/04/24/Handwritten-code/","link":"","permalink":"https://data-cz.github.io/2022/04/24/Handwritten-code/","excerpt":"","text":"手写事件侦听器，并要求兼容浏览器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var eventUtil = &#123; getEvent: function(event) &#123; return event || window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;,&lt;!--more--&gt; addListener: function(element, type, hander) &#123; if (element.addEventListener) &#123; element.addEventListener(type, hander, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&#x27;on&#x27; + type, hander); &#125; else &#123; element[&#x27;on&#x27; + type] = hander; &#125; &#125;, removeListener: function(element, type, hander) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, hander, false); &#125; else if (element.deattachEvent) &#123; element.detachEvent(type, hander); &#125; else &#123; element[&#x27;on&#x27; + type] = null; &#125; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;;// 调用(function() &#123; var btn = document.getElementById(&quot;btn&quot;); var link = document.getElementsByTagName(&quot;a&quot;)[0]; eventUtil.addListener(btn, &quot;click&quot;, function(event) &#123; var event = eventUtil.getEvent(event); var target = eventUtil.getTarget(event); alert(event.type); alert(target); eventUtil.stopPropagation(event); &#125;); eventUtil.addListener(link, &quot;click&quot;, function(event) &#123; alert(&quot;prevent default event&quot;); var event = eventUtil.getEvent(event); eventUtil.preventDefault(event); &#125;); eventUtil.addListener(document.body, &quot;click&quot;, function() &#123; alert(&quot;click body&quot;); &#125;);&#125;)(); 手写事件模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344var Event = (function () &#123; var list = &#123;&#125;, bind, trigger, remove; bind = function (key, fn) &#123; if (!list[key]) &#123; list[key] = []; &#125; list[key].push(fn); &#125;; trigger = function () &#123; var key = Array.prototype.shift.call(arguments); var fns = list[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = list[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp; (fns.length = 0); &#125; else &#123; for (var i = fns.length - 1; i &gt;= 0; i--) &#123; var _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;; return &#123; bind: bind, trigger: trigger, remove: remove &#125;&#125;)();// 调用Event.bind(&#x27;Hit&#x27;, function()&#123; console.log(&#x27;bind event&#x27;); &#125;); // 绑定事件Event.trigger(&quot;Hit&quot;, function()&#123; console.log(&#x27;trigger event&#x27;); &#125;); // 触发事件 手写事件代理，并要求兼容浏览器 12345678910111213141516171819202122232425262728293031323334353637function delegateEvent(parentEl, selector, type, fn) &#123; var handler = function(e)&#123; var e = e || window.event; var target = e.target || e.srcElement; if (matchSelector(target, selector)) &#123; if(fn) &#123; fn.call(target, e); &#125; &#125; &#125;; if(parentEl.addEventListener)&#123; parentEl.addEventListener(type, handler); &#125;else&#123; parentEl.attachEvent(&quot;on&quot; + type, handler); &#125;&#125;/** * support #id, tagName, .className */function matchSelector(ele, selector) &#123; // if use id if (selector.charAt(0) === &quot;#&quot;) &#123; return ele.id === selector.slice(1); &#125; // if use class if (selector.charAt(0) === &quot;.&quot;) &#123; return (&quot; &quot; + ele.className + &quot; &quot;).indexOf(&quot; &quot; + selector.slice(1) + &quot; &quot;) != -1; &#125; // if use tagName return ele.tagName.toLowerCase() === selector.toLowerCase();&#125;// 调用var box = document.getElementById(&quot;box&quot;);delegateEvent(box, &quot;a&quot;, &quot;click&quot;, function()&#123; console.log(this.href);&#125;) 手写事件触发器，并要求兼容浏览器 12345678910var fireEvent = function(element, event)&#123; if (document.createEventObject)&#123; var mockEvent = document.createEventObject(); return element.fireEvent(&#x27;on&#x27; + event, mockEvent) &#125;else&#123; var mockEvent = document.createEvent(&#x27;HTMLEvents&#x27;); mockEvent.initEvent(event, true, true); return element.dispatchEvent(mockEvent); &#125;&#125; 手写 Function.bind 函数 123456789101112131415161718192021222324252627282930313233if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; throw new TypeError(&quot;&#x27;this&#x27; is not function&quot;); &#125; // bind&#x27;s default arguments, array without first element // first part arguments for the function var aBindArgs = Array.prototype.slice.call(arguments, 1); var fToBind = this; // the function will be binding var fNOP = function () &#123;&#125;; var fBound = function () &#123; // target this will be binding var oThis = this instanceof fNOP ? this : oThis || this; // last part arguments for the function var aCallArgs = Array.prototype.slice.call(arguments); // complete arguments for the function var aFuncArgs = aBindArgs.concat(aCallArgs); return fToBind.apply(oThis, aFuncArgs); &#125;; // fBound extends fToBind fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;// 调用var add = function(a, b, c)&#123; return a + b + c;&#125;;var newAdd = add.bind(null, 1, 2);var result = newAdd(3); 手写数组快速排序 123456789101112131415161718var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0, len = arr.length; i &lt; len; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;;// 调用quickSort([9, 4, 2, 8, 1, 5, 3, 7]); 手写数组冒泡排序 1234567891011121314151617181920var bubble = function(arr)&#123; var maxIndex = arr.length - 1, temp, flag; for (var i = maxIndex; i &gt; 0; i--) &#123; flag = true for (var j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if(! flag)&#123; break; &#125; &#125; return arr;&#125;// 调用var arr = bubble([13, 69, 28, 93, 55, 75, 34]); 手写数组去重 12345678910111213141516171819202122232425262728293031323334353637383940414243Array.prototype.unique = function() &#123; return [...new Set(this)];&#125;;// 调用[1, 2, 3, 3, 2, 1].unique();function unique1(arr)&#123; var hash = &#123;&#125;, result = []; for(var i=0, len=arr.length; i&lt;len; i++)&#123; if(! hash[arr[i]])&#123; result.push(arr[i]); hash[arr[i]] = true; &#125; &#125; return result;&#125;// 调用unique1([1, 2, 3, 3, 2, 1]);Array.prototype.unique2 = function()&#123; this.sort(); var result = [this[0]]; var len = this.length; for(var i = 0; i &lt; len; i++)&#123; if(this[i] !== result[result.length - 1])&#123; result.push(this[i]); &#125; &#125; return result;&#125;// 调用[1, 2, 3, 3, 2, 1].unique2();function unique3(arr)&#123; var result = []; for(var i=0; i&lt;arr.length; i++)&#123; if(result.indexOf(arr[i]) == -1)&#123; result.push(arr[i]); &#125; &#125; return result;&#125;// 调用unique3([1, 2, 3, 3, 2, 1]); 将url的查询参数解析成字典对象 12345678910111213function parseQuery(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var hash = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (match, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); hash[name] = String(val); return match; &#125;); return hash;&#125; 封装函数节流函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var throttle = function(fn, delay, mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;;&#125;;// 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次window.onresize = throttle(myFunc, 50, 100);````**用JS实现千位分隔符**```JavaScriptfunction test1(num)&#123; var str = (+ num) + &#x27;&#x27;; var len = str.length; if(len &lt;= 3) return str; num = &#x27;&#x27;; while(len &gt; 3)&#123; len -= 3; num = &#x27;,&#x27; + str.substr(len, 3) + num; &#125; return str.substr(0, len) + num;&#125;function test2(num)&#123; // ?= 正向匹配:匹配位置 // ?! 正向不匹配:排除位置 var str = (+num).toString(); var reg = /(?=(?!\\b)(\\d&#123;3&#125;)+$)/g; return str.replace(reg, &#x27;,&#x27;);&#125;","categories":[],"tags":[]},{"title":"ES6 语法","slug":"ES6","date":"2022-04-24T01:43:08.378Z","updated":"2022-04-24T01:59:32.219Z","comments":true,"path":"2022/04/24/ES6/","link":"","permalink":"https://data-cz.github.io/2022/04/24/ES6/","excerpt":"1、ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线 2、babel是什么，有什么作用? babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台 3、let有什么用，有了var为什么还要用let？ 在ES6之前，声明变量只能用var，var方式声明变量其实是很不合理的，准确的说，是因为ES5里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。let声明的变量拥有自己的块级作用域，且修复了var声明变量带来的变量提升问题。 4、举一些ES6对String字符串类型做的常用升级优化?","text":"1、ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线 2、babel是什么，有什么作用? babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台 3、let有什么用，有了var为什么还要用let？ 在ES6之前，声明变量只能用var，var方式声明变量其实是很不合理的，准确的说，是因为ES5里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。let声明的变量拥有自己的块级作用域，且修复了var声明变量带来的变量提升问题。 4、举一些ES6对String字符串类型做的常用升级优化? 优化部分 ES6新增了字符串模板，在拼接大段字符串时，用反斜杠()&#96;取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅 升级部分 ES6在String原型上新增了includes()方法，用于取代传统的只能用indexOf查找包含字符的方法(indexOf返回-1表示没查到不如includes方法返回false更明确，语义更清晰), 此外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串 5、举一些ES6对Array数组类型做的常用升级优化优化部分 数组解构赋值。ES6可以直接以let [a,b,c] = [1,2,3]形式进行变量赋值，在声明较多变量时，不用再写很多let(var),且映射关系清晰，且支持赋默认值 扩展运算符。ES6新增的扩展运算符(...)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。（尤其是在ES5中，arguments并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（let a = [2,3,4]; let b = [...a]） 升级部分 ES6在Array原型上新增了find()方法，用于取代传统的只能用indexOf查找包含数组项目的方法,且修复了indexOf查找不到NaN的bug([NaN].indexOf(NaN) === -1).此外还新增了copyWithin(), includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等 6、举一些ES6对Number数字类型做的常用升级优化优化部分 ES6在Number原型上新增了isFinite(), isNaN()方法，用来取代传统的全局isFinite(), isNaN()方法检测数值是否有限、是否是NaN。ES5的isFinite(), isNaN()方法都会先将非数值类型的参数转化为Number类型再做判断，这其实是不合理的，最造成isNaN(&#39;NaN&#39;) === true的奇怪行为--&#39;NaN&#39;是一个字符串，但是isNaN却说这就是NaN。而Number.isFinite()和Number.isNaN()则不会有此类问题(Number.isNaN(&#39;NaN&#39;) === false)。（isFinite()同上） 升级部分 ES6在Math对象上新增了Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算 7、举一些ES6对Object类型做的常用升级优化?(重要)优化部分 对象属性变量式声明。ES6可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰 12let [apple, orange] = [&#x27;red appe&#x27;, &#x27;yellow orange&#x27;];let myFruits = &#123;apple, orange&#125;; // let myFruits = &#123;apple: &#x27;red appe&#x27;, orange: &#x27;yellow orange&#x27;&#125;; 尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显 12let &#123;keys, values, entries&#125; = Object;let MyOwnMethods = &#123;keys, values, entries&#125;; // let MyOwnMethods = &#123;keys: keys, values: values, entries: entries&#125; 可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法 123456let es5Fun = &#123; method: function()&#123;&#125;&#125;; let es6Fun = &#123; method()&#123;&#125;&#125; 对象的解构赋值。 ES6对象也可以像数组解构赋值那样，进行变量的解构赋值 1let &#123;apple, orange&#125; = &#123;apple: &#x27;red appe&#x27;, orange: &#x27;yellow orange&#x27;&#125;; 对象的扩展运算符(...)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解 12345let &#123;apple, orange, ...otherFruits&#125; = &#123;apple: &#x27;red apple&#x27;, orange: &#x27;yellow orange&#x27;, grape: &#x27;purple grape&#x27;, peach: &#x27;sweet peach&#x27;&#125;; // otherFruits &#123;grape: &#x27;purple grape&#x27;, peach: &#x27;sweet peach&#x27;&#125;// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)let moreFruits = &#123;watermelon: &#x27;nice watermelon&#x27;&#125;;let allFruits = &#123;apple, orange, ...otherFruits, ...moreFruits&#125;; super 关键字。ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象 升级部分 ES6在Object原型上新增了is()方法，做两个目标对象的相等比较，用来完善&#39;===&#39;方法。&#39;===&#39;方法中NaN === NaN //false其实是不合理的，Object.is修复了这个小bug。(Object.is(NaN, NaN) // true) ES6在Object原型上新增了assign()方法，用于对象新增属性或者多个对象合并 12345const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意: assign合并的对象target只能合并source1、source2中的自身属性，并不会合并source1、source2中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行get/set函数，取return的值） ES6在Object原型上新增了getOwnPropertyDescriptors()方法，此方法增强了ES5中getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合defineProperties()方法，可以完美复制对象，包括复制get和set属性 ES6在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。这个方法存在的意义在于，ES5中获取设置prototype对像是通过__proto__属性来实现的，然而__proto__属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的prototype对象时，都应该采用ES6新增的标准用法 ES6在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组 8、举一些ES6对Function函数类型做的常用升级优化?优化部分 箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点 箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下this的指向变得很难理解，尤其是非严格模式情况下，this有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的this,这也就导致了this总是指向上一层的this，如果上一层还是箭头函数，则继续向上指，直到指向到有自己this的函数为止，并作为自己的this 箭头函数不能用作构造函数，因为它没有自己的this，无法实例化 也是因为箭头函数没有自己的this,所以箭头函数 内也不存在arguments对象。（可以用扩展运算符代替） 函数默认赋值。ES6之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6以更简洁更明确的方式进行函数默认赋值 1234function es6Fuc (x, y = &#x27;default&#x27;) &#123; console.log(x, y);&#125;es6Fuc(4) // 4, default 升级部分 ES6新增了双冒号运算符，用来取代以往的bind，call,和apply。(浏览器暂不支持，Babel已经支持转码) 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 9、Symbol是什么，有什么作用？ Symbol是ES6引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中Symbol()属性不能被for...in遍历，但是也不是私有属性 10、Set是什么，有什么作用？ Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员，区别是Set实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重 11、Map是什么，有什么作用？ Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性 12、Proxy是什么，有什么作用？ Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数&#96; 12345678910111213141516171819202122232425262728293031323334function createMyOwnObj() &#123; //想把所有的key都变成函数，或者Promise,或者anything return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let randomBoolean = Math.random() &gt; 0.5; let Message; if (randomBoolean) &#123; Message = `你的$&#123;propKey&#125;运气不错，成功了`; resolve(Message); &#125; else &#123; Message = `你的$&#123;propKey&#125;运气不行，失败了`; reject(Message); &#125; &#125;, 1000); &#125;); &#125; &#125;);&#125;let myOwnObj = createMyOwnObj();myOwnObj.hahaha.then(result =&gt; &#123; console.log(result) //你的hahaha运气不错，成功了&#125;).catch(error =&gt; &#123; console.log(error) //你的hahaha运气不行，失败了&#125;)myOwnObj.wuwuwu.then(result =&gt; &#123; console.log(result) //你的wuwuwu运气不错，成功了&#125;).catch(error =&gt; &#123; console.log(error) //你的wuwuwu运气不行，失败了&#125;) 13、Reflect是什么，有什么作用？ Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API 14、Promise是什么，有什么作用？ Promise是ES6引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用 15、Iterator是什么，有什么作用？(重要) Iterator是ES6中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为ES6新增了Set、Map类型，他们和Array、Object类型很像，Array、Object都是可以遍历的，但是Set、Map都不能用for循环遍历，解决这个问题有两种方案，一种是为Set、Map单独新增一个用来遍历的API，另一种是为Set、Map、Array、Object新增一个统一的遍历API，显然，第二种更好，ES6也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator正是这样一种标准。或者说是一种规范理念 就好像JavaScript是ECMAScript标准的一种具体实现一样，Iterator标准的具体实现是Iterator遍历器。Iterator标准规定，所有部署了key值为[Symbol.iterator]，且[Symbol.iterator]的value是标准的Iterator接口函数(标准的Iterator接口函数: 该函数必须返回一个对象，且对象中包含next方法，且执行next()能返回包含value/done属性的Iterator对象)的对象，都称之为可遍历对象，next()后返回的Iterator对象也就是Iterator遍历器 123456789101112131415161718192021//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。//obj.[Symbol.iterator]() 就是Iterator遍历器let obj = &#123; data: [ &#x27;hello&#x27;, &#x27;world&#x27; ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; ES6给Set、Map、Array、String都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的Iterator接口规范，所以Set、Map、Array、String默认都是可以遍历的 123456789101112131415161718192021//Arraylet array = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];array[Symbol.iterator]() //Iterator遍历器array[Symbol.iterator]().next() //&#123;value: &quot;red&quot;, done: false&#125;//Stringlet string = &#x27;1122334455&#x27;;string[Symbol.iterator]() //Iterator遍历器string[Symbol.iterator]().next() //&#123;value: &quot;1&quot;, done: false&#125;//setlet set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]);set[Symbol.iterator]() //Iterator遍历器set[Symbol.iterator]().next() //&#123;value: &quot;red&quot;, done: false&#125;//Maplet map = new Map();let obj= &#123;map: &#x27;map&#x27;&#125;;map.set(obj, &#x27;mapValue&#x27;);map[Symbol.iterator]().next() &#123;value: Array(2), done: false&#125; 16、for…in 和for…of有什么区别？ 如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用for...of。ES6规定，有所部署了载了Iterator接口的对象(可遍历对象)都可以通过for...of去遍历，而for..in仅仅可以遍历对象 这也就意味着，数组也可以用for...of遍历，这极大地方便了数组的取值，且避免了很多程序用for..in去遍历数组的恶习 17、Generator函数是什么，有什么作用？ 如果说JavaScript是ECMAScript标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。 执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。 Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。 18、async函数是什么，有什么作用？ async函数可以理解为内置自动执行器的Generator函数语法糖，它配合ES6的Promise近乎完美的实现了异步编程解决方案 19、Class、extends是什么，有什么作用？ ES6 的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。它参考了java语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class类可以通过extends实现继承。它和ES5构造函数的不同点 类的内部定义的所有方法，都是不可枚举的 123456789101112131415161718192021222324///ES5function ES5Fun (x, y) &#123; this.x = x; this.y = y;&#125;ES5Fun.prototype.toString = function () &#123; return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;;&#125;var p = new ES5Fun(1, 3);p.toString();Object.keys(ES5Fun.prototype); //[&#x27;toString&#x27;]//ES6class ES6Fun &#123; constructor (x, y) &#123; this.x = x; this.y = y; &#125; toString () &#123; return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;; &#125;&#125;Object.keys(ES6Fun.prototype); //[] ES6的class类必须用new命令操作，而ES5的构造函数不用new也可以执行。 ES6的class类不存在变量提升，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 20、module、export、import是什么，有什么作用？ module、export、import是ES6用来统一前端模块化方案的设计思路和实现方案。export、import的出现统一了前端模块化的实现方案，整合规范了浏览器&#x2F;服务端的模块化方法，用来取代传统的AMD/CMD、requireJS、seaJS、commondJS等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS也能更加能实现大型的应用程序开发。 import引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。 import引入export导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？ 常用箭头函数来取代var self = this;的做法。 常用let取代var命令。 常用数组&#x2F;对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。 在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。 用Class类取代传统的构造函数，来生成实例化对象。 在大型应用开发中，要保持module模块化开发思维，分清模块之间的关系，常用import、export方法。 22、ES6的了解 新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs&#x3D;&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念 23、说说你对Promise的理解 依照 Promise&#x2F;A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算 24、Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject 什么是 Promise ？ Promise 就是一个对象，用来表示并传递异步操作的最终结果 Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因 Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱） 25、谈一谈你了解ECMAScript6的新特性？ 块级作用区域 let a = 1; 可定义常量 const PI = 3.141592654; 变量解构赋值 var [a, b, c] = [1, 2, 3]; 字符串的扩展(模板字符串) var sum =${a + b}; 数组的扩展(转换数组类型) Array.from($(&#39;li&#39;)); 函数的扩展(扩展运算符) [1, 2].push(...[3, 4, 5]); 对象的扩展(同值相等算法) Object.is(NaN, NaN); 新增数据类型(Symbol) let uid = Symbol(&#39;uid&#39;); 新增数据结构(Map) let set = new Set([1, 2, 2, 3]); for…of循环 for(let val of arr)&#123;&#125;; Promise对象 var promise = new Promise(func); Generator函数 function* foo(x)&#123;yield x; return x*x;&#125; 引入Class(类) class Foo &#123;&#125; 引入模块体系 export default func; 引入async函数[ES7] 12345async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value) &#125; 26、Object.is() 与原来的比较操作符 &#x3D;&#x3D;&#x3D;、&#x3D;&#x3D; 的区别？ &#x3D;&#x3D; 相等运算符，比较时会自动进行数据类型转换 &#x3D;&#x3D;&#x3D; 严格相等运算符，比较时不进行隐式类型转换 Object.is 同值相等算法，在 &#x3D;&#x3D;&#x3D; 基础上对 0 和 NaN 特别处理 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 27、什么是 Babel Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。这些转化器让开发者提前使用最新的 JS语法(ES6&#x2F;ES7)，而不用等浏览器全部兼容。 Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。","categories":[],"tags":[]},{"title":"canvas压缩图片","slug":"canvas压缩图片","date":"2022-04-24T01:43:08.334Z","updated":"2022-04-24T01:59:31.992Z","comments":true,"path":"2022/04/24/canvas压缩图片/","link":"","permalink":"https://data-cz.github.io/2022/04/24/canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/","excerpt":"图片上传压缩我们通常在做图片上传的时候都会遇上这样的情况，一是后端接口限制上传图片的大小，或者是即使后端没有限制大小，因为图片太大在前端渲染时太慢，造成页面加载体验较差。因此我们很有必要对上传的图片进行压缩。 本文主要包括以下流程： 用户通过 input 框选择图片 使用 FileReader 进行图片预览 将图片绘制到 canvas 画布上 使用 canvas 画布的能力进行图片压缩 将压缩后的 Base64(DataURL) 格式的数据转换成 Blob 对象进行上传","text":"图片上传压缩我们通常在做图片上传的时候都会遇上这样的情况，一是后端接口限制上传图片的大小，或者是即使后端没有限制大小，因为图片太大在前端渲染时太慢，造成页面加载体验较差。因此我们很有必要对上传的图片进行压缩。 本文主要包括以下流程： 用户通过 input 框选择图片 使用 FileReader 进行图片预览 将图片绘制到 canvas 画布上 使用 canvas 画布的能力进行图片压缩 将压缩后的 Base64(DataURL) 格式的数据转换成 Blob 对象进行上传 Input 标签来获取图片 通过设置 input 标签的 type 属性为 file，来让用户可以选择文件，设置 accept 限制选择的文件类型，绑定 onchange 事件，来获取确认选择后的文件 1&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; onchange=&quot;loadFile(event)&quot; FileReaderFileReader 是什么，我们先来看看官方文档的介绍 FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 FileReader 常用的两个方法如下： FileReader.onload:处理 load 事件。即该钩子在读取操作完成时触发，通过该钩子函数可以完成例如读取完图片后进行预览的操作，或读取完图片后对图片内容进行二次处理等操作。 FileReader.readAsDataURL：读取方法，并且读取完成后，result 属性将返回 Data URL 格式（Base64 编码）的字符串，代表图片内容。 在图片上传中，我们可以通过 readAsDataURL() 方法进行了文件的读取，并且通过 result 属性拿到了图片的 Base64(DataURL) 格式的数据，然后通过该数据实现了图片预览的功能 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; onchange=&quot;loadFile(event)&quot; /&gt;&lt;/div&gt;&lt;script&gt; const loadFile = function (event) &#123; let file = event.target.files[0] const reader = new FileReader() reader.onload = function () &#123; console.log(reader.result) ... &#125; reader.readAsDataURL(file) &#125;&lt;/script&gt; canvas 压缩图片这是图片上传压缩的核心所在，我们先使用 CanvasRenderingContext2D.drawImage() 方法将上传的图片文件在画布上绘制出来，再使用 Canvas.toDataURL() 将画布上的图片信息转换成 base64(DataURL) 格式的数据。 drawImage() 方法在画布上绘制图像、画布或视频。drawImage() 方法也能够绘制图像的某些部分，以及&#x2F;或者增加或减少图像的尺寸。参数如下 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 12345678910var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)// 先创建图片对象var img = new Image()img.src = &#x27;./images/1.jpg&#x27;// 图片加载完之后img.onload = function () &#123; ctx.drawImage(img, 206, 111, 32, 38, 100, 100, 32, 38)&#125; Canvas.toDataURl()Canvas.toDataURl() 方法可以将 canvas 画布上的信息转换为 base64(DataURL) 格式的图像信息，纯字符的图片表示形式。该方法接收 2 个参数： mimeType(可选): 表示需要转换的图像的 mimeType 类型。默认值是 image/png，还可以是 image/jpeg， image/webp 等。 quailty(可选)：quality 表示转换的图片质量。范围是 0 到 1。图片的 mimeType 需要是 image/jpeg 或者 image/webp，其他 mimeType 值无效。默认压缩质量是 0.92。 12var canvas = document.createElement(&#x27;canvas&#x27;)canvas.toDataURL(&quot;image/jpeg&quot; 0.8) 到这里，我们先来上 canvas 压缩图片的代码 12345678910111213141516171819202122232425function compress(base64, quality, mimeType) &#123; let canvas = document.createElement(&#x27;canvas&#x27;) let img = document.createElement(&#x27;img&#x27;) img.crossOrigin = &#x27;anonymous&#x27; return new Promise((resolve, reject) =&gt; &#123; img.src = base64 img.onload = () =&gt; &#123; let targetWidth, targetHeight if (img.width &gt; MAX_WIDTH) &#123; targetWidth = MAX_WIDTH targetHeight = (img.height * MAX_WIDTH) / img.width &#125; else &#123; targetWidth = img.width targetHeight = img.height &#125; canvas.width = targetWidth canvas.height = targetHeight let ctx = canvas.getContext(&#x27;2d&#x27;) ctx.clearRect(0, 0, targetWidth, targetHeight) // 清除画布 ctx.drawImage(img, 0, 0, canvas.width, canvas.height) let imageData = canvas.toDataURL(mimeType, quality / 100) resolve(imageData) &#125; &#125;)&#125; 将 base64 转化为文件 通过 window.atob 将 base-64 字符串解码为 binaryString（二进制文本）； 将 binaryString 构造为 multipart/form-data 格式； 用 Uint8Array 将 multipart 格式的二进制文本转换为 ArrayBuffer。 123456789function dataUrlToBlob(base64, mimeType) &#123; let bytes = window.atob(base64.split(&#x27;,&#x27;)[1]) let ab = new ArrayBuffer(bytes.length) let ia = new Uint8Array(ab) for (let i = 0; i &lt; bytes.length; i++) &#123; ia[i] = bytes.charCodeAt(i) &#125; return new Blob([ab], &#123; type: mimeType &#125;)&#125; 将图片上传到服务端 创建一个 FormData，把 blob append 到 FormData 里面 请求服务端接口，提交图片 1234567function uploadFile(url, blob) &#123; let formData = new FormData() let request = new XMLHttpRequest() formData.append(&#x27;image&#x27;, blob) request.open(&#x27;POST&#x27;, url, true) request.send(formData)&#125; ps：在实际开发中，我们要不要把图片转化为 FormData 形式上传到服务端，这就看具体的业务需要了。我们可以上图片上传到腾讯云，直接返回一个&#39;https.xxx.jgp&#39;的图片 url 用于上传。","categories":[],"tags":[]},{"title":"JavaScript单行代码","slug":"1js 简介代码操作","date":"2022-04-24T01:43:08.327Z","updated":"2022-04-24T01:59:32.240Z","comments":true,"path":"2022/04/24/1js 简介代码操作/","link":"","permalink":"https://data-cz.github.io/2022/04/24/1js%20%E7%AE%80%E4%BB%8B%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"JavaScript单行代码 01-随机获取布尔值此函数将使用Math.random()方法返回布尔值（真或假）。Math.random创建一个介于0和1之间的随机数，然后我们检查它是否大于或小于0.5。这意味着有50&#x2F;50的机会会得到对或错。 1234const getRandomBoolean = () =&gt; Math.random() &gt;= 0.5;console.log(getRandomBoolean());// a 50/50 chance of returning true or false 02-检查日期是否为周末通过此功能，你将能够检查提供的日期是工作日还是周末。 1234567const isWeekend = (date) =&gt; [0, 6].indexOf(date.getDay()) !== -1;console.log(isWeekend(new Date(2021, 4, 14)));// false (Friday)console.log(isWeekend(new Date(2021, 4, 15)));// true (Saturday) ##03-检查数字是偶数还是奇数简单的实用程序功能，用于检查数字是偶数还是奇数。 1234567const isEven = (num) =&gt; num % 2 === 0;console.log(isEven(5));// falseconsole.log(isEven(4));// true 04-获取数组中的唯一值(数组去重)从数组中删除所有重复值的非常简单的方法。此函数将数组转换为Set，然后返回数组。 12345const uniqueArr = (arr) =&gt; [...new Set(arr)];console.log(uniqueArr([1, 2, 3, 1, 2, 3, 4, 5]));// [1, 2, 3, 4, 5] 05-检查变量是否为数组一种检查变量是否为数组的干净简便的方法。 当然，也可以有其他方法😉 123456789const isArray = (arr) =&gt; Array.isArray(arr);console.log(isArray([1, 2, 3]));// trueconsole.log(isArray(&#123; name: &#x27;Ovi&#x27; &#125;));// falseconsole.log(isArray(&#x27;Hello World&#x27;));// false 06-在两个数字之间生成一个随机数这将以两个数字为参数，并将在这两个数字之间生成一个随机数！ 1234const random = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1) + min);console.log(random(1, 50));// could be anything from 1 - 50 07-生成随机字符串（唯一ID？）也许你需要临时的唯一ID，这是一个技巧，你可以使用它在旅途中生成随机字符串。 12345const randomString = () =&gt; Math.random().toString(36).slice(2);console.log(randomString());// could be anything!!! 08-滚动到页面顶部所述window.scrollTo（）方法把一个X和Y坐标滚动到。如果将它们设置为零和零，我们将滚动到页面顶部。 1234image.pngconst scrollToTop = () =&gt; window.scrollTo(0, 0);scrollToTop(); 09-切换布尔切换布尔值是非常基本的编程问题之一，可以通过许多不同的方法来解决。代替使用if语句来确定将布尔值设置为哪个值，你可以使用函数使用！翻转当前值。非运算符。 12345// bool is stored somewhere in the upperscopeconst toggleBool = () =&gt; (bool = !bool);//orconst toggleBool = b =&gt; !b; 10-交换两个变量下面的代码是不使用第三个变量而仅使用一行代码即可交换两个变量的更简单方法之一。 12[foo, bar] = [bar, foo]; 11-计算两个日期之间的天数要计算两个日期之间的天数，我们首先找到两个日期之间的绝对值，然后将其除以86400000（等于一天中的毫秒数），最后将结果四舍五入并返回。 12345const daysDiff = (date, date2) =&gt; Math.ceil(Math.abs(date - date2) / 86400000);console.log(daysDiff(new Date(&#x27;2021-05-10&#x27;), new Date(&#x27;2021-11-25&#x27;)));// 199 12-将文字复制到剪贴板PS：你可能需要添加检查以查看是否存在navigator.clipboard.writeText 1234const copyTextToClipboard = async (text) =&gt; &#123; await navigator.clipboard.writeText(text);&#125;; 13-合并多个数组的不同方法有两种合并数组的方法。其中之一是使用concat方法。另一个使用扩展运算符（…）。 PS：我们也可以使用“设置”对象从最终数组中复制任何内容。 12345678910// Merge but don&#x27;t remove the duplicationsconst merge = (a, b) =&gt; a.concat(b);// Orconst merge = (a, b) =&gt; [...a, ...b];// Merge and remove the duplicationsconst merge = [...new Set(a.concat(b))];// Orconst merge = [...new Set([...a, ...b])]; 14-获取javascript语言的实际类型人们有时会使用库来查找JavaScript中某些内容的实际类型，这一小技巧可以节省你的时间（和代码大小）。 123456789101112131415161718192021const trueTypeOf = (obj) =&gt; &#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125;;console.log(trueTypeOf(&#x27;&#x27;));// stringconsole.log(trueTypeOf(0));// numberconsole.log(trueTypeOf());// undefinedconsole.log(trueTypeOf(null));// nullconsole.log(trueTypeOf(&#123;&#125;));// objectconsole.log(trueTypeOf([]));// arrayconsole.log(trueTypeOf(0));// numberconsole.log(trueTypeOf(() =&gt; &#123;&#125;));// function 15-在结尾处截断字符串需要从头开始截断字符串，这不是问题！ 123456789const truncateString = (string, length) =&gt; &#123; return string.length &lt; length ? string : `$&#123;string.slice(0, length - 3)&#125;...`;&#125;;console.log( truncateString(&#x27;Hi, I should be truncated because I am too loooong!&#x27;, 36),);// Hi, I should be truncated because... 16-从中间截断字符串从中间截断字符串怎么样？ 该函数将一个字符串作为第一个参数，然后将我们需要的字符串大小作为第二个参数，然后从第3个和第4个参数开始和结束需要多少个字符 1234567891011121314const truncateStringMiddle = (string, length, start, end) =&gt; &#123; return `$&#123;string.slice(0, start)&#125;...$&#123;string.slice(string.length - end)&#125;`;&#125;;console.log( truncateStringMiddle( &#x27;A long story goes here but then eventually ends!&#x27;, // string 25, // 需要的字符串大小 13, // 从原始字符串第几位开始截取 17, // 从原始字符串第几位停止截取 ),);// A long story ... eventually ends! 17-大写字符串好吧，不幸的是，JavaScript没有内置函数来大写字符串，但是这种解决方法可以实现。 12345const capitalize = (str) =&gt; str.charAt(0).toUpperCase() + str.slice(1);console.log(capitalize(&#x27;hello world&#x27;));// Hello world 18-检查当前选项卡是否在视图&#x2F;焦点内此简单的帮助程序方法根据选项卡是否处于视图&#x2F;焦点状态而返回true或false 12345const isTabInView = () =&gt; !document.hidden; // Not hiddenisTabInView();// true/false 19-检查用户是否在Apple设备上如果用户使用的是Apple设备，则返回true 12345const isAppleDevice = () =&gt; /Mac|iPod|iPhone|iPad/.test(navigator.platform);console.log(isAppleDevice);// true/false 20-三元运算符当你只想在一行中编写if..else语句时，这是一个很好的代码保护程序。 12345678910111213// Longhandconst age = 18;let greetings;if (age &lt; 18) &#123; greetings = &#x27;You are not old enough&#x27;;&#125; else &#123; greetings = &#x27;You are young!&#x27;;&#125;// Shorthandconst greetings = age &lt; 18 ? &#x27;You are not old enough&#x27; : &#x27;You are young!&#x27;; 21-短路评估速记在将变量值分配给另一个变量时，可能要确保源变量不为null，未定义或为空。可以编写带有多个条件的long if语句，也可以使用短路评估。 12345678// Longhandif (name !== null || name !== undefined || name !== &#x27;&#x27;) &#123; let fullName = name;&#125;// Shorthandconst fullName = name || &#x27;buddy&#x27;;","categories":[],"tags":[]},{"title":"什么是单页面应用","slug":"框架区别","date":"2022-04-24T01:40:58.468Z","updated":"2022-04-24T01:59:32.004Z","comments":true,"path":"2022/04/24/框架区别/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%A1%86%E6%9E%B6%E5%8C%BA%E5%88%AB/","excerpt":"什么是单页面应用(SPA)？ 单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页 目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。 流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据 实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。 优点：用户体验流畅，服务器压力小，前后端职责分离 缺点：关键词布局难度加大，不利于 SEO","text":"什么是单页面应用(SPA)？ 单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页 目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。 流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据 实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。 优点：用户体验流畅，服务器压力小，前后端职责分离 缺点：关键词布局难度加大，不利于 SEO 什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点? 前端路由通过 URL 和 History 来实现页面切换 应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目 优点：用户体验好，交互流畅 缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存 模块化开发怎么做？ 封装对象作为命名空间 – 内部状态可以被外部改写 立即执行函数(IIFE) – 需要依赖多个JS文件，并且严格按顺序加载 使用模块加载器 – require.js, sea.js, EC6 模块 通行的 Javascript 模块的规范有哪些？ CommonJS – 主要用在服务器端 node.js 12var math = require(&#x27;./math&#x27;);math.add(2,3); AMD(异步模块定义) – require.js 123require([&#x27;./math&#x27;], function (math) &#123; math.add(2, 3);&#125;); CMD(通用模块定义) – sea.js 12var math = require(&#x27;./math&#x27;);math.add(2,3); ES6 模块 12import &#123;math&#125; from &#x27;./math&#x27;;math.add(2, 3); AMD 与 CMD 规范的区别？ 规范化产出： AMD 由 RequireJS 推广产出 CMD 由 SeaJS 推广产出 模块的依赖: AMD 提前执行，推崇依赖前置 CMD 延迟执行，推崇依赖就近 API 功能: AMD 的 API 默认多功能（分全局 require 和局部 require） CMD 的 API 推崇职责单一纯粹（没有全局 require） 模块定义规则： AMD 默认一开始就载入全部依赖模块 1234define([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) &#123; a.doSomething(); b.doSomething();&#125;); CMD 依赖模块在用到时才就近载入 123456define(function(require, exports, module) &#123; var a = require(&#x27;./a&#x27;); a.doSomething(); var b = require(&#x27;./b&#x27;); b.doSomething();&#125;) requireJS的核心原理是什么？ 每个模块所依赖模块都会比本模块预先加载 对 Node.js 的优点、缺点提出了自己的看法？ Node.js的特点和适用场景？ Node.js的特点：单线程，非阻塞I&#x2F;O，事件驱动 Node.js的优点：擅长处理高并发；适合I&#x2F;O密集型应用 Node.js的缺点：不适合CPU密集运算；不能充分利用多核CPU；可靠性低，某个环节出错会导致整个系统崩溃 Node.js的适用场景： RESTful API 实时应用：在线聊天、图文直播 工具类应用：前端部署(npm, gulp) 表单收集：问卷系统 如何判断当前脚本运行在浏览器还是node环境中？ 判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中 什么是 npm ？ npm 是 Node.js 的模块管理和发布工具 什么是 WebKit ？ WebKit 是一个开源的浏览器内核，由渲染引擎(WebCore)和JS解释引擎(JSCore)组成 通常所说的 WebKit 指的是 WebKit(WebCore)，主要工作是进行 HTML&#x2F;CSS 渲染 WebKit 一直是 Safari 和 Chrome(之前) 使用的浏览器内核，后来 Chrome 改用Blink 内核 如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)? 通过为前端代码编写单元测试(Unit Test)来测试前端代码 Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码 BDD：行为驱动开发 – 业务需求描述产出产品代码的开发方法 TDD：测试驱动开发 – 单元测试用例代码产出产品代码的开发方法 单元测试框架： 12345678910111213// mocha 示例describe(&#x27;Test add&#x27;, function() &#123; it(&#x27;1 + 2 = 3&#x27;, function() &#123; expect(add(1, 2)).to.be.equal(3); &#125;);&#125;);// jasmin 示例describe(&#x27;Test add&#x27;, function () &#123; it(&#x27;1 + 2 = 3&#x27;, function () &#123; expect(add(1, 2)).toEqual(3); &#125;);&#125;); 介绍你知道的前端模板引擎？ artTemplate, underscore, handlebars 什么是 Modernizr？ Modernizr 工作原理？ Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况 移动端最小触控区域是多大？ 44 * 44 px 移动端的点击事件的延迟时间是多长，为什么会有延迟？ 如何解决这个延时？ 移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计 解决方案： 禁用缩放(对safari无效) 使用指针事件(IE私有特性，且仅IE10+) 使用 Zepto 的 tap 事件(有点透BUG) 使用 FastClick 插件(体积大[压缩后8k]) 什么是函数式编程？ 函数式编程是一种”编程范式”，主要思想是把运算过程尽量写成一系列嵌套的函数调用 例如：var result &#x3D; subtract(multiply(add(1,2), 3), 4); 函数式编程的特点： 函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值 只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值 没有”副作用”：所有功能只为返回一个新的值，不修改外部变量 引用透明：运行不依赖于外部变量，只依赖于输入的参数 函数式编程的优点： 代码简洁，接近自然语言，易于理解 便于维护，利于测试、除错、组合 易于“并发编程“，不用担心一个线程的数据，被另一个线程修改 可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机 什么是函数柯里化Currying)？ 柯里化： 通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数 期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程 柯里化的作用：延迟计算；参数复用；动态创建函数 柯里化的缺点： 函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等） 什么是依赖注入？ 当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。 依赖注入解决的就是如何有效组织代码依赖模块的问题 设计模式：什么是 singleton, factory, strategy, decorator？ Singleton(单例) 一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点 Factory (工厂) 解决实列化对象产生重复的问题 Strategy(策略) 将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用 Observer(观察者) 多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知 Prototype(原型) 一个完全初始化的实例，用于拷贝或者克隆 Adapter(适配器) 将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作 Proxy(代理模式) 一个充当过滤转发的对象用来代表一个真实的对象 Iterator(迭代器) 在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素 Chain of Responsibility(职责连) 处理请求组成的对象一条链，请求链中传递，直到有对象可以处理 什么是前端工程化？ 前端工程化就是把一整套前端工作流程使用工具自动化完成 前端开发基本流程： 项目初始化：yeoman, FIS 引入依赖包：bower, npm 模块化管理：npm, browserify, Webpack 代码编译：babel, sass, less 代码优化(压缩&#x2F;合并)：Gulp, Grunt 代码检查：JSHint, ESLint 代码测试：Mocha 目前最知名的构建工具：Gulp, Grunt, npm + Webpack 介绍 Yeoman 是什么？ Yeoman –前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架 Yeoman 其实是三类工具的合体，三类工具各自独立： yo — 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起） Grunt、gulp — 自动化构建工具 （最初只有grunt，之后加入了gulp） Bower、npm — 包管理工具 （原来是bower，之后加入了npm） 介绍 WebPack 是什么？ 有什么优势？ WebPack 是一款[模块加载器]兼[打包工具]，用于把各种静态资源（js&#x2F;css&#x2F;image等）作为模块来使用 WebPack 的优势： WebPack 同时支持 commonJS 和 AMD&#x2F;CMD，方便代码迁移 不仅仅能被模块化 JS ，还包括 CSS、Image 等 能替代部分 grunt&#x2F;gulp 的工作，如打包、压缩混淆、图片base64 扩展性强，插件机制完善，特别是支持 React 热插拔的功能 介绍类库和框架的区别？ 类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码 框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架 什么是 MVC&#x2F;MVP&#x2F;MVVM&#x2F;Flux？ MVC(Model-View-Controller) V-&gt;C, C-&gt;M, M-&gt;V 通信都是单向的；C只起路由作用，业务逻辑都部署在V Backbone MVP(Model-View-Presenter) V&lt;-&gt;P, P&lt;-&gt;M 通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P Riot.js MVVM(Model-View-ViewModel) V-&gt;VM, VM&lt;-&gt;M 采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面 Angular Flux(Dispatcher-Store-View) Action-&gt;Dispatcher-&gt;Store-&gt;View, View-&gt;Action Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想 基于一个简单的原则：数据在应用中单向流动（单向数据流） React(Flux 中 View，只关注表现层) Backbone 是什么？ Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架 AngularJS 是什么？ AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等 AngularJS 由 Google 维护，用来协助大型单一页面应用开发。 React 是什么？ React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层 React 主要的原理： 虚拟 DOM + diff 算法 -&gt; 不直接操作 DOM 对象 Components 组件 -&gt; Virtual DOM 的节点 State 触发视图的渲染 -&gt; 单向数据绑定 React 解决方案：React + Redux + react-router + Fetch + webpack react-router 路由系统的实现原理？ 实现原理：location 与 components 之间的同步 路由的职责是保证 UI 和 URL 的同步 在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定 因此，路由在 react-router 中就转变成 location 与 components 之间的同步 Meteor 是什么 Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。 Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。","categories":[],"tags":[]},{"title":"","slug":"性能","date":"2022-04-24T01:40:58.463Z","updated":"2022-04-24T01:59:31.404Z","comments":true,"path":"2022/04/24/性能/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E6%80%A7%E8%83%BD/","excerpt":"title: 性能date: 2022&#x2F;4&#x2F;13 hh:mm:ss # 时间 一、网络相关1.1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//yuchengkai.cn&quot;&gt;","text":"title: 性能date: 2022&#x2F;4&#x2F;13 hh:mm:ss # 时间 一、网络相关1.1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//yuchengkai.cn&quot;&gt; 1.2 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度 通常浏览器缓存策略分为两种：强缓存和协商缓存 强缓存 实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200 1Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 1Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高 选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 1.3 使用 HTTP &#x2F; 2.0 因为浏览器会有并发请求限制，在 HTTP &#x2F; 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 在 HTTP &#x2F; 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小 1.4 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot;&gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好 1.5 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 1&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com&quot;&gt; 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 二、优化渲染过程2.1 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒 2.2 懒加载 懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等","categories":[],"tags":[]},{"title":"前端错误监控","slug":"前端错误监控","date":"2022-04-24T01:40:58.459Z","updated":"2022-04-24T01:59:31.487Z","comments":true,"path":"2022/04/24/前端错误监控/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/","excerpt":"1 前言 错误监控包含的内容是： 前端错误的分类 每种错误的捕获方式 上报错误的基本原理","text":"1 前言 错误监控包含的内容是： 前端错误的分类 每种错误的捕获方式 上报错误的基本原理 面试时，可能有两种问法： 如何监测 js 错误？（开门见山的方式） 如何保证产品质量？（其实问的也是错误监控） 2 前端错误的分类包括两种： 即时运行错误（代码错误） 资源加载错误 3 每种错误的捕获方式3.1 即时运行错误的捕获方式方式1：try ... catch。 这种方式要部署在代码中。 方式2：window.onerror函数。这个函数是全局的。 1window.onerror = function(msg, url, row, col, error) &#123; ... &#125; 参数解释： msg为异常基本信息 source为发生异常Javascript文件的url row为发生错误的行号 方式二中的window.onerror是属于DOM0的写法，我们也可以用DOM2的写法：window.addEventListener(&quot;error&quot;, fn);也可以。 问题延伸1： window.onerror默认无法捕获跨域的js运行错误。捕获出来的信息如下：（基本属于无效信息） 比如说，我们的代码想引入B网站的b.js文件，怎么捕获它的异常呢？ 解决办法：在方法二的基础之上，做如下操作： 在b.js文件里，加入如下 response header，表示允许跨域：（或者世界给静态资源b.js加这个 response header） 1Access-Control-Allow-Origin: * 引入第三方的文件b.js时，在&lt;script&gt;标签中增加crossorigin属性； 问题延伸2： 只靠方式二中的window.onerror是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把堆栈信息作为msg打印出来，堆栈里很详细。 3.2 资源加载错误的捕获方式 上面的window.onerror只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，object.onerror捕获后就会终止（不会冒泡给window），所以window.onerror并不能捕获资源加载错误。 方式1：object.onerror。img标签、script标签等节点都可以添加onerror事件，用来捕获资源加载的错误。 方式2：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。 举例： 浏览器打开一个网站，在Console控制台下，输入： 1performance.getEntries().forEach(function(item)&#123;console.log(item.name)&#125;) 或者输入： 1performance.getEntries().forEach(item=&gt;&#123;console.log(item.name)&#125;) 上面这个api，返回的是数组，既然是数组，就可以用forEach遍历。打印出来的资源就是已经成功加载的资源。； 再入document.getElementsByTagName(&#39;img&#39;)，就会显示出所有需要加载的的img集合。 于是，document.getElementsByTagName(&#39;img&#39;)获取的资源数组减去通过performance.getEntries()获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。 这种方式非常有用，一定要记住。 方式3；Error事件捕获。 源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如： 总结：如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。 4 错误上报的两种方式 方式一：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式） 方式二：利用Image对象上报（推荐。网站的监控体系都是采用的这种方式） 方式二的实现方式如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //通过Image对象进行错误上报 (new Image()).src = &#x27;http://smyhvae.com/myPath?badjs=msg&#x27;; // myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开浏览器，效果如下： 上图中，红色那一栏表明，我的请求已经发出去了。点进去看看： 这种方式，不需要借助第三方的库，一行代码即可搞定。","categories":[],"tags":[]},{"title":"图片懒加载","slug":"前端性能优化之图片懒加载","date":"2022-04-24T01:40:58.454Z","updated":"2022-04-24T01:59:32.084Z","comments":true,"path":"2022/04/24/前端性能优化之图片懒加载/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"图片懒加载在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。 为什么要进行图片懒加载我们先来看一下页面启动时加载的图片信息。 如图所示，这个页面启动时加载了几十张图片（甚至更多），而这些图片请求几乎是并发的，在 Chrome 浏览器，最多支持的并发请求次数是有限的，其他的请求会推入到队列中等待或者停滞不前，直到上轮请求完成后新的请求才会发出。所以相当一部分图片资源请求是需要排队等待时间的。 在上面可以看出，有部分图片达到几百 kB，设置 2M(这锅必须运营背，非得上传高清大图不可？)，直接导致了加载时间过长。","text":"图片懒加载在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。 为什么要进行图片懒加载我们先来看一下页面启动时加载的图片信息。 如图所示，这个页面启动时加载了几十张图片（甚至更多），而这些图片请求几乎是并发的，在 Chrome 浏览器，最多支持的并发请求次数是有限的，其他的请求会推入到队列中等待或者停滞不前，直到上轮请求完成后新的请求才会发出。所以相当一部分图片资源请求是需要排队等待时间的。 在上面可以看出，有部分图片达到几百 kB，设置 2M(这锅必须运营背，非得上传高清大图不可？)，直接导致了加载时间过长。 针对以上情况，进行图片懒加载有以下优点： 减少资源的加载，页面启动只加载首屏的图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。 防止并发加载的资源过多而阻塞 js 的加载，影响整个网站的启动。 能提升用户的体验，不妨设想下，用户打开页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长这就严重影响用户体验。 图片懒加载的原理图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的 拿到所有的图片 dome 。 遍历每个图片判断当前图片是否到了可视区范围内。 如果到了就设置图片的 src 属性。 绑定 window 的 scroll 事件，对其进行事件监听。 我们先来看下页面结构 1234567891011121314151617181920212223242526&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; height: 200px; width: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/1.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/2.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/3.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/4.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/5.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/6.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/7.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/8.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/9.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/10.jpg&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 先获取所有图片的 dom，通过 document.body.clientHeight 获取可视区高度，再使用 element.getBoundingClientRect() API 直接得到元素相对浏览的 top 值， 遍历每个图片判断当前图片是否到了可视区范围内。代码如下： 1234567891011121314function lazyload() &#123; let viewHeight = document.body.clientHeight //获取可视区高度 let imgs = document.querySelectorAll(&#x27;img[data-src]&#x27;) imgs.forEach((item, index) =&gt; &#123; if (item.dataset.src === &#x27;&#x27;) return // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 let rect = item.getBoundingClientRect() if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123; item.src = item.dataset.src item.removeAttribute(&#x27;data-src&#x27;) &#125; &#125;)&#125; 最后给 window 绑定 onscroll 事件 1window.addEventListener(&#x27;scroll&#x27;, lazyload) 主要就完成了一个图片懒加载的操作了。但是这样存在较大的性能问题，因为 scroll 事件会在很短的时间内触发很多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内（如 200ms）只执行一次回调。 下面实现一个节流函数 1234567891011121314151617181920212223function throttle(fn, delay) &#123; let timer let prevTime return function (...args) &#123; const currTime = Date.now() const context = this if (!prevTime) prevTime = currTime clearTimeout(timer) if (currTime - prevTime &gt; delay) &#123; prevTime = currTime fn.apply(context, args) clearTimeout(timer) return &#125; timer = setTimeout(function () &#123; prevTime = Date.now() timer = null fn.apply(context, args) &#125;, delay) &#125;&#125; 然后修改一下 srcoll 事件 1window.addEventListener(&#x27;scroll&#x27;, throttle(lazyload, 200)) IntersectionObserver通过上面例子的实现，我们要实现懒加载都需要去监听 scroll 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数，但是我们还是需要去计算 scrollTop，offsetHeight 等属性，有没有简单的不需要计算这些属性的方式呢，答案就是 IntersectionObserver。 IntersectionObserver 是一个新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法： 12345678910var io = new IntersectionObserver(callback, option)// 开始观察io.observe(document.getElementById(&#x27;example&#x27;))// 停止观察io.unobserve(element)// 关闭观察器io.disconnect() IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。 目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 123var io = new IntersectionObserver((entries) =&gt; &#123; console.log(entries)&#125;) callback 函数的参数（entries）是一个数组，每个成员都是一个 IntersectionObserverEntry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 isIntersecting: 目标是否可见 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1，完全不可见时小于等于 0 下面我们用 IntersectionObserver 实现图片懒加载 1234567891011121314151617181920212223const imgs = document.querySelectorAll(&#x27;img[data-src]&#x27;)const config = &#123; rootMargin: &#x27;0px&#x27;, threshold: 0,&#125;let observer = new IntersectionObserver((entries, self) =&gt; &#123; entries.forEach((entry) =&gt; &#123; if (entry.isIntersecting) &#123; let img = entry.target let src = img.dataset.src if (src) &#123; img.src = src img.removeAttribute(&#x27;data-src&#x27;) &#125; // 解除观察 self.unobserve(entry.target) &#125; &#125;)&#125;, config)imgs.forEach((image) =&gt; &#123; observer.observe(image)&#125;) 懒加载指令Vue 中除了平时常用的 v-show、v-bind、v-for 等指令外，还可以自定义指令。Vue 指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 实现一个懒加载指令的思路 判断浏览器是否支持 IntersectionObserver API，如果支持就使用 IntersectionObserver 实现懒加载，否则则使用 srcoll 事件监听 + 节流的方法实现。 通过 Vue.directive 注册一个 v-lazy 的指令，暴露一个 install() 函数，供 Vue 调用。 在 main.js 里 use(指令) 即可调用。 将组件内 &lt;img&gt; 标签的 src 换成 v-lazy 即可实现图片懒加载。 代码如下 新建 LazyLoad.js 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const LazyLoad = &#123; // install方法 install(Vue, options) &#123; const defaultSrc = options.default Vue.directive(&#x27;lazy&#x27;, &#123; bind(el, binding) &#123; LazyLoad.init(el, binding.value, defaultSrc) &#125;, inserted(el) &#123; if (IntersectionObserver) &#123; LazyLoad.observe(el) &#125; else &#123; LazyLoad.listenerScroll(el) &#125; &#125;, &#125;) &#125;, // 初始化 init(el, val, def) &#123; el.setAttribute(&#x27;data-src&#x27;, val) el.setAttribute(&#x27;src&#x27;, def) &#125;, // 利用IntersectionObserver监听el observe(el) &#123; var io = new IntersectionObserver((entries) =&gt; &#123; const realSrc = el.dataset.src if (entries[0].isIntersecting) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;) io.observe(el) &#125;, // 监听scroll事件 listenerScroll(el) &#123; const handler = LazyLoad.throttle(LazyLoad.load, 300) LazyLoad.load(el) window.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; handler(el) &#125;) &#125;, // 加载真实图片 load(el) &#123; const windowHeight = document.documentElement.clientHeight const elTop = el.getBoundingClientRect().top const elBtm = el.getBoundingClientRect().bottom const realSrc = el.dataset.src if (elTop - windowHeight &lt; 0 &amp;&amp; elBtm &gt; 0) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;, // 节流 throttle(fn, delay) &#123; let timer let prevTime return function (...args) &#123; const currTime = Date.now() const context = this if (!prevTime) prevTime = currTime clearTimeout(timer) if (currTime - prevTime &gt; delay) &#123; prevTime = currTime fn.apply(context, args) clearTimeout(timer) return &#125; timer = setTimeout(function () &#123; prevTime = Date.now() timer = null fn.apply(context, args) &#125;, delay) &#125; &#125;,&#125;export default LazyLoad 在 main.js 里 use 指令 12345import LazyLoad from &#x27;./LazyLoad.js&#x27;Vue.use(LazyLoad, &#123; default: &#x27;xxx.png&#x27;,&#125;) 将组件内 &lt;img&gt; 标签的 src 换成 v-lazy 1&lt;img v-lazy=&quot;xxx.jpg&quot; /&gt; 这样就能完成一个 vue 懒加载的指令了。 小结 为提高网站加载性能，图片懒加载是必要的。 图片懒加载是实现原理是判断当前图片是否到了可视区域进行加载，可通过监听 scroll 事件和 IntersectionObserver 实现相应的功能。 可通过 Vue.directive 编写图片懒加载指令。","categories":[],"tags":[]},{"title":"开发规范及代码优化","slug":"前端代码规范","date":"2022-04-24T01:40:58.450Z","updated":"2022-04-24T01:59:31.999Z","comments":true,"path":"2022/04/24/前端代码规范/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"vue 开发规范及代码优化所谓无规矩不成方圆，前端时间在团队 code-review 中发现，不同时期不同开发人员写的代码可谓五花八门。因此我们提出了一些相关代码方面的规范，希望日后能形成团队的编码规范。 制定开发规范的目的 统一编码风格，规范，提高团队协作效率 在团队协作中输出可读性强，易维护，风格一致的代码 本文在gitthub做了收录：https://github.com/Michael-lzg/my--article/blob/master/other/前端代码规范及优化.md","text":"vue 开发规范及代码优化所谓无规矩不成方圆，前端时间在团队 code-review 中发现，不同时期不同开发人员写的代码可谓五花八门。因此我们提出了一些相关代码方面的规范，希望日后能形成团队的编码规范。 制定开发规范的目的 统一编码风格，规范，提高团队协作效率 在团队协作中输出可读性强，易维护，风格一致的代码 本文在gitthub做了收录：https://github.com/Michael-lzg/my--article/blob/master/other/前端代码规范及优化.md HTML 篇启用标准模式使用 HTML5 的 doctype 来启用标准模式 1&lt;!DOCTYPE html&gt; 统一使用 UTF-8 编码1&lt;meta charset=&quot;utf-8&quot; /&gt; 优先使用 IE 最新版本和 Chrome1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; 移动设备添加 viewport1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot; /&gt; 自闭合标签无需闭合例如： img， input， br， hr 等 123&lt;img src=&quot;https://xxx.png&quot; alt=&quot;Google&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; 使用语义化标签html 的标签能使用语义化的，尽量使用语义化标签，避免一个页面都是 div 或者 p 标签 12345678&lt;!-- bad --&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- good --&gt;&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt; 属性顺序要求HTML 属性应该按照特定的顺序出现以保证易读性。 1234567idclassnamedata-xxxsrc, for, type, hreftitle, altaria-xxx, role CSS 篇BEM 命名原则 block：模块，名字单词间用 - 连接 element：元素，模块的子元素，以 __ 与 block 连接 modifier：修饰，模块的变体，定义特殊模块，以 – 与 block 连接 12345/* 举个例子 */.block__element &#123;&#125;.block--modifier &#123;&#125; 有效使用 css 选择器选择器嵌套应少于 3 级 1234567/* bad */.page .header .login #username input &#123;&#125;/* good */#username input &#123;&#125; 有效使用 css 选择器，因遵循以下原则 保持简单，不要使用嵌套过多过于复杂的选择器。 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。 不要使用类选择器和 ID 选择器修饰元素标签。 不要为了追求速度而放弃可读性与可维护性 避免使用 CSS 表达式 慎重选择高消耗的样式高消耗属性在绘制前需要浏览器进行大量计算： 12345box-shadowsborder-radiustransparencytransformsCSS filters（性能杀手） 避免重绘重排当发生重排的时候，浏览器需要重新计算布局位置与大小，不利于性能优化。 常见引起重绘重排属性和方法 添加或者删除可见的 DOM 元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在 input 框中输入文字 浏览器窗口尺寸改变——resize 事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 减少重绘重排的方法 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 Javascript 篇关于命名普通命名采用小驼峰式命名 1let userName = &#x27;jack&#x27; 命名是复数的时候需要加 s，比如说我想声明一个数组，表示很多人的名字 1let names = new Array() 每个常量都需命名，这样更利于别人读懂含义 123456// goodconst COL_NUM = 10let row = Math.ceil(num / COL_NUM)// badlet row = Math.ceil(num / 10) 命名需要符合语义化，如果函数命名，可以采用加上动词前缀： can 判断是否可执行某个动作 has 判断是否含有某个值 is 判断是否为某个值 get 获取某个值 set 设置某个值 12345678//是否可阅读function canRead()&#123; return true;&#125;//获取姓名function getName&#123; return this.name&#125; 关于字符串统一使用单引号而不是双引号 12345// badconst name = &#x27;jack&#x27;// goodconst name = &#x27;jack&#x27; 用字符串模板而不是 ‘+’ 来拼接字符串 12345678function sayHi(name) &#123; return &#x27;How are you, &#x27; + name + &#x27;?&#x27;&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`&#125; 关于数组用字面量赋值 12345// badconst items = new Array()// goodconst items = [] 用扩展运算符做数组浅拷贝 1234567891011// badlet arr = [1, 2, 3]const len = arr.lengthconst copyArr = []for (let i = 0; i &lt; len; i += 1) &#123; copyArr[i] = arr[i]&#125;// goodconst copyArr = [...arr] 用 Array.from 去将一个类数组对象转成一个数组。 1234567const arrLike = &#123; 0: &#x27;foo&#x27;, 1: &#x27;bar&#x27;, 2: &#x27;baz&#x27;, length: 3 &#125;// badconst arr = Array.prototype.slice.call(arrLike)// goodconst arr = Array.from(arrLike) 使用数组解构 12345678const arr = [1, 2, 3, 4]// badconst first = arr[0]const second = arr[1]// goodconst [first, second] = arr 关于对象创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。 123456789101112// goodlet obj = &#123; name: &#x27;Tom&#x27;, age: 15, sex: &#x27;男&#x27;,&#125;// badlet obj = &#123;&#125;obj.name = &#x27;Tom&#x27;obj.age = 15obj.sex = &#x27;男&#x27; ES6 使用属性值缩写 1234567891011const lukeSkywalker = &#x27;Luke Skywalker&#x27;// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;// goodconst obj = &#123; lukeSkywalker,&#125; 将属性的缩写放在对象声明的开头 12345678910111213141516171819202122const anakinSkywalker = &#x27;Anakin Skywalker&#x27;const lukeSkywalker = &#x27;Luke Skywalker&#x27;// badconst obj = &#123; episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125; 对象浅拷贝时，更推荐使用扩展运算符 …，而不是 Object.assign。解构赋值获取对象指定的几个属性时，推荐用 rest 运算符，也是 …。 1234567891011121314// very badconst original = &#123; a: 1, b: 2 &#125;const copy = Object.assign(original, &#123; c: 3 &#125;)delete copy.a // 改变了 original// badconst original = &#123; a: 1, b: 2 &#125;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;) // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// goodconst original = &#123; a: 1, b: 2 &#125;const copy = &#123; ...original, c: 3 &#125; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, ...noA &#125; = copy // noA =&gt; &#123; b: 2, c: 3 &#125; 关于函数函数参数使用默认值替代使用条件语句进行赋值。 12345678910// goodfunction createMicrobrewery(name = &#x27;Jack&#x27;) &#123; ...&#125;// badfunction createMicrobrewery(name) &#123; const userNameName = name || &#x27;Jack&#x27; ...&#125; 函数参数使用结构语法，函数参数越少越好，如果参数超过两个，要使用 ES6 的解构语法，不用考虑参数的顺序。 12345678910111213141516// goodfunction createMenu(&#123; title, body, buttonText, cancellable &#125;) &#123; ...&#125;createMenu(&#123; title: &#x27;Foo&#x27;, body: &#x27;Bar&#x27;, buttonText: &#x27;Baz&#x27;, cancellable: true,&#125;)// badfunction createMenu(title, body, buttonText, cancellable) &#123; // ...&#125; 优先使用 rest 语法…，而不是 arguments 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments) return args.join(&#x27;&#x27;)&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&#x27;&#x27;)&#125; 把默认参数赋值放在最后 123456789// badfunction handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// goodfunction handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; 尽量使用箭头函数 1234567891011121314// bad;[1, 2, 3] .map(function (x) &#123; const y = x + 1 return x * y &#125;) [ // good (1, 2, 3) ].map((x) =&gt; &#123; const y = x + 1 return x * y &#125;) 关于模块在非标准模块系统上使用(import&#x2F;export) 1234567891011// badconst AirbnbStyleGuide = require(&#x27;./AirbnbStyleGuide&#x27;)module.exports = AirbnbStyleGuide.es6// okimport AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;export default AirbnbStyleGuide.es6// bestimport &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;export default es6 一个入口只 import 一次 1234567// badimport foo from &#x27;foo&#x27;// … some other imports … //import &#123; named1, named2 &#125; from &#x27;foo&#x27;// goodimport foo, &#123; named1, named2 &#125; from &#x27;foo&#x27; 在只有一个导出的模块里，用 export default 更好 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123; for 循环使用 for 循环过程中，数组的长度，使用一个变量来接收，这样有利于代码执行效率得到提高，而不是每走一次循环，都得重新计算数组长度 123456789// badfor(var i=0;i&lt;arr.length,i++)&#123;&#125;// goodfor(var i=0;i&lt;arr.length,i++)&#123;&#125; Vue 篇Prop 定义尽量详细。prop 的定义应该尽量详细，至少需要指定其类型。 123456789101112131415161718// badprops: [&#x27;status&#x27;]// goodprops: &#123; status: String&#125;// betterprops: &#123; status: &#123; type: String, required: true, validator: function (value) &#123; return [&#x27;syncing&#x27;,&#x27;synced&#x27;,&#x27;version-conflict&#x27;,&#x27;error&#x27;].indexOf(value) !== -1 &#125; &#125;&#125; v-for 遍历必须添加 key在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。 123456789&lt;!-- bad --&gt;&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!-- good --&gt;&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&lt;/ul&gt; v-if 和 v-for 不要用在同一个元素上。v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。 123456789&lt;!-- bad --&gt;&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; :key=&quot;user.id&quot;&gt;&#123;&#123; user.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!-- good --&gt;&lt;ul v-if=&quot;shouldShowUsers&quot;&gt; &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt;&#123;&#123; user.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 组件的 data 必须是一个函数JS 中的实例是通过构造函数来创建的，每个构造函数可以 new 出很多个实例，那么每个实例都会继承原型上的方法或属性。Vue 的 data 数据其实是 Vue 原型上的属性，数据存在于内存当中。 同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果 data 是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性，要求每个组件必须通过 data 函数返回一个对象作为组件的状态，这样每复用一次组件，就会返回一份新的 data。 123456789101112131415// badVue.component(&#x27;some-comp&#x27;, &#123; data: &#123; foo: &#x27;bar&#x27;, &#125;,&#125;)// goodVue.component(&#x27;some-comp&#x27;, &#123; data: function () &#123; return &#123; foo: &#x27;bar&#x27;, &#125; &#125;,&#125;) 组件模板应该书写简洁组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。 123456789101112131415161718// bad&#123;&#123; fullName.split(&#x27; &#x27;).map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(&#x27; &#x27;)&#125;&#125;// good// 在模板中&#123;&#123; normalizedFullName &#125;&#125;// 复杂表达式已经移入一个计算属性computed: &#123; normalizedFullName: function () &#123; return this.fullName.split(&#x27; &#x27;).map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(&#x27; &#x27;) &#125;&#125; 指令缩写1234&lt;!-- bad --&gt;&lt;input v-bind:value=&quot;newTodoText&quot; :placeholder=&quot;newTodoInstructions&quot; v-on:input=&quot;onInput&quot; /&gt;&lt;!-- good --&gt;&lt;input :value=&quot;newTodoText&quot; :placeholder=&quot;newTodoInstructions&quot; @input=&quot;onInput&quot; /&gt; 组件名为多个单词我们开发过程中自定义的组件的名称需要为多个单词，这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 123456789101112131415161718// goodVue.component(&#x27;todo-item&#x27;, &#123; // ...&#125;)export default &#123; name: &#x27;TodoItem&#x27;, // ...&#125;// badVue.component(&#x27;todo&#x27;, &#123; // ...&#125;)export default &#123; name: &#x27;Todo&#x27;, // ...&#125; 多个属性进行分行在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。 12345&lt;!-- good --&gt;&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; /&gt;&lt;!-- bad --&gt;&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; /&gt; 元素特性的顺序原生属性放前面，指令其次，传参和方法放最后 123456- class, id, ref- name, data-*, src, alt, for, type, href, value, max, min- title, placeholder, aria-*, role- required, readonly, disabled- v-model, v-for, key, v-if, v-show, v-bind,:- foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; 关于组件内样式为组件样式设置作用域 12345678910111213/* bad */&lt;style&gt;.btn-close &#123; background-color: red;&#125;&lt;/style&gt;/* good */&lt;style scoped&gt;.button-close &#123; background-color: red;&#125;&lt;/style&gt; 若要改变第三方组件库的样式，需要加上顶级作用域。 12345678910/* bad */.ivu-input &#123; width: 254px !important;&#125;/* good */.customerForm .ivu-input &#123; width: 254px !important;&#125;/* .customerForm为当前组件的顶级dom */ 关于组件结构组件结构遵循从上往下 template，script，style 的结构。 123456789&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; script 部分各方法成员遵循以下顺序放置。 12345678910- name- components- props- data- methods- computed- watch- created- mounted- update 清除定时器或者事件监听由于项目中有些页面难免会碰到需要定时器或者事件监听。但是在离开当前页面的时候，定时器如果不及时合理地清除，会造成业务逻辑混乱甚至应用卡死的情况，这个时就需要清除定时器事件监听，即在页面卸载（关闭）的生命周期函数里，清除定时器。 1234567891011121314151617181920methods:&#123; resizeFun () &#123; this.tableHeight = window.innerHeight - document.getElementById(&#x27;table&#x27;).offsetTop - 128 &#125;, setTimer() &#123; this.timer = setInterval(() =&gt; &#123; &#125;) &#125;, clearTimer() &#123; clearInterval(this.timer) this.timer = null &#125;&#125;,mounted() &#123; this.setTimer() window.addEventListener(&#x27;resize&#x27;, this.resizeFun)&#125;,beforeDestroy() &#123; window.removeEventListener(&#x27;resize&#x27;, this.resizeFun) this.clearTimer()&#125; 路由懒加载Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。 1234&#123; path: &#x27;/Home&#x27;, component: () =&gt; import(&#x27;@/views/Home.vue&#x27;)&#125; 职责单一任何时候尽量是的一个函数就做一件事情，而不是将各种逻辑全部耦合在一起，提高单个函数的复用性和可读性。比如：每个页面都会在加载完成时进行数据的请求并展示到页面。 12345678910111213141516171819202122232425262728293031// badmethods: &#123; getList1() &#123; // to do ... &#125;, getList2() &#123; // to do ... &#125;&#125;,created() &#123; this.getList1() this.getList2()&#125;,// goodmethods: &#123; // 将全部的请求行为聚合在init函数中 init() &#123; this.getList1() this.getList2() &#125;, getList1() &#123; // to do ... &#125;, getList2() &#123; // to do ... &#125;&#125;,created() &#123; this.init();&#125;, 第三方 UI 组件按需引入我们在项目中使用的第三方 UI 组件，如果我们直接引入整个组件库，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 vant 为例： 1、首先，安装 babel-plugin-component 1npm install babel-plugin-component -D 2、修改 .babelrc 123456789&#123; &quot;plugins&quot;: [ [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;vant&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: true &#125;] ]&#125; 3、引入部分组件： 1234import Vue from &#x27;vue&#x27;import &#123; Button &#125; from &#x27;vant&#x27;Vue.use(Button) 图片篇：使用恰当的图片格式。 jpg：适用于内容图片多为照片之类的。 png：适用于而饰图片，通常更适合用无损压缩。 gif： 基本上除了 gif 动画外不要使用。 webP：大大减小图片的体积，但是移动端有兼容性问题。 使用雪碧图雪碧图，CSS Sprites，国内也叫 CSS 精灵，是一种 CSS 图像合成技术，主要用于小图片显示。 雪碧图的优点是把诸多小图片合成一张大图，利用backround-position属性值来确定图片呈现的位置，这样就能减少 http 请求，到达性能优化的效果。 使用 iconfonticonfont(字体图标)，即通过字体的方式展示图标，多用于渲染图标、简单图形、特殊字体等。 使用 iconfont 时，由于只需要引入对应的字体文件即可，这种方法可有效减少 HTTP 请求次数，而且一般字体体积较小，所以请求传输数据量较少。与直接引入图片不同，iconfont 可以像使用字体一样，设置大小、颜色及其他样式，且不存在失真的情况。 图片懒加载图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载。 1234567891011121314151617function lazyload() &#123; var images = document.getElementsByTagName(&#x27;img&#x27;) var len = images.length var n = 0 //存储图片加载到的位置，避免每次都从第一张图片开始遍历 return function () &#123; var seeHeight = document.documentElement.clientHeight for (var i = n; i &lt; len; i++) &#123; if (images[i].getBoundingClientRect().top &lt; seeHeight) &#123; //方法二: 当图片的视口top出现在视口中 if (images[i].getAttribute(&#x27;src&#x27;) === &#x27;images/default.jpg&#x27;) &#123; images[i].src = images[i].getAttribute(&#x27;data-src&#x27;) &#125; n = n + 1 &#125; &#125; &#125;&#125; vue 项目可以 vue-lazyload 插件实现图片懒加载 main.js 中全局引入： 1234567import VueLazyLoad from &#x27;vue-lazyload&#x27;Vue.use(VueLazyLoad, &#123; preLoad: 1, error: require(&#x27;./assets/img/error.jpg&#x27;), loading: require(&#x27;./assets/img/homePage_top.jpg&#x27;), attempt: 2,&#125;) 页面中使用 123&lt;li v-for=&quot;(item,index) in imgList&quot;&gt; &lt;img v-lazy=&quot;item&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;","categories":[],"tags":[]},{"title":"前端优化代码","slug":"前端代码优化","date":"2022-04-24T01:40:58.444Z","updated":"2022-04-24T01:59:32.265Z","comments":true,"path":"2022/04/24/前端代码优化/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/","excerpt":"","text":"前端优化代码所谓无规矩不成方圆，前端时间在团队 code-review 中发现，不同时期不同开发人员写的代码可谓五花八门。因此我们提出了一些相关代码方面的规范，希望日后能形成团队的编码规范。 本文主要针对一些 JavaScript 进行优化，使之更加健壮，可读性更强，更以维护。gitthub地址：https://github.com/Michael-lzg/my--article/blob/master/other/前端代码优化.md 上一篇：code-review之前端代码规范 if 判断的优化JavaScript 条件语句在我们平时的开发中是不可避免要用到的，但是很多时候我们的代码写的并不好，一连串的 if-else 或者多重嵌套判断都会使得代码很臃肿，下面举例进行优化。 需求：现在有 4 个产品，分别是手机、电脑、电视机、游戏机，当然每个产品显示的价格不一样。 1、最简单的方法：if 判断 12345678910111213141516171819let commodity = &#123; phone: &#x27;手机&#x27;, computer: &#x27;电脑&#x27;, television: &#x27;电视&#x27;, gameBoy: &#x27;游戏机&#x27;,&#125;function price(name) &#123; if (name === commodity.phone) &#123; console.log(1999) &#125; else if (name === commodity.computer) &#123; console.log(9999) &#125; else if (name === commodity.television) &#123; console.log(2999) &#125; else if (name === commodity.gameBoy) &#123; console.log(3999) &#125;&#125;price(&#x27;手机&#x27;) // 9999 缺点：代码太长了,维护和阅读都很不友好 2、好一点的方法：Switch 1234567891011121314151617181920212223let commodity = &#123; phone: &#x27;手机&#x27;, computer: &#x27;电脑&#x27;, television: &#x27;电视&#x27;, gameBoy: &#x27;游戏机&#x27;,&#125;const price = (name) =&gt; &#123; switch (name) &#123; case commodity.phone: console.log(1999) break case commodity.computer: console.log(9999) break case commodity.television: console.log(2999) break case commodity.gameBoy: console.log(3999) break &#125;&#125;price(&#x27;手机&#x27;) // 9999 3、更优的方法: 策略模式 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。它提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。 1234567891011const commodity = new Map([ [&#x27;phone&#x27;, 1999], [&#x27;computer&#x27;, 9999], [&#x27;television&#x27;, 2999], [&#x27;gameBoy&#x27;, 3999],])const price = (name) =&gt; &#123; return commodity.get(name)&#125;price(&#x27;phone&#x27;) // 1999 includes 的优化includes 是 ES7 新增的 API，与 indexOf 不同的是 includes 直接返回的是 Boolean 值，indexOf 则 返回的索引值, 数组和字符串都有 includes 方法。 需求：我们来实现一个身份认证方法，通过传入身份 Id 返回对应的验证结果 传统方法 1234567function verifyIdentity(identityId) &#123; if (identityId == 1 || identityId == 2 || identityId == 3 || identityId == 4) &#123; return &#x27;你的身份合法，请通行！&#x27; &#125; else &#123; return &#x27;你的身份不合法&#x27; &#125;&#125; includes 优化 1234567function verifyIdentity(identityId) &#123; if ([1, 2, 3, 4].includes(identityId)) &#123; return &#x27;你的身份合法，请通行！&#x27; &#125; else &#123; return &#x27;你的身份不合法&#x27; &#125;&#125; for 循环在 JavaScript 中，我们可以使用 for()， while()， for(in)，for(in)几种循环，事实上，这三种循环中 for(in) 的效率极差，因为他需要查询散列键，所以应该尽量少用。 for 循环是最传统的语句，它以变量 i 作为索引，以跟踪访问的位置，对数组进行操作。 1234var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]) //结果依次a,b,c&#125; 以上的方法有一个问题：就是当数组的长度到达百万级时，arr.length 就要计算一百万次，这是相当耗性能的。所以可以采用以下方法就行改良。 1234var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for (var i = 0, length = arr.length; i &lt; length; i++) &#123; console.log(arr[i]) //结果依次a,b,c&#125; 此时 arr.length 只需要计算一次，优化了性能。 for-in 一般用来来遍历对象的属性的，不过属性需要 enumerable（可枚举）才能被读取到。同时 for-in 也可以遍历数组，遍历数组的时候遍历的是数组的下标值。 123456789var obj = &#123; 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, 2: &#x27;c&#x27; &#125;for (var key in obj) &#123; console.log(key) //结果为依次为0，1，2&#125;var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for (var key in a) &#123; console.log(key) //结果为依次为0，1，2&#125; for-of 语句看着有点像 for-in 语句，但是和 for-of 语句不同的是它不可以循环对象，只能循环数组。 1234var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]for (var value of arr) &#123; console.log(value) // 结果依次为a,b,c&#125; for-of 比 for-in 循环遍历数组更好。for-of 只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。for-in 需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且 for-in 的 key 是 String 类型，有转换过程，开销比较大。 所以在开发过程中循环数组尽量避免使用 for-in。 数组去重数组去重是实际开发处理数据中经常遇到的，方法有很多，这里就不一一例举了。 1、最传统的方法：利用数组的 indexOf 下标属性来查询。 1234567891011function unique4(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique4([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]))// [1, 2, 3, 5, 6, 7, 4] 2、优化：利用 ES6 的 Set 方法。 Set 本身是一个构造函数，用来生成 Set 数据结构。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。 12345function unique4(arr) &#123; return Array.from(new Set(arr)) // 利用Array.from将Set结构转换成数组&#125;console.log(unique4([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]))// [1, 2, 3, 5, 6, 7, 4] 箭头函数箭头函数表达式的语法比函数表达式更简洁。所以在开发中更推荐使用箭头函数。特别是在 vue 项目中，使用箭头函数不需要在更 this 重新赋一个变量。 12345678910// 使用functionsvar arr = [5, 3, 2, 9, 1]var arrFunc = arr.map(function (x) &#123; return x * x&#125;)console.log(arrFunc)// 使用箭头函数var arr = [5, 3, 2, 9, 1]var arrFunc = arr.map((x) =&gt; x * x) 要注意的是，箭头函数不绑定 arguments，取而代之用 rest 参数…解决。 1234567891011// 不能使用 argumentslet fun1 = (b) =&gt; &#123; console.log(arguments)&#125;fun1(2, 92, 32, 32) // Uncaught ReferenceError: arguments is not defined// 使用rest 参数let fun2 = (...c) =&gt; &#123; console.log(c)&#125;fun2(3, 82, 32, 11323) // [3, 82, 32, 11323] Dom 的创建创建多个 dom 元素时，先将元素 append 到 DocumentFragment 中，最后统一将 DocumentFragment 添加到页面。 常规方法； 12345for (var i = 0; i &lt; 1000; i++) &#123; var el = document.createElement(&#x27;p&#x27;) el.innerHTML = i document.body.appendChild(el)&#125; 使用 DocumentFragment 优化多次 append 1234567var frag = document.createDocumentFragment()for (var i = 0; i &lt; 1000; i++) &#123; var el = document.createElement(&#x27;p&#x27;) el.innerHTML = i frag.appendChild(el)&#125;document.body.appendChild(frag) 更优的方法:使用一次 innerHTML 赋值代替构建 dom 元素 12345var html = []for (var i = 0; i &lt; 1000; i++) &#123; html.push(&#x27;&lt;p&gt;&#x27; + i + &#x27;&lt;/p&gt;&#x27;)&#125;document.body.innerHTML = html.join(&#x27;&#x27;) 内存泄漏系统进程不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。当内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 引起内存泄漏的原因 全局变量1、未声明变量或者使用 this 创建的变量(this 的指向是 window)都会引起内存泄漏 123456789function fn() &#123; a = &quot;Actually, I&#x27;m a global variable&quot;&#125;fn()function fn() &#123; this.a = &quot;Actually, I&#x27;m a global variable&quot;&#125;fn() 解决方法： 避免创建全局变量 使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 use strict。 2、在 vue 单页面应用，声明的全局变量在切换页面的时候没有清空 1234567891011121314151617&lt;template&gt; &lt;div id=&quot;home&quot;&gt; 这里是首页 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted() &#123; window.test = &#123; // 此处在全局window对象中引用了本页面的dom对象 name: &#x27;home&#x27;, node: document.getElementById(&#x27;home&#x27;) &#125; &#125; &#125;&lt;/script&gt; 解决方案: 在页面卸载的时候顺便处理掉该引用。 123destroyed () &#123; window.test = null // 页面卸载的时候解除引用&#125; 闭包闭包引起的内存泄漏原因：闭包可以维持函数内局部变量，使其得不到释放。 123456function fn() &#123; var a = &quot;I&#x27;m a&quot; return function () &#123; console.log(a) &#125;&#125; 解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。 定时器或事件监听由于项目中有些页面难免会碰到需要定时器或者事件监听。但是在离开当前页面的时候，定时器如果不及时合理地清除，会造成业务逻辑混乱甚至应用卡死的情况，这个时就需要清除定时器事件监听，即在页面卸载（关闭）的生命周期函数里，清除定时器。 1234567891011121314151617181920methods:&#123; resizeFun () &#123; this.tableHeight = window.innerHeight - document.getElementById(&#x27;table&#x27;).offsetTop - 128 &#125;, setTimer() &#123; this.timer = setInterval(() =&gt; &#123; &#125;) &#125;, clearTimer() &#123;//清除定时器 clearInterval(this.timer) this.timer = null &#125;&#125;,mounted() &#123; this.setTimer() window.addEventListener(&#x27;resize&#x27;, this.resizeFun)&#125;,beforeDestroy() &#123; window.removeEventListener(&#x27;resize&#x27;, this.resizeFun) this.clearTimer()&#125; 防抖与节流在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。 案例 1：远程搜索时需要通过接口动态的获取数据，若是每次用户输入都接口请求，是浪费带宽和性能的。 123456789101112131415161718192021&lt;Select :remote-method=&quot;remoteMethod&quot;&gt; &lt;Option v-for=&quot;item in temoteList&quot; :value=&quot;item.value&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.label&#125;&#125;&lt;/Option&gt;&lt;/Select&gt;&lt;script&gt;function debounce(fn, wait) &#123; let timeout = null return function () &#123; if (timeout !== null) clearTimeout(timeout) timeout = setTimeout(fn, wait) &#125;&#125;export default &#123; methods：&#123; remoteMethod：debounce(function (query) &#123; // to do ... &#125;, 200), &#125;&#125;&lt;script&gt; 案例 2：持续触发 scroll 事件时，并不立即执行 handle 函数，当 1000 毫秒内没有触发 scroll 事件时，才会延时触发一次 handle 函数。 1234567891011function debounce(fn, wait) &#123; let timeout = null return function () &#123; if (timeout !== null) clearTimeout(timeout) timeout = setTimeout(fn, wait) &#125;&#125;function handle() &#123; console.log(Math.random())&#125;window.addEventListener(&#x27;scroll&#x27;, debounce(handle, 1000)) 异步加载 js默认情况下，浏览器是同步加载 js 脚本，解析 html 过程中，遇到 &lt;script&gt; 标签就会停下来，等脚本下载、解析、执行完后，再继续向下解析渲染。 如果 js 文件体积比较大，下载时间就会很长，容易造成浏览器堵塞，浏览器页面会呈现出“白屏”效果，用户会感觉浏览器“卡死了”，没有响应。此时，我们可以让 js 脚本异步加载、执行。 12&lt;script src=&quot;path/to/home.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;path/to/home.js&quot; async&gt;&lt;/script&gt; 上面代码中，&lt;script&gt; 标签分别有 defer 和 async 属性，浏览器识别到这 2 个属性时 js 就会异步加载。也就是说，浏览器不会等待这个脚本下载、执行完毕后再向后执行，而是直接继续向后执行 defer 与 async 区别: defer：DOM 结构完全生成，以及其他脚本执行完成，才会执行（渲染完再执行）。有多个 defer 脚本时，会按照页面出现的顺序依次加载、执行。 async：一旦下载完成，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染（下载完就执行）。有多个 async 脚本时，不能保证按照页面出现顺序加载、执行","categories":[],"tags":[]},{"title":"HTML标签","slug":"HTML","date":"2022-04-24T01:40:58.440Z","updated":"2022-04-24T01:59:32.185Z","comments":true,"path":"2022/04/24/HTML/","link":"","permalink":"https://data-cz.github.io/2022/04/24/HTML/","excerpt":"HTML 语义化 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的class 为什么需要语义化： 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护","text":"HTML 语义化 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的class 为什么需要语义化： 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 Doctype作用？标准模式与兼容模式各有什么区别? &lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作 HTML5 为什么只需要写 ？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行） 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 常见的空元素: &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u 对可用性产生负面影响的元素：frame，frameset，noframes 支持HTML5新标签： IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt; 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现123456789CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件 HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete&#x3D;off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker 也可以调用localstorge、cookies等本地存储方式 webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 如何在页面上实现一个圆形的可点击区域？ map+area或者svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果 1&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响 strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容 i内容展示为斜体，em表示强调的文本 页面导入样式时，使用 link 和 @import 有什么区别？ link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS 页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 @import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题 介绍一下你对浏览器内核的理解？ 浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎 渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机 JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些？ Blink内核：新版 Chrome、新版 Opera Webkit内核：Safari、原Chrome Gecko内核：FireFox、Netscape6及以上版本 Trident内核（又称MSHTML内核）：IE、国产浏览器 Presto内核：原Opera7及以上 HTML5有哪些新特性？ 新增选择器 document.querySelector、document.querySelectorAll 拖拽释放(Drag and drop) API 媒体播放的 video 和 audio 本地存储 localStorage 和 sessionStorage 离线应用 manifest 桌面通知 Notifications 语意化标签 article、footer、header、nav、section 增强表单控件 calendar、date、time、email、url、search 地理位置 Geolocation 多任务 webworker 全双工通信协议 websocket 历史管理 history 跨域资源共享(CORS) Access-Control-Allow-Origin 页面可见性改变事件 visibilitychange 跨窗口通信 PostMessage Form Data 对象 绘画 canvas HTML5移除了那些元素？ 纯表现的元素：basefont、big、center、font、s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 如何处理HTML5新标签的浏览器兼容问题？ 通过 document.createElement 创建新标签 使用垫片 html5shiv.js 如何区分 HTML 和 HTML5？ DOCTYPE声明、新增的结构元素、功能元素 HTML5的离线储存工作原理能不能解释一下，怎么使用？ HTML5的离线储存原理： 用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容 HTML5的离线储存使用： 在文档的 html 标签设置 manifest 属性，如 manifest&#x3D;”&#x2F;offline.appcache” 在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache 在 web 服务器配置正确的 MIME-type，即 text&#x2F;cache-manifest 浏览器是怎么对HTML5的离线储存资源进行管理和加载的？ 在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件 如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储 如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源。 iframe 有那些优点和缺点？ 优点： 用来加载速度较慢的内容（如广告） 可以使脚本可以并行下载 可以实现跨子域通信 缺点： iframe 会阻塞主页面的 onload 事件 无法被一些搜索引擎索识别 会产生很多页面，不容易管理 label 的作用是什么？怎么使用的？ label标签来定义表单控件的关系： 当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上 使用方法1： &lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt; 使用方法2： &lt;label&gt;date: &lt;input type=&quot;text&quot;/&gt;&lt;/label&gt; 如何实现浏览器内多个标签页之间的通信？ iframe + contentWindow postMessage SharedWorker(Web Worker API) storage 事件(localStorge API) WebSocket webSocket 如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 当用户浏览其他页面，暂停网站首页幻灯自动播放 完成登陆后，无刷新自动同步其他页面的登录状态 title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？ title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响 strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b 是展示强调内容 i 内容展示为斜体，em 表示强调的文本 自然样式标签：b, i, u, s, pre 语义样式标签：strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签","categories":[],"tags":[]},{"title":"DOM事件的总结","slug":"DOM事件的总结","date":"2022-04-24T01:40:58.435Z","updated":"2022-04-24T01:59:31.980Z","comments":true,"path":"2022/04/24/DOM事件的总结/","link":"","permalink":"https://data-cz.github.io/2022/04/24/DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"知识点主要包括以下几个方面： 基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ….”。","text":"知识点主要包括以下几个方面： 基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ….”。 DOM事件模型、DOM事件流 面试官如果问你“DOM事件模型”，你不一定知道怎么回事。其实说的就是捕获和冒泡。 DOM事件流，指的是事件传递的三个阶段。 描述DOM事件捕获的具体流程 讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。 能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。 Event对象的常见应用（Event的常用api方法） DOM事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。 自定义事件（非常重要） 一般人可以讲出事件和注册事件，但是如果让你讲自定义事件，能知道的人，就更少了。 DOM事件的级别 DOM事件的级别，准确来说，是DOM标准定义的级别。包括： DOM0的写法： 123element.onclick = function () &#123;&#125; 上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。 DOM2的写法： 123element.addEventListener(&#x27;click&#x27;, function () &#123;&#125;, false); 【重要】上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）。如果不写，则默认为false。 DOM3的写法： 123element.addEventListener(&#x27;keyup&#x27;, function () &#123;&#125;, false); DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。 PS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。 总结：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。 DOM事件模型 DOM事件模型讲的就是捕获和冒泡，一般人都能回答出来。 捕获：从上往下。 冒泡：从下（目标元素）往上。 DOM事件流 DOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。 完整的事件流，分三个阶段： 捕获：从 window 对象传到 目标元素。 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。 冒泡：从目标元素传到 Window 对象。 描述DOM事件捕获的具体流程 很少有人能说完整。 捕获的流程 说明：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。 PS1：第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。 代码如下： 123456789101112131415161718192021222324window.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 window&quot;);&#125;, true);document.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 document&quot;);&#125;, true);document.documentElement.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 html&quot;);&#125;, true);document.body.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 body&quot;);&#125;, true);fatherBox.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 father&quot;);&#125;, true);childBox.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 child&quot;);&#125;, true); 补充一个知识点： 在 js中： 如果想获取 body 节点，方法是：document.body； 但是，如果想获取 html节点，方法是document.documentElement。 冒泡的流程 与捕获的流程相反 Event对象的常见 api 方法 用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法： 方法一 1event.preventDefault(); 解释：阻止默认事件。 比如，已知&lt;a&gt;标签绑定了click事件，此时，如果给&lt;a&gt;设置了这个方法，就阻止了链接的默认跳转。 方法二：阻止冒泡 这个在业务中很常见。 有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。 w3c的方法：（火狐、谷歌、IE11） 1event.stopPropagation(); IE10以下则是： 1event.cancelBubble = true; 兼容代码如下： 12345678910111213box3.onclick = function (event) &#123; alert(&quot;child&quot;); //阻止冒泡 event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125; 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。 方法三：设置事件优先级 1event.stopImmediatePropagation(); 这个方法比较长，一般人没听说过。解释如下： 比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到stopImmediatePropagation方法了。做法是：在事件A的响应函数中加入这句话。 大家要记住 event 有这个方法。 属性4、属性5（事件委托中用到） 12345event.currentTarget //当前所绑定的事件对象。在事件委托中，指的是【父元素】。event.target //当前被点击的元素。在事件委托中，指的是【子元素】。 上面这两个属性，在事件委托中经常用到。 总结：上面这几项，非常重要，但是容易弄混淆。 自定义事件 自定义事件的代码如下： 12345678 var myEvent = new Event(&#x27;clickTest&#x27;); element.addEventListener(&#x27;clickTest&#x27;, function () &#123; console.log(&#x27;smyhvae&#x27;); &#125;);//元素注册事件 element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作： 123456789var myEvent = new Event(&#x27;clickTest&#x27;);element.addEventListener(&#x27;clickTest&#x27;, function () &#123; console.log(&#x27;smyhvae&#x27;);&#125;);setTimeout(function () &#123; element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest&#125;, 1000);","categories":[],"tags":[]},{"title":"canvas基础","slug":"canvas基础","date":"2022-04-24T01:40:58.424Z","updated":"2022-04-24T01:59:32.029Z","comments":true,"path":"2022/04/24/canvas基础/","link":"","permalink":"https://data-cz.github.io/2022/04/24/canvas%E5%9F%BA%E7%A1%80/","excerpt":"","text":"CanvasCanvas 是 HTML5 提供的一个用于展示绘图效果的标签. Canvas 原意为画布, 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现。 canvas 的使用领域 游戏 大数据可视化数据 banner 广告 多媒体 模拟仿真 远程操作 图形编辑 判断浏览器是否支持 canvas 标签 123456var canvas = document.getElementById(&#x27;canvas&#x27;)if (canvas.getContext) &#123; console.log(&#x27;你的浏览器支持Canvas!&#x27;)&#125; else &#123; console.log(&#x27;你的浏览器不支持Canvas!&#x27;)&#125; canvas 的基本用法1、使用 canvas 标签, 即可在页面中开辟一格区域，可以设置其宽高，宽高为 300 和 150 1&lt;canvas&gt;&lt;/canvas&gt; 2、获取 dom 元素 canvas canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api。 1var cas = document.querySelector(&#x27;canvas&#x27;) 3、通过 cas 获取上下文对象(画布对象!) 1var ctx = cas.getContext(&#x27;2d&#x27;) 4、通过 ctx 开始画画（设置起点 设置终点 连线-描边 ） 123ctx.moveTo(10, 10)ctx.lineTo(100, 100)ctx.stroke() 绘制线条 设置开始位置: context.moveTo( x, y ). 设置终点位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath(). canvas 还可以设置线条的相关属性，如下： CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.strokeStyle 设置线条颜色. CanvasRenderingContext2D.lineCap 设置线末端类型，’butt’( 默认 ), ‘round’, ‘square’. CanvasRenderingContext2D.lineJoin 设置相交线的拐点， ‘miter’(默认)，’round’, ‘bevel’, CanvasRenderingContext2D.getLineDash() 获得线段样式数组. CanvasRenderingContext2D.setLineDash() 设置线段样式. CanvasRenderingContext2D.lineDashOffset 绘制线段偏移量. 封装一个画矩形的方法 123456789101112function myRect(ctxTmp, x, y, w, h) &#123; ctxTmp.moveTo(x, y) ctxTmp.lineTo(x + w, y) ctxTmp.lineTo(x + w, y + h) ctxTmp.lineTo(x, y + h) ctxTmp.lineTo(x, y) ctxTmp.stroke()&#125;var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)myRect(ctx, 50, 50, 200, 200) 绘制矩形 fillRect( x , y , width , height) 填充以(x,y)为起点宽高分别为 width、height 的矩形 默认为黑色 stokeRect( x , y , width , height) 绘制一个空心以(x,y)为起点宽高分别为 width、height 的矩形 clearRect( x, y , width , height ) 清除以(x,y)为起点宽高分别为 width、height 的矩形 为透明 绘制圆弧绘制圆弧的方法有 CanvasRenderingContext2D.arc() CanvasRenderingContext2D.arcTo() 6 个参数: x，y(圆心的坐标)，半径，起始的弧度(不是角度 deg)，结束的弧度，(bool 设置方向 ! ) 12345678910var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)ctx.arc(100, 100, 100, 0, degToArc(360))ctx.stroke()// 角度转弧度function degToArc(num) &#123; return (Math.PI / 180) * num&#125; 绘制扇形123456789101112var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)ctx.arc(300, 300, 200, degToArc(125), degToArc(300))// 自动连回原点ctx.closePath()ctx.stroke()function degToArc(num) &#123; return (Math.PI / 180) * num&#125; 制作画笔 声明一个变量作为标识 鼠标按下的时候，记录起点位置 鼠标移动的时候，开始描绘并连线 鼠标抬起的时候，关闭开关 123456789101112131415161718192021222324252627var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)var isDraw = false// 鼠标按下事件cas.addEventListener(&#x27;mousedown&#x27;, function () &#123; isDraw = true ctx.beginPath()&#125;)// 鼠标移动事件cas.addEventListener(&#x27;mousemove&#x27;, function (e) &#123; if (!isDraw) &#123; // 没有按下 return &#125; // 获取相对于容器内的坐标 var x = e.offsetX var y = e.offsetY ctx.lineTo(x, y) ctx.stroke()&#125;)cas.addEventListener(&#x27;mouseup&#x27;, function () &#123; // 关闭开关了! isDraw = false&#125;) 手动涂擦1234567891011121314151617181920212223242526var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)ctx.fillRect(0, 0, 600, 600)// 开关var isClear = falsecas.addEventListener(&#x27;mousedown&#x27;, function () &#123; isClear = true&#125;)cas.addEventListener(&#x27;mousemove&#x27;, function (e) &#123; if (!isClear) &#123; return &#125; var x = e.offsetX var y = e.offsetY var w = 20 var h = 20 ctx.clearRect(x, y, w, h)&#125;)cas.addEventListener(&#x27;mouseup&#x27;, function () &#123; isClear = false&#125;) 刮刮乐 首先需要设置奖品和画布，将画布置于图片上方盖住， 随机设置生成奖品。 当手触摸移动的时候，可以擦除部分画布，露出奖品区。html 1234&lt;div&gt; &lt;img src=&quot;./images/2.jpg&quot; alt=&quot;&quot; /&gt; &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;/div&gt; css 12345678910111213141516img &#123; width: 600px; height: 600px; position: absolute; top: 10%; left: 30%;&#125;canvas &#123; width: 600px; height: 600px; position: absolute; top: 10%; left: 30%; border: 1px solid #000;&#125; js 123456789101112131415161718192021222324252627282930var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)var img = document.querySelector(&#x27;img&#x27;)// 加一个遮罩层ctx.fillStyle = &#x27;#ccc&#x27;ctx.fillRect(0, 0, cas.width, cas.height)setImgUrl()// 开关var isClear = falsecas.addEventListener(&#x27;mousedown&#x27;, function () &#123; isClear = true&#125;)cas.addEventListener(&#x27;mousemove&#x27;, function (e) &#123; if (!isClear) &#123; return &#125; var x = e.offsetX var y = e.offsetY ctx.clearRect(x, y, 30, 30)&#125;)cas.addEventListener(&#x27;mouseup&#x27;, function () &#123; isClear = false&#125;)function setImgUrl() &#123; var arr = [&#x27;./images/1.jpg&#x27;, &#x27;./images/2.jpg&#x27;, &#x27;./images/3.jpg&#x27;, &#x27;./images/4.jpg&#x27;] // 0-3 var random = Math.round(Math.random() * 3) img.src = arr[random]&#125; 在线画图drawImage() 方法在画布上绘制图像、画布或视频。drawImage() 方法也能够绘制图像的某些部分，以及&#x2F;或者增加或减少图像的尺寸。参数如下 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 12345678910var cas = document.querySelector(&#x27;canvas&#x27;)var ctx = cas.getContext(&#x27;2d&#x27;)// 先创建图片对象var img = new Image()img.src = &#x27;./images/1.jpg&#x27;// 图片加载完之后img.onload = function () &#123; ctx.drawImage(img, 206, 111, 32, 38, 100, 100, 32, 38)&#125;","categories":[],"tags":[]},{"title":"","slug":"页面布局","date":"2022-04-24T01:39:40.207Z","updated":"2022-04-24T01:59:31.452Z","comments":true,"path":"2022/04/24/页面布局/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/","excerpt":"","text":"title: 页面布局date: 2020-10-13 15:34:10 页面布局 问题：假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。 分析： 初学者想到的答案有两种： 方法1：浮动 方法2：绝对定位 但要求你能至少写出三四种方法，才算及格。剩下的方法如下： 方法3：flexbox。移动开发里经常用到。 方法4：表格布局 table。虽然已经淘汰了，但也应该了解。 方法5：网格布局 grid 方法1、浮动： 左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。 方法2、绝对定位： 左侧设置为绝对定位， left：0px。右侧设置为绝对定位， right：0px。中间设置为绝对定位，left 和right 都为300px，即可。中间的宽度会自适应。 使用article标签作为容器，包裹左、中、右三个部分。 方法1 和方法2 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0px; margin: 0px; &#125; .layout &#123; margin-bottom: 150px; &#125; .layout article div &#123; /*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/ height: 100px; &#125; /* 方法一 start */ .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; .layout.float .center &#123; background: green; &#125; /* 方法一 end */ /* 方法二 start */ .layout.absolute .left-center-right &#123; position: relative; &#125; .layout.absolute .left &#123; position: absolute; left: 0; width: 300px; background: red; &#125; /* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */ .layout.absolute .center &#123; position: absolute; left: 300px; right: 300px; background: green; &#125; .layout.absolute .right &#123; position: absolute; right: 0; width: 300px; background: blue; &#125; /* 方法二 end */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法一：浮动 start --&gt; &lt;!-- 输入 section.layout.float，即可生成 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;!-- 用 article 标签包裹左、中、右三个部分 --&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;!-- 输入 div.left+div.right+div.center，即可生成 --&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; 浮动解决方案 我是 center &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 方法一：浮动 end --&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方法3、flexbox布局 将左中右所在的容器设置为display: flex，设置两侧的宽度后，然后让中间的flex = 1，即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .layout article div &#123; height: 100px; &#125; .left-center-right &#123; display: flex; &#125; .layout.flex .left &#123; width: 300px; background: red; &#125; .layout.flex .center &#123; flex: 1; background: green; &#125; .layout.flex .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout flex&quot;&gt; &lt;article class=&quot;left-center-right-&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;flex布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方法4、表格布局 table 设置整个容器的宽度为100%，设置三个部分均为表格，然后左边的单元格为 300px，右边的单元格为 300px，即可。中间的单元格会自适应。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .layout.table div &#123; height: 100px; &#125; /* 重要：设置容器为表格布局，宽度为100% */ .layout.table .left-center-right &#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-center-right div &#123; display: table-cell; /* 重要：设置三个模块为表格里的单元*/ &#125; .layout.table .left &#123; width: 300px; background: red; &#125; .layout.table .center &#123; background: green; &#125; .layout.table .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;表格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 方法5、网格布局 grid 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; /* 重要：设置容器为网格布局，宽度为100% */ .layout.grid .left-center-right &#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; /* 重要：设置网格为三列，并设置每列的宽度。即可。*/ &#125; .layout.grid .left &#123; background: red; &#125; .layout.grid .center &#123; background: green; &#125; .layout.grid .right &#123; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;网格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果： 延伸：五种方法的对比 五种方法的优缺点 考虑中间模块的高度问题 兼容性问题：实际开发中，哪个最实用？ 方法1：浮动： 优点：兼容性好。 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。 方法:2：绝对定位 优点：快捷。 缺点：导致子元素也脱离了标准文档流，可实用性差。 方法3：flex 布局（CSS3中出现的） 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。 方法4：表格布局 优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局 缺点：因为三个部分都当成了单元格来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。 什么时候用 flex 布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。 方法5：网格布局 CSS3中引入的布局，很好用。代码量简化了很多。 PS：面试提到网格布局，说明我们对新技术是有追求的。 延伸：如果题目中去掉高度已知 问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？ 分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。 答案是：flex 布局和表格布局可以通用，其他三个布局都不能用了。 总结 涉及到的知识点： 语义化掌握到位：每个区域用section、article代表容器、div代表块儿。如果通篇都用 div，那就是语义化没掌握好。 页面布局理解深刻。 CSS基础知识扎实。 思维灵活且积极上进。题目中可以通过网格布局来体现。 代码书写规范。注意命名。上面的代码中，没有一行代码是多的。","categories":[],"tags":[]},{"title":"","slug":"面试题精简版本","date":"2022-04-24T01:39:40.202Z","updated":"2022-04-24T01:59:31.805Z","comments":true,"path":"2022/04/24/面试题精简版本/","link":"","permalink":"https://data-cz.github.io/2022/04/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/","excerpt":"","text":"title: 面试题date: 2020-10-13 15:34:10 一、CSS相关1.1 左边定宽，右边自适应方案：float + margin，float + calc1234567891011121314151617/* 方案1 */ .left &#123; width: 120px; float: left;&#125;.right &#123; margin-left: 120px;&#125;/* 方案2 */ .left &#123; width: 120px; float: left;&#125;.right &#123; width: calc(100% - 120px); float: left;&#125; 1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex123456789101112131415161718192021222324252627282930313233343536373839404142434445.wrap &#123; width: 100%; height: 200px;&#125;.wrap &gt; div &#123; height: 100%;&#125;/* 方案1 */.left &#123; width: 120px; float: left;&#125;.right &#123; float: right; width: 120px;&#125;.center &#123; margin: 0 120px; &#125;/* 方案2 */.left &#123; width: 120px; float: left;&#125;.right &#123; float: right; width: 120px;&#125;.center &#123; width: calc(100% - 240px); margin-left: 120px;&#125;/* 方案3 */.wrap &#123; display: flex;&#125;.left &#123; width: 120px;&#125;.right &#123; width: 120px;&#125;.center &#123; flex: 1;&#125; 1.3 左右居中 行内元素: text-align: center 定宽块状元素: 左右 margin 值为 auto 不定宽块状元素: table布局，position + transform 1234567891011121314151617181920212223/* 方案1 */.wrap &#123; text-align: center&#125;.center &#123; display: inline; /* or */ /* display: inline-block; */&#125;/* 方案2 */.center &#123; width: 100px; margin: 0 auto;&#125;/* 方案2 */.wrap &#123; position: relative;&#125;.center &#123; position: absulote; left: 50%; transform: translateX(-50%);&#125; 1.4 上下垂直居中 定高：margin，position + margin(负值) 不定高：position + transform，flex，IFC + vertical-align:middle 1234567891011121314151617181920212223242526272829303132333435363738394041/* 定高方案1 */.center &#123; height: 100px; margin: 50px 0; &#125;/* 定高方案2 */.center &#123; height: 100px; position: absolute; top: 50%; margin-top: -25px;&#125;/* 不定高方案1 */.center &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125;/* 不定高方案2 */.wrap &#123; display: flex; align-items: center;&#125;.center &#123; width: 100%;&#125;/* 不定高方案3 *//* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */.wrap::before &#123; content: &#x27;&#x27;; height: 100%; display: inline-block; vertical-align: middle;&#125;.wrap &#123; text-align: center;&#125;.center &#123; display: inline-block; vertical-align: middle;&#125; 1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距） 延伸： box-sizing content-box：默认值，总宽度 &#x3D; margin + border + padding + width border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width inherit：从父元素继承 box-sizing 属性 1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文 BFC：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 BFC)。产生 BFC 方式如下 float 的值不为 none。 overflow 的值不为 visible。 position 的值不为 relative 和 static。 display 的值为 table-cell, table-caption, inline-block中的任何一个 用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行 IFC：内联格式化上下文，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。 IFC中的line box一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div ）会产生两个匿名块与 div 分隔开，即产生两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列。 用处？ 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中 GFC：网格布局格式化上下文（display: grid） FFC：自适应格式化上下文（display: flex） 二、JS 基础（ES5）2.1 原型 这里可以谈很多，只要围绕 [[ prototype ]] 谈，都没啥问题 2.2 闭包 牵扯作用域，可以两者联系起来一起谈 2.3 作用域 词法作用域，动态作用域 2.4 this 不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数 2.5 call，apply，bind 三者用法和区别 参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call，apply 立即执行，bind 是return 出一个 this “固定”的函数，这也是为什么 bind 是强绑定的一个原因） 注：“固定”这个词的含义，它指的固定是指只要传进去了 context，则 bind 中 return 出来的函数 this 便一直指向 context，除非 context 是个变量 2.6 变量声明提升 js 代码在运行前都会进行 AST 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 AST 解析，这里也可以说是形成词法作用域的主要原因 三、JS 基础（ES6）3.1 let，const let 产生块级作用域（通常配合 for 循环或者 &#123;&#125; 进行使用产生块级作用域），const 申明的变量是常量（内存地址不变） 3.2 Promise 这里你谈 promise的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask(微任务)、macrotask(任务) 的执行顺序，如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人） 3.3 Generator 遍历器对象生成函数，最大的特点是可以交出函数的执行权 function 关键字与函数名之间有一个星号； 函数体内部使用 yield表达式，定义不同的内部状态； next 指针移向下一个状态 这里你可以说说 Generator的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下 回调函数 事件监听 发布&#x2F;订阅 传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。 3.4 async、await Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。 async =&gt; * await =&gt; yield 123456789101112// 基本用法async function timeout (ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms) &#125;)&#125;async function asyncConsole (value, ms) &#123; await timeout(ms) console.log(value)&#125;asyncConsole(&#x27;hello async and await&#x27;, 1000) 注：最好把2，3，4 连到一起讲 3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点 AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置 CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近 CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。 四、框架相关4.1 数据双向绑定原理：常见数据绑定的方案 Object.defineProperty（vue）：劫持数据的 getter 和 setter 脏值检测（angularjs）：通过特定事件进行轮循发布&#x2F;订阅模式：通过消息发布并将消息进行订阅 4.2 VDOM：三个 part 虚拟节点类，将真实 DOM 节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM 节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象 re-render：解析 patch 对象，进行 re-render 补充1：VDOM 的必要性？ 创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。 补充2：vue 为什么采用 vdom？ 引入 Virtual DOM 在性能方面的考量仅仅是一方面。 性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。 Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。 4.3 vue 和 react 区别 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等 不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue 的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render 4.4 为什么用 vue 简洁、轻快、舒服 五、网络基础类5.1 跨域 很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 jsonp、iframe、cors、img、HTML5 postMessage等等。其中用到 html 标签进行跨域的原理就是 html 不受同源策略影响。但只是接受 Get 的请求方式，这个得清楚。 延伸1：img iframe script 来发送跨域请求有什么优缺点？ 1. iframe 优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的 缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。 2. script 优点：可以直接返回json格式的数据，方便处理 缺点：只接受GET请求方式 3. 图片ping 优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法 缺点：不能访问响应文本，只能监听是否响应 延伸2：配合 webpack 进行反向代理？ webpack 在 devServer 选项里面提供了一个 proxy 的参数供开发人员进行反向代理 1234567&#x27;/api&#x27;: &#123; target: &#x27;http://www.example.com&#x27;, // your target host changeOrigin: true, // needed for virtual hosted sites pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; // rewrite path &#125;&#125;, 然后再配合 http-proxy-middleware 插件对 api 请求地址进行代理 123456789const express = require(&#x27;express&#x27;);const proxy = require(&#x27;http-proxy-middleware&#x27;);// proxy api requestsconst exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项// mount `exampleProxy` in web serverconst app = express();app.use(&#x27;/api&#x27;, exampleProxy);app.listen(3000); 然后再用 nginx 把允许跨域的源地址添加到报头里面即可 说到 nginx ，可以再谈谈 CORS 配置，大致如下 123456789101112location / &#123; if ($request_method = &#x27;OPTIONS&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;; add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type&#x27;; add_header &#x27;Access-Control-Max-Age&#x27; 86400; add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;; add_header &#x27;Content-Length&#x27; 0; return 200; &#125;&#125; 5.2 http 无状态无连接 http 协议对于事务处理没有记忆能力 对同一个url请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见，请求过的资源下一次会继续进行请求 http协议无状态中的 状态 到底指的是什么？！ 【状态】的含义就是：客户端和服务器在某次会话中产生的数据 那么对应的【无状态】就意味着：这些数据不会被保留 通过增加cookie和session机制，现在的网络请求其实是有状态的 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话 5.3 http-cache：就是 http 缓存1. 首先得明确 http 缓存的好处 减少了冗余的数据传输，减少网费 减少服务器端的压力 Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间 加快客户端加载网页的速度 2. 常见 http 缓存的类型 私有缓存（一般为本地浏览器缓存） 代理缓存 3. 然后谈谈本地缓存 本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是 第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来 第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器 如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值。 3.1 Cache-Control Cache-Control是HTPP缓存策略中最重要的头，它是HTTP/1.1中出现的，它由如下几个值 no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 max-age：从当前请求开始，允许获取的响应被重用的最长时间（秒）。 1234# 例如：Cache-Control: public, max-age=1000 # 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。 3.2 Expires Expires是HTTP/1.0出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如Mon, 10 Jun 2015 21:31:12 GMT，只要发送请求时间是在Expires之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现Cache-Control：max-age和Expires，那么max-age优先级更高。他们可以这样组合使用 12Cache-Control: publicExpires: Wed, Jan 10 2018 00:27:04 GMT 3.3 所谓的缓存协商 当第一次请求时服务器返回的响应头中存在以下情况时 没有 Cache-Control 和 Expires Cache-Control 和 Expires 过期了 Cache-Control 的属性设置为 no-cache 时 那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据HTTP的另外两组头信息，分别是：Last-Modified/If-Modified-Since 与 ETag/If-None-Match。 Last-Modified 与 If-Modified-Since 浏览器第一次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT放在响应头中返回给浏览器 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头If-Modified-Since:Thu, 29 Dec 2011 18:23:55发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比 如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回 1234# 第一次请求返回的响应头Cache-Control:max-age=3600Expires: Fri, Jan 12 2018 00:27:04 GMTLast-Modified: Wed, Jan 10 2018 00:27:04 GMT 12# 第二次请求的请求头信息If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT 这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 ETag 与 If-None-Match ETag与If-None-Match ETag/If-None-Match与Last-Modified/If-Modified-Since的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断 浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。 1234# 第一次请求返回的响应头：Cache-Control: public, max-age=31536000ETag: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot; 123# 第二次请求的请求头信息：If-None-Match: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot; 5.4 cookie 和 session session： 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念 cookie：它是一个世纪存在的东西，http 协议中定义在 header 中的字段，可以认为是 session 的一种后端无状态实现 现在我们常说的 session，是为了绕开 cookie 的各种限制，通常借助 cookie本身和后端存储实现的，一种更高级的会话状态实现 session 的常见实现要借助cookie来发送 sessionID 5.5 安全问题，如 XSS 和 CSRF XSS：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动 防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义 CSRF：跨站请求伪造，也称 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。与 XSS 相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。 防范：用户操作验证（验证码），额外验证机制（token使用）等","categories":[],"tags":[]},{"title":"css基础","slug":"CSS","date":"2022-04-24T01:39:40.160Z","updated":"2022-04-24T01:59:31.395Z","comments":true,"path":"2022/04/24/CSS/","link":"","permalink":"https://data-cz.github.io/2022/04/24/CSS/","excerpt":"CSS display: none; 与 visibility: hidden; 的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘 读屏器不会读取display: none;元素内容；会读取visibility: hidden元素内容 css hack原理及常用hack","text":"CSS display: none; 与 visibility: hidden; 的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘 读屏器不会读取display: none;元素内容；会读取visibility: hidden元素内容 css hack原理及常用hack 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。 常见的hack有 属性hack 选择器hack IE条件注释 link 与 @import 的区别 link 是HTML方式， @import 是CSS方式 link 最大限度支持并行下载， @import 过多嵌套导致串行下载，出现FOUC link 可以通过 rel=&quot;alternate stylesheet&quot; 指定候选样式 浏览器对 link 支持早于 @import ，可以使用 @import 对老浏览器隐藏样式 @import 必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import CSS有哪些继承属性 关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadow line-height color visibility cursor display,float,position的关系 如果 display 为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 display 外边距折叠(collapsing margins) 毗邻的两个或多个 margin 会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素或inline-block元素或绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE 盒子模型、W3C 盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？ id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel &#x3D; “external”]） 伪类选择器（a:hover, li:nth-child） 可继承的样式： font-size font-family color, UL LI DL DD DT 不可继承的样式：border padding margin width height CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 CSS3新增伪类有那些？ 1234567891011p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:after 在元素之前添加内容,也可以用来做清除浮动。:before 在元素之后添加内容:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？ 给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto; &#125; 居中一个浮动元素 1234567891011//确定容器的宽高 宽500 高 300 的层//设置层的外边距 .div &#123; width:500px ; height:300px;//高度可以不设 margin: -150px 0 0 -250px; position:relative; //相对定位 background-color:pink; //方便看效果 left:50%; top:50%; &#125; 让绝对定位的div居中 12345678position: absolute;width: 1200px;background: none;margin: 0 auto;top: 0;left: 0;bottom: 0;right: 0; display有哪些值？说明他们的作用 block 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。 inherit 规定从父元素继承 position 属性的值 CSS3有哪些新特性？ 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 增加了旋转,缩放,定位,倾斜,动画，多背景 transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: 用纯CSS创建一个三角形的原理是什么？ 12345678// 把上、左、右三条边隐藏掉（颜色设为 transparent）#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 一个满屏 品 字布局 如何设计? 简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一 IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性 IE下,even对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了 为什么要初始化CSS样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 对BFC规范(块级格式化上下文：block formatting context)的理解？ 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 css定义的权重 12345678910111213141516171819202122// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 display:inline-block 什么时候会显示间隙？(携程) 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin) IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型) 标准(W3C)盒模型：元素宽度 &#x3D; width + padding + border + margin 怪异(IE)盒模型：元素宽度 &#x3D; width + margin 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高 box-sizing 常用的属性有哪些？分别有什么作用？ box-sizing: content-box; &#x2F;&#x2F; 默认的标准(W3C)盒模型元素效果 box-sizing: border-box; &#x2F;&#x2F; 触发怪异(IE)盒模型元素的效果 box-sizing: inherit; &#x2F;&#x2F; 继承父元素 box-sizing 属性的值 CSS选择器有哪些？ id选择器 #id 类选择器 .class 标签选择器 div, h1, p 相邻选择器 h1 + p 子选择器 ul &gt; li 后代选择器 li a 通配符选择器 * 属性选择器 a[rel&#x3D;’external’] 伪类选择器 a:hover, li:nth-child CSS哪些属性可以继承？哪些属性不可以继承？ 可以继承的样式：font-size、font-family、color、list-style、cursor 不可继承的样式：width、height、border、padding、margin、background CSS如何计算选择器优先？ 相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式 含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式 选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1] 在同一组属性设置中，!important 优先级最高，高于行内样式 CSS3新增伪类有哪些？ :root 选择文档的根元素，等同于 html 元素 :empty 选择没有子元素的元素 :target 选取当前活动的目标元素 :not(selector) 选择除 selector 元素意外的元素 :enabled 选择可用的表单元素 :disabled 选择禁用的表单元素 :checked 选择被选中的表单元素 :after 在元素内部最前添加内容 :before 在元素内部最后添加内容 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n :nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数 :nth-child(odd) :nth-child(even) :nth-child(3n+1) :first-child :last-child :only-child :nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n :nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数 :nth-of-type(odd) :nth-of-type(even) :nth-of-type(3n+1) :first-of-type :last-of-type :only-of-type ::selection 选择被用户选取的元素部分 :first-line 选择元素中的第一行 :first-letter 选择元素中的第一个字符 请列举几种隐藏元素的方法 visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 opacity: 0; CSS3属性，设置0可以使一个元素完全透明 position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外 display: none; 元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留 &lt;div hidden=&quot;hidden&quot;&gt; HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态 height: 0; 将元素高度设为 0 ，并消除边框 filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中 rgba() 和 opacity 的透明效果有什么不同？ opacity 作用于元素以及元素内的所有内容（包括文字）的透明度 rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 css 属性 content 有什么作用？ content 属性专门应用在 before&#x2F;after 伪元素上，用于插入额外内容或样式 CSS3有哪些新特性？ 新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)} 弹性盒模型 display: flex; 多列布局 column-count: 5; 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}} 个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);} 颜色透明度 color: rgba(255, 0, 0, 0.75); 圆角 border-radius: 5px; 渐变 background:linear-gradient(red, green, blue); 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); 倒影 box-reflect: below 2px; 文字装饰 text-stroke-color: red; 文字溢出 text-overflow:ellipsis; 背景效果 background-size: 100px 100px; 边框效果 border-image:url(bt_blue.png) 0 10; 转换 旋转 transform: rotate(20deg); 倾斜 transform: skew(150deg, -10deg); 位移 transform: translate(20px, 20px); 缩放 transform: scale(.5); 平滑过渡 transition: all .3s ease-in .1s; 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s; 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？ Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？ 当前样式：getComputedStyle(el, null) VS el.currentStyle 事件对象：e VS window.event 鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y 按键码：e.which VS event.keyCode 文本节点：el.textContent VS el.innerText li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ li排列受到中间空白(回车&#x2F;空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔 解决办法：在ul设置设置font-size&#x3D;0,在li上设置需要的文字大小 什么是外边距重叠？ 重叠的结果是什么？ 外边距重叠就是 margin-collapse 相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负时，折叠结果是两者的相加的和 请写出多种等高布局 在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行 css3 flexbox 布局： .container{display: flex; align-items: stretch;} css垂直居中的方法有哪些？ 如果是单行文本, line-height 设置成和 height 值 1234.vertical &#123; height: 100px; line-height: 100px; &#125; 已知高度的块级子元素，采用绝对定位和负边距 123456789.container &#123; position: relative;&#125;.vertical &#123; height: 300px; /*子元素高度*/ position: absolute; top:50%; /*父元素高度50%*/ margin-top: -150px; /*自身高度一半*/&#125; 未知高度的块级父子元素居中，模拟表格布局 缺点：IE67不兼容，父级 overflow：hidden 失效 12345678.container &#123; display: table; &#125; .content &#123; display: table-cell; vertical-align: middle; &#125; 新增 inline-block 兄弟元素，设置 vertical-align 缺点：需要增加额外标签，IE67不兼容 1234567891011.container &#123; height: 100%;/*定义父级高度，作为参考*/&#125;.extra .vertical&#123; display: inline-block; /*行内块显示*/ vertical-align: middle; /*垂直居中*/&#125;.extra &#123; height: 100%; /*设置新增元素高度为100%*/&#125; 绝对定位配合 CSS3 位移 12345.vertical &#123; position: absolute; top:50%; /*父元素高度50%*/ transform:translateY(-50%, -50%);&#125; CSS3弹性盒模型 12345.container &#123; display:flex; justify-content: center; /*子元素水平居中*/ align-items: center; /*子元素垂直居中*/&#125; 圣杯布局的实现原理？ 要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽 好处：重要的内容放在文档流前面可以优先渲染 原理：利用相对定位、浮动、负边距布局，而不添加额外标签 12345678910111213141516171819202122.container &#123; padding-left: 150px; padding-right: 190px;&#125;.main &#123; float: left; width: 100%;&#125;.left &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -150px;&#125;.right &#123; float: left; width: 190px; margin-left: -190px; position: relative; right: -190px;&#125; 什么是双飞翼布局？实现原理？ 双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。 1234567891011121314151617181920212223242526.container &#123; /*padding-left:150px;*/ /*padding-right:190px;*/&#125;.main-wrap &#123; width: 100%; float: left;&#125;.main &#123; margin-left: 150px; margin-right: 190px;&#125;.left &#123; float: left; width: 150px; margin-left: -100%; /*position: relative;*/ /*left:-150px;*/&#125;.right &#123; float: left; width: 190px; margin-left: -190px; /*position:relative;*/ /*right:-190px;*/&#125; 在CSS样式中常使用 px、em 在表现上有什么区别？ px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能 em 值并不是固定的，会继承父级的字体大小： em &#x3D; 像素值 &#x2F; 父级font-size 为什么要初始化CSS样式？ 不同浏览器对有些标签样式的默认值解析不同 不初始化CSS会造成各现浏览器之间的页面显示差异 可以使用 reset.css 或 Normalize.css 做 CSS 初始化 解释下什么是浮动和它的工作原理？ 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。 工作原理： 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） 浮动元素碰到包含它的边框或者其他浮动元素的边框停留 浮动元素引起的问题？ 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素会跟随其后 列举几种清除浮动的方式？ 添加额外标签，例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 使用 br 标签和其自身的 clear 属性，例如 &lt;br clear=&quot;all&quot; /&gt; 父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1; 父元素也设置浮动 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout 清除浮动最佳实践（after伪元素闭合浮动）： 123456789.clearfix:after&#123; content: &quot;\\200B&quot;; display: table; height: 0; clear: both; &#125; .clearfix&#123; *zoom: 1; &#125; 什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？ 当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC 产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。 等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。 解决方法：使用 link 标签将样式表放在文档 head 介绍使用过的 CSS 预处理器？ CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等） 开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用 使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性 最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS CSS优化、提高性能的方法有哪些？ 多个css合并，尽量减少HTTP请求 将css文件放在页面最上面 移除空的css规则 避免使用CSS表达式 选择器优化嵌套，尽量避免层级过深 充分利用css继承属性，减少代码量 抽象提取公共样式，减少代码量 属性值为0时，不加单位 属性值为小于1的小数时，省略小数点前面的0 css雪碧图 浏览器是怎样解析CSS选择器的？ 浏览器解析 CSS 选择器的方式是从右到左 在网页中的应该使用奇数还是偶数的字体？ 在网页中的应该使用“偶数”字体： 偶数字号相对更容易和 web 设计的其他部分构成比例关系 使用奇数号字体时文本段落无法对齐 宋体的中文网页排布中使用最多的就是 12 和 14 margin和padding分别适合什么场景使用？ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding 抽离样式模块怎么写，说出思路？ CSS可以拆分成2部分：公共CSS 和 业务CSS： 网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务 对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS 元素竖向的百分比设定是相对于容器的高度吗？ 元素竖向的百分比设定是相对于容器的宽度，而不是高度 全屏滚动的原理是什么？ 用到了CSS的那些属性？ 原理类似图片轮播原理，超出隐藏部分，滚动时显示 可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none; 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容： 12345678910111213141516$(window).resize(function () &#123; screenRespond();&#125;);screenRespond();function screenRespond()&#123;var screenWidth = $(window).width();if(screenWidth &lt;= 1800)&#123; $(&quot;body&quot;).attr(&quot;class&quot;, &quot;w1800&quot;);&#125;if(screenWidth &lt;= 1400)&#123; $(&quot;body&quot;).attr(&quot;class&quot;, &quot;w1400&quot;);&#125;if(screenWidth &gt; 1800)&#123; $(&quot;body&quot;).attr(&quot;class&quot;, &quot;&quot;);&#125;&#125; 什么是视差滚动效果，如何给每页做不同的动画？ 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的 实现原理 以 “页面滚动条” 作为 “视差动画进度条” 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 a标签上四个伪类的执行顺序是怎么样的？ link &gt; visited &gt; hover &gt; active L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆 伪元素和伪类的区别和作用？ 伪元素 – 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： 12345p::before &#123;content:&quot;第一章：&quot;;&#125;p::after &#123;content:&quot;Hot!&quot;;&#125;p::first-line &#123;background:red;&#125;p::first-letter &#123;font-size:30px;&#125; 伪类 – 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： 12a:hover &#123;color: #FF00FF&#125;p:first-child &#123;color: red&#125; ::before 和 :after 中双冒号和单冒号有什么区别？ 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法 如何修改Chrome记住密码后自动填充表单的黄色背景？ 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete&#x3D;”off” 解决方案2：input:-webkit-autofill { background-color: transparent; } input [type&#x3D;search] 搜索框右侧小图标如何美化？ 12345678input[type=&quot;search&quot;]::-webkit-search-cancel-button&#123; -webkit-appearance: none; height: 15px; width: 15px; border-radius: 8px; background:url(&quot;images/searchicon.png&quot;) no-repeat 0 0; background-size: 15px 15px;&#125; 网站图片文件，如何点击下载？而非点击预览？ &lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt; iOS safari 如何阻止“橡皮筋效果”？ 1234567$(document).ready(function()&#123; var stopScrolling = function(event) &#123; event.preventDefault(); &#125; document.addEventListener(&#x27;touchstart&#x27;, stopScrolling, false); document.addEventListener(&#x27;touchmove&#x27;, stopScrolling, false);&#125;); 你对 line-height 是如何理解的？ line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中 line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比） 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 &#x3D; 27px 百分比：将计算后的值传递给后代 设置元素浮动后，该元素的 display 值会如何变化？ 设置元素浮动后，该元素的 display 值自动变成 block 怎么让Chrome支持小于12px 的文字？ 12345.shrink&#123; -webkit-transform:scale(0.8); -o-transform:scale(1); display:inline-block;&#125; 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置） 1-webkit-font-smoothing: antialiased; font-style 属性 oblique 是什么意思？ font-style: oblique; 使没有 italic 属性的文字实现倾斜 如果需要手动写动画，你认为最小时间间隔是多久？ 16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s &#x2F; 60 * 1000 ＝ 16.7ms display:inline-block 什么时候会显示间隙？ 相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距 非 inline-block 水平元素设置为 inline-block 也会有水平间距 可以借助 vertical-align:top; 消除垂直间隙 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差 overflow: scroll 时不能平滑滚动的问题怎么处理？ 监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度 方案1： .sub &#123; height: calc(100%-100px); &#125; 方案2： .container &#123; position:relative; &#125; .sub &#123; position: absolute; top: 100px; bottom: 0; &#125; 方案3： .container &#123; display:flex; flex-direction:column; &#125; .sub &#123; flex:1; &#125;","categories":[],"tags":[]},{"title":"this指向问题","slug":"this指向问题","date":"2022-04-13T02:16:10.128Z","updated":"2022-04-24T01:59:31.894Z","comments":true,"path":"2022/04/13/this指向问题/","link":"","permalink":"https://data-cz.github.io/2022/04/13/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","excerpt":"this 指向使用 JavaScript 开发的时候，很多开发者多多少少会被 this 的指向搞蒙圈，但是实际上，关于 this 的指向，记住最核心的一句话：哪个对象调用函数，函数里面的 this 指向哪个对象。","text":"this 指向使用 JavaScript 开发的时候，很多开发者多多少少会被 this 的指向搞蒙圈，但是实际上，关于 this 的指向，记住最核心的一句话：哪个对象调用函数，函数里面的 this 指向哪个对象。 1、普通函数：谁调用指向谁全局变量指向全局对象-window 12345var username = &#x27;cn&#x27;function fn() &#123; alert(this.username) //cn&#125;fu() 有一点需要注意，let 声明的全局变量，不是指向 window 对象 12345let username = &#x27;cn&#x27;function fn() &#123; alert(this.username) //undefined&#125;fn() 2、对象函数调用就是那个函数调用，this 指向哪里 123456789window.b = 2222let obj = &#123; a: 111, fn: function() &#123; alert(this.a) //111 alert(this.b) //undefined &#125;&#125;obj.fn() 3.构造函数中调用JS里的普通函数可以使用new操作符来创建一个对象，此时该函数就是一个构造函数，箭头函数不能作为构造函数。执行new操作符，其实JS内部完成了以下事情： 创建一个空的简单JavaScript对象（即{}）； 将构造函数的prototype绑定为新对象的原型对象 ； 将步骤1新创建的对象作为this的上下文并执行函数 ； 如果该函数没有返回对象，则返回this。 12345678910function A () &#123; this.a = 1 this.func = () =&gt; &#123; return this &#125;&#125;let obj = new A()console.log(obj.a) // 1console.log(obj.func() === obj) // true 4.箭头函数中调用箭头函数的this指向，和箭头函数定义所在上下文的this相同。对于普通函数，this在函数调用时才确定；而对于箭头函数，this在箭头函数定义时就已经确定了，并且不能再被修改。 12345678910111213141516171819let obj = &#123; A () &#123; return () =&gt; &#123; return this &#125; &#125;, B () &#123; return function () &#123; return this &#125; &#125;&#125;let func = obj.A()console.log(func() === obj) // truefunc = obj.B()console.log(func() === obj) // falseconsole.log(func() === window) // true apply、call、bind在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。举个例子 12345678910111213141516171819function fruits() &#123;&#125;fruits.prototype = &#123; color: &#x27;red&#x27;, say: function() &#123; console.log(&#x27;My color is &#x27; + this.color) &#125;&#125;var apple = new fruits()apple.say() //My color is red// 但是如果我们有一个对象banana= &#123;color : &quot;yellow&quot;&#125; ,我们不想对它重新定义 say 方法，//那么我们可以通过 call 或 apply 用 apple 的 say 方法：banana = &#123; color: &#x27;yellow&#x27;&#125;apple.say.call(banana) //My color is yellowapple.say.apply(banana) //My color is yellow apply、call 区别对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样 12func.call(this, arg1, arg2)func.apply(this, [arg1, arg2]) apply、call 实例 123456789101112131415// 数组追加var array1 = [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458];var array2 = [&quot;Doe&quot; , 555 , 100];Array.prototype.push.apply(array1, array2);// array1 值为 [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100]// 获取数组中的最大值和最小值var numbers = [5, 458 , 120 , -215 ];var maxInNumbers = Math.max.apply(Math, numbers), //458var maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458// 验证是否是数组functionisArray(obj)&#123; return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;&#125; bind()bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 123456789101112131415this.num = 9var mymodule = &#123; num: 81, getNum: function() &#123; console.log(this.num) &#125;&#125;mymodule.getNum() // 81var getNum = mymodule.getNumgetNum() // 9, 因为在这个例子中，&quot;this&quot;指向全局对象var boundGetNum = getNum.bind(mymodule)boundGetNum() // 81 当调用 bind 函数后，bind 函数的第一个参数就是原函数作用域中 this 指向的值 123456789101112131415function func() &#123; console.log(this)&#125;let newFunc = func.bind(&#123; a: 1 &#125;)newFunc() // 打印：&#123;a:1&#125;let newFunc2 = func.bind([1, 2, 3])newFunc2() // 打印：[1,2,3]let newFunc3 = func.bind(1)newFunc3() // 打印：Number:&#123;1&#125;let newFunc4 = func.bind(undefined / null)newFunc4() // 打印：window 当传入为 null 或者 undefined 时，在非严格模式下，this 指向为 window。 当传入为简单值时，内部会将简单的值包装成对应类型的对象，数字就调用 Number 方法包装；字符串就调用 String 方法包装；true&#x2F;false 就调用 Boolean 方法包装。要想取到原始值，可以调用 valueOf 方法。 传递的参数的顺序问题 12345678function func(a, b, c) &#123; console.log(a, b, c) // 打印传入的实参&#125;let newFunc = func.bind(&#123;&#125;, 1, 2)newFunc(3) //1,2,3// 可以看到，在 bind 中传递的参数要先传入到原函数中。 返回的新函数被当成构造函数 123456789101112131415161718// 原函数function func(name) &#123; console.log(this) // 打印：通过&#123;name:&#x27;wy&#x27;&#125; this.name = name&#125;func.prototype.hello = function() &#123; console.log(this.name)&#125;let obj = &#123; a: 1 &#125;// 调用bind,返回新函数let newFunc = func.bind(obj)// 把新函数作为构造函数,创建实例let o = new newFunc(&#x27;seven&#x27;)console.log(o.hello()) // 打印：&#x27;seven&#x27;console.log(obj) // 打印：&#123;a:1&#125; 新函数被当成了构造函数，原函数 func 中的 this 不再指向传入给 bind 的第一个参数，而是指向用 new 创建的实例。在通过实例 o 找原型上的方法 hello 时，能够找到原函数 func 原型上的方法。 apply、call、bind 比较 apply 、call 、bind 三者都是用来改变函数的 this 对象的指向的； apply 、call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文； apply 、call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 12345678910111213var obj = &#123; x: 81&#125;var foo = &#123; getX: function() &#123; return this.x &#125;&#125;console.log(foo.getX.bind(obj)()) //81console.log(foo.getX.call(obj)) //81console.log(foo.getX.apply(obj)) //81","categories":[],"tags":[]},{"title":"Vue 组件下拉加载更多","slug":"Vue 组件下拉 加载更多","date":"2022-04-13T01:46:34.427Z","updated":"2022-04-24T01:59:31.416Z","comments":true,"path":"2022/04/13/Vue 组件下拉 加载更多/","link":"","permalink":"https://data-cz.github.io/2022/04/13/Vue%20%E7%BB%84%E4%BB%B6%E4%B8%8B%E6%8B%89%20%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/","excerpt":"一、新建一个loadingMessage组件1.1 监听滑动1&lt;div ref=&quot;content&quot;&gt;&lt;/div&gt; 1.1 挂载监听12345mounted() &#123; this.$refs.content.scrollTag = 0; // 标记监听数 // 挂载监听 this.listenerScroll(); &#125;,","text":"一、新建一个loadingMessage组件1.1 监听滑动1&lt;div ref=&quot;content&quot;&gt;&lt;/div&gt; 1.1 挂载监听12345mounted() &#123; this.$refs.content.scrollTag = 0; // 标记监听数 // 挂载监听 this.listenerScroll(); &#125;, 1.2 加载数据时候设置高度123updated() &#123; this.scrollHeight = this.$refs.content.scrollHeight; // 加载数据时设置滚动内容高&#125;, 1.3 离开页面销毁监听组件123beforeDestroy() &#123; this.destroyScroll()&#125;, 1.3 watch 监听，滑动到顶部事件 12345678910111213141516watch: &#123; scrollHeight: function(newHeight,oldHeight)&#123; // 加载数据时设置滚动条 if(this.scrollTop === 0)&#123; // scrollTop 为0时说明时下拉加载操作 this.$refs.content.scrollTop = newHeight - oldHeight; &#125; &#125;, interlocutor: function()&#123; this.scrollToBottom(); // 滚动条至底 this.listenerScroll(); // 重现挂载监听 &#125;, loadingStatus: function(newStatus,oldStatus) &#123; // 加载完全部数据时移除滚动条监听 if(newStatus === 2)&#123; this.destroyScroll(); &#125; &#125;&#125;, 1.4 监听 滑动 滚动事件 12345678910111213141516171819202122232425262728293031methods: &#123; // 滚动监听处理 handleScroll(e)&#123; this.scrollTop = e.srcElement.scrollTop; // 距离顶部 this.scrollHeight = e.srcElement.scrollHeight; // 滚动内容高 this.clientHeight = e.srcElement.clientHeight; // 滚动区域高 if(this.scrollTop === 0) &#123; // 滚动触顶调用 this.$emit(&#x27;onTouchTop&#x27;); &#125; if(this.scrollHeight === this.scrollTop + this.clientHeight)&#123; // 滚动触底调用 this.$emit(&#x27;onTouchBottom&#x27;); &#125; &#125;, // 添加滚动监听事件 listenerScroll() &#123; if(this.$refs.content.scrollTag !== 0) return; this.$refs.content.scrollTag++; this.$refs.content.addEventListener(&#x27;scroll&#x27;, this.handleScroll, true); &#125;, // 移除滚动监听事件 destroyScroll() &#123; if(this.$refs.content.scrollTag !== 1) return; this.$refs.content.scrollTag--; this.$refs.content.removeEventListener(&quot;scroll&quot;, this.handleScroll, true); &#125;, scrollToBottom() &#123; //滚动条置底 this.$nextTick(function()&#123; this.$refs.content.scrollTop = this.$refs.content.scrollHeight - this.$refs.content.clientHeight; &#125;) &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/tags/Vue/"}]},{"title":"SVG 转地图json 数据","slug":"svg-to-geojson","date":"2022-04-13T01:46:34.408Z","updated":"2022-04-24T01:59:32.016Z","comments":true,"path":"2022/04/13/svg-to-geojson/","link":"","permalink":"https://data-cz.github.io/2022/04/13/svg-to-geojson/","excerpt":"","text":"svg-yo-geojson svg 转 json 源码地址DEMO_HERE","categories":[{"name":"Map","slug":"Map","permalink":"https://data-cz.github.io/categories/Map/"}],"tags":[{"name":"json","slug":"json","permalink":"https://data-cz.github.io/tags/json/"}]},{"title":"2020年你不能不知道的webpack基本配置","slug":"2020年你不能不知道的webpack基本配置","date":"2022-04-13T01:46:32.651Z","updated":"2022-04-24T01:59:31.917Z","comments":true,"path":"2022/04/13/2020年你不能不知道的webpack基本配置/","link":"","permalink":"https://data-cz.github.io/2022/04/13/2020%E5%B9%B4%E4%BD%A0%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","excerpt":"前言在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况： 需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。 传统的html+css+js开发方式不能不能很好地运用less/scss等css预处理器以及ES6+的高级语法。 代码复用性差，可维护性差。","text":"前言在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况： 需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。 传统的html+css+js开发方式不能不能很好地运用less/scss等css预处理器以及ES6+的高级语法。 代码复用性差，可维护性差。 此时就需要一个处理这些问题的工具，webpack应运而生。 webpack可以看做是模块打包工具：它将各种静态资源（比如：javaScript 文件，图片文件，css文件等）视为模块，它能够对这些模块进行解析优化和转换等操作，最后将它们打包在一起，打包后的文件可用于在浏览器中使用。 webpack的优点： 代码转换: typeScript 编译成 javaScript、scss，less 编译成 css. 文件优化：压缩 javaScript、css、html 代码，压缩合并图片。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 扩展性强，插件机制完善。 webpack打包过程： 利用babel完成代码转换,并生成单个文件的依赖 从入口开始递归分析，并生成依赖图谱 将各个引用模块打包为一个立即执行函数 将最终的bundle文件写入bundle.js中 Webpack 的四大核心： entry：js 入口源文件 output：生成文件 loader：进行文件处理 plugins：插件，比 loader 更强大，能使用更多 webpack 的 api Entrywebpack 应该使用哪个模块做为入口文件，来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 单⼊⼝：entry 是⼀个字符串 123module.exports = &#123; entry: &#x27;./src/index.js&#x27;&#125; 多⼊⼝：entry 是⼀个对象 123456module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, manager: &#x27;./src/manager.js&#x27; &#125;&#125; Output告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，这些都可以在webpack的配置文件中指定。 单⼊⼝配置 1234567module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js’, path: __dirname + &#x27;/dist&#x27; &#125;&#125;; 多⼊⼝配置 12345678910module.exports = &#123; entry: &#123; app: &#x27;./src/app.js&#x27;, search: &#x27;./src/search.js&#x27; &#125;, output: &#123; filename: &#x27;[name].js&#x27;, path: __dirname + &#x27;/dist&#x27; &#125;&#125; 通过[name]占位符确保⽂件名称的唯⼀ Loaderloader 让 webpack 能够去处理那些非 javaScript 文件（webpack 自身只理解 javaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 loader的特点 一个Loader 的职责是单一的，只需要完成一种转换 一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数 loader 总是从右到左地被调用。 常用的loader处理样式 css-loader: 加载.css 文件， style-loader:使用 style 标签将 css-loader 内部样式注入到我们的 html 页面 less-loader, sass-loader: 解析css预处理器 处理 js 让你能使用最新的js代码（ES6，ES7…） 让你能使用基于js进行了拓展的语言，比如React的JSX； 处理文件处理图片资源时，我们常用的两种loader是file-loader或者url-loader，两者的主要差异在于。url-loader可以设置图片大小限制，当图片超过限制时，其表现行为等同于file-loader，而当图片不超过限制时，则会将图片以base64的形式打包进css文件，以减少请求次数 处理.vue文件vue-loader 是 webpack 的加载器模块，它使我们可以用 .vue 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 vue-loader 模块允许 webpack 使用单独的加载器模块（例如 sass 或 scss 加载器）提取和处理每个部分。该设置使我们可以使用 .vue 文件无缝编写程序。 开发一个loader","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world-hexo","date":"2022-04-13T01:41:20.276Z","updated":"2022-04-24T01:59:32.258Z","comments":true,"path":"2022/04/13/hello-world-hexo/","link":"","permalink":"https://data-cz.github.io/2022/04/13/hello-world-hexo/","excerpt":"摘要","text":"摘要 正文Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"分类","slug":"分类","permalink":"https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"https://data-cz.github.io/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"https://data-cz.github.io/tags/Games/"}]},{"title":"css","slug":"CSS盒模型及BFC","date":"2022-04-12T10:07:00.353Z","updated":"2022-04-24T01:59:31.987Z","comments":true,"path":"2022/04/12/CSS盒模型及BFC/","link":"","permalink":"https://data-cz.github.io/2022/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/","excerpt":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。","text":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型 代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷&#x2F;margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理&#x2F;BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算","categories":[{"name":"css","slug":"css","permalink":"https://data-cz.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://data-cz.github.io/tags/css/"}]},{"title":"CSS盒模型的认识","slug":"CSS盒模型的认识","date":"2022-04-07T07:34:10.000Z","updated":"2022-04-24T01:59:32.106Z","comments":true,"path":"2022/04/07/CSS盒模型的认识/","link":"","permalink":"https://data-cz.github.io/2022/04/07/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86/","excerpt":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。","text":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型 代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷&#x2F;margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理&#x2F;BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算","categories":[],"tags":[]},{"title":"JS防抖与节流","slug":"js防抖与节流","date":"2020-04-14T02:06:22.000Z","updated":"2022-04-24T01:59:31.899Z","comments":true,"path":"2020/04/14/js防抖与节流/","link":"","permalink":"https://data-cz.github.io/2020/04/14/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"防抖与节流应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。","text":"防抖与节流应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。 非立即执行版 1234567891011function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 立即执行版 12345678910111213function debounce(func,wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果 防抖应用场景 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。 表单验证 按钮提交事件。 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。 函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器 时间戳版: 123456789101112function throttle(func, wait) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 定时器版: 12345678910111213function throttle(func, wait) &#123; let timeout; return function() &#123; let context = this; let args = arguments; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 节流应用场景 按钮点击事件 拖拽事件 onScoll 计算鼠标移动的距离(mousemove) 总结函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[]},{"title":"JS对象创建与拷贝","slug":"js对象及深拷贝","date":"2020-04-14T02:05:22.000Z","updated":"2022-04-24T01:59:31.410Z","comments":true,"path":"2020/04/14/js对象及深拷贝/","link":"","permalink":"https://data-cz.github.io/2020/04/14/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"JS 对象创建与拷贝五种创建对象的方法1、对象字面量的方式 1person = &#123; firstname: &#x27;Mark&#x27;, lastname: &#x27;Yun&#x27;, age: 25, eyecolor: &#x27;black&#x27; &#125;","text":"JS 对象创建与拷贝五种创建对象的方法1、对象字面量的方式 1person = &#123; firstname: &#x27;Mark&#x27;, lastname: &#x27;Yun&#x27;, age: 25, eyecolor: &#x27;black&#x27; &#125; 2、用 function 来模拟无参的构造函数 12345678function Person() &#123;&#125;var person = new Person() //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Classperson.name = &#x27;Mark&#x27;person.age = &#x27;25&#x27;person.work = function() &#123; alert(person.name + &#x27; hello...&#x27;)&#125;person.work() 3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性） 12345678910function Pet(name, age, hobby) &#123; this.name = name //this作用域：当前对象 this.age = age this.hobby = hobby this.eat = function() &#123; alert(&#x27;我叫&#x27; + this.name + &#x27;,我喜欢&#x27; + this.hobby + &#x27;,是个程序员&#x27;) &#125;&#125;var maidou = new Pet(&#x27;麦兜&#x27;, 25, &#x27;coding&#x27;) //实例化、创建对象maidou.eat() //调用eat方法 4、用工厂方式来创建（内置对象） 1234567var wcDog = new Object()wcDog.name = &#x27;旺财&#x27;wcDog.age = 3wcDog.work = function() &#123; alert(&#x27;我是&#x27; + wcDog.name + &#x27;,汪汪汪......&#x27;)&#125;wcDog.work() 5、用原型方式来创建 123456function Dog() &#123;&#125;Dog.prototype.name = &#x27;旺财&#x27;Dog.prototype.eat = function() &#123; alert(this.name + &#x27;是个吃货&#x27;)&#125;var wangcai = new Dog() 合并两个对象 1234let object1 = &#123; a: 1, b: 2, c: 3 &#125;let object2 = &#123; b: 30, c: 40, d: 50 &#125;let merged = &#123; ...object1, ...object2 &#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 深拷贝和浅拷贝js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。 基本数据类型：直接存储在栈(stack)中的数据 引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放。 堆（heap）则是动态分配的内存，大小不定也不会自动释放。 数据的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 10var b = 10console.log(a === b) //true 而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1, 2, 3]var b = [1, 2, 3]console.log(a === b) // false 传值与传址基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子； 123456var a = 10var b = aa++console.log(a) // 11console.log(b) // 10 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125; // a保存了一个空对象的实例var b = a // a和b都指向了这个空对象a.name = &#x27;jozo&#x27;console.log(a.name) // &#x27;jozo&#x27;console.log(b.name) // &#x27;jozo&#x27;b.age = 22console.log(b.age) // 22console.log(a.age) // 22console.log(a == b) // true 深拷贝深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 浅拷贝浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 区别浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制； 1234567891011121314151617let obj = &#123; name: &#x27;Tom&#x27;, age: 18, hobbies: [&#x27;reading&#x27;, &#x27;photography&#x27;]&#125;let obj1 = objlet obj2 = Object.assign(&#123;&#125;, obj)let obj3 = &#123; ...obj &#125;let obj4 = JSON.parse(JSON.stringify(obj))obj.name = &#x27;Jack&#x27;obj.hobbies.push(&#x27;coding&#x27;)console.log(obj) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj1) //&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj2) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj3) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;console.log(obj4) //&#123; name: &#x27;Tom&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125; 从以上例子可以看出，当数据为引用数据类型时 直接赋值属于浅拷贝 Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。 扩展运算符和Object.assign原理一样。 JSON.parse(JSON.stringify(obj))可实现深拷贝 深拷贝的实现 JSON.parse(JSON.stringify(obj)) 但存在一些缺陷 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date，RegExp 类型的数据 会忽略 undefined 实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 1234567891011121314151617181920212223242526function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) if (obj === null || typeof obj !== &#x27;object&#x27;) &#123; //如果不是复杂数据类型，直接返回 return obj &#125; if (hash.has(obj)) &#123; return hash.get(obj) &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor() hash.set(obj, t) for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123; //是否是自身的属性 t[key] = deepClone(obj[key], hash) &#125; &#125; return t&#125;","categories":[],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://data-cz.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/categories/webpack/"},{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/categories/Vue/"},{"name":"Map","slug":"Map","permalink":"https://data-cz.github.io/categories/Map/"},{"name":"分类","slug":"分类","permalink":"https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"},{"name":"css","slug":"css","permalink":"https://data-cz.github.io/categories/css/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://data-cz.github.io/tags/Web/"},{"name":"webpack","slug":"webpack","permalink":"https://data-cz.github.io/tags/webpack/"},{"name":"Vue","slug":"Vue","permalink":"https://data-cz.github.io/tags/Vue/"},{"name":"json","slug":"json","permalink":"https://data-cz.github.io/tags/json/"},{"name":"PS3","slug":"PS3","permalink":"https://data-cz.github.io/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"https://data-cz.github.io/tags/Games/"},{"name":"css","slug":"css","permalink":"https://data-cz.github.io/tags/css/"}]}