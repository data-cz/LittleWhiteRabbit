{"meta":{"title":"面试详解","subtitle":"","description":"","author":"Chen Daxian","url":"https://data-cz.github.io","root":"/LittleWhiteRabbit/"},"pages":[{"title":"","date":"2022-04-11T03:46:10.402Z","updated":"2022-04-11T03:46:10.402Z","comments":true,"path":"404.html","permalink":"https://data-cz.github.io/404.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-12T02:07:57.000Z","updated":"2022-04-12T02:07:57.393Z","comments":true,"path":"tags/index.html","permalink":"https://data-cz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS盒模型BFC","slug":"CSS盒模型及BFC","date":"2022-04-12T10:07:00.353Z","updated":"2022-04-12T10:09:00.801Z","comments":true,"path":"2022/04/12/CSS盒模型及BFC/","link":"","permalink":"https://data-cz.github.io/2022/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/","excerpt":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。","text":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型 代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷&#x2F;margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理&#x2F;BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://data-cz.github.io/tags/CSS/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-07T07:23:27.048Z","updated":"2022-04-12T02:09:04.873Z","comments":true,"path":"2022/04/07/hello-world/","link":"","permalink":"https://data-cz.github.io/2022/04/07/hello-world/","excerpt":"摘要","text":"摘要 正文Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"分类","slug":"分类","permalink":"https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"https://data-cz.github.io/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"https://data-cz.github.io/tags/Games/"}]},{"title":"CSS盒模型的认识","slug":"CSS盒模型的认识","date":"2020-10-13T07:34:10.000Z","updated":"2022-04-12T10:08:40.096Z","comments":true,"path":"2020/10/13/CSS盒模型的认识/","link":"","permalink":"https://data-cz.github.io/2020/10/13/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86/","excerpt":"","text":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型 代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高 方式一：通过DOM节点的 style 样式获取 1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型） 1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的） 1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四 1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷&#x2F;margin重叠 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间 如下图所示： 子元素和父元素之间 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的&#96;margin。 BFC（边距重叠解决方案） BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理&#x2F;BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： BFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC 有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用 举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算","categories":[],"tags":[]}],"categories":[{"name":"分类","slug":"分类","permalink":"https://data-cz.github.io/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://data-cz.github.io/tags/CSS/"},{"name":"PS3","slug":"PS3","permalink":"https://data-cz.github.io/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"https://data-cz.github.io/tags/Games/"}]}